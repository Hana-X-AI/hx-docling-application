# HX Docling Application - SSE and Progress Tracking Test Cases

**Document Type**: SSE and Progress Tracking Test Cases
**Version**: 2.2.0
**Status**: DRAFT
**Created**: 2025-12-12
**Last Updated**: 2025-12-15
**Author**: Julia Santos (Testing & QA Specialist)
**Master Plan Reference**: `project/0.5-test/00-test-plan-overview.md`
**Specification Reference**: `project/0.3-specification/0.3.1-detailed-specification.md` v1.2.1
**Review Reference**: `project/0.5-test/reviews/sse/consolidated-sse-review.md`

---

## Table of Contents

1. [Overview](#1-overview)
2. [SSE Connection Tests](#2-sse-connection-tests)
3. [Progress Event Tests](#3-progress-event-tests)
4. [State Sync Event Tests](#4-state-sync-event-tests)
5. [Cancelled Event Tests](#5-cancelled-event-tests)
6. [Event Buffering Tests](#6-event-buffering-tests)
7. [Reconnection Tests](#7-reconnection-tests)
8. [Polling Fallback Tests](#8-polling-fallback-tests)
9. [Client-Side Hook Tests](#9-client-side-hook-tests)
10. [Redis Pub/Sub Integration Tests](#10-redis-pubsub-integration-tests)
11. [Redis Circuit Breaker Tests](#11-redis-circuit-breaker-tests)
    - 11.1 [Circuit Breaker Behavior](#111-circuit-breaker-behavior)
    - 11.2 [Circuit Breaker State Transitions](#112-circuit-breaker-state-transitions)
    - 11.3 [Cache Invalidation Tests](#113-cache-invalidation-tests)
    - 11.4 [Redis Failover and Recovery Tests](#114-redis-failover-and-recovery-tests)
12. [Database Integration Tests](#12-database-integration-tests)
13. [Component Integration Tests](#13-component-integration-tests)
14. [MCP-to-SSE Integration Tests](#14-mcp-to-sse-integration-tests)
15. [Accessibility Tests](#15-accessibility-tests)
16. [Job State Machine Tests](#16-job-state-machine-tests)
17. [Infrastructure Health Tests](#17-infrastructure-health-tests)
18. [Load and Performance Tests](#18-load-and-performance-tests)
19. [Security Tests](#19-security-tests)
20. [Test Summary](#20-test-summary)

---

## 1. Overview

### 1.1 Purpose

This document defines comprehensive test cases for Server-Sent Events (SSE) functionality, including connection management, progress event handling, event buffering, reconnection logic, and polling fallback mechanisms.

### 1.2 SSE Architecture

```
Browser                     Next.js API                Redis
   |                            |                       |
   |-- GET /events?jobId=X ---->|                       |
   |                            |-- SUBSCRIBE job:X --->|
   |<-- event: connected -------|                       |
   |                            |                       |
   |                            |<-- PUBLISH progress --|
   |<-- event: progress --------|                       |
   |                            |                       |
   |                            |<-- PUBLISH complete --|
   |<-- event: complete --------|                       |
   |                            |                       |
```

### 1.3 SSE Event Types

| Event Type | Purpose | Data Schema |
|------------|---------|-------------|
| connected | Confirms SSE connection | `{ connectionId, timestamp }` |
| progress | Processing progress update | `{ stage, percent, message }` |
| retry | Retry notification | `{ attempt, maxRetries, delay, reason, nextRetryAt }` |
| complete | Processing completed | `{ jobId, status, results: Result[] }` |
| error | Processing failed | `{ code, message, userMessage, suggestedAction, retryable }` |
| cancelled | Job cancelled | `{ jobId, cancelledAt, cancelledBy, reason }` |
| heartbeat | Keep-alive ping | `{ timestamp }` |
| state_sync | Full state synchronization on reconnect | `{ jobId, status, progress, results?, error? }` |

### 1.4 MCP-to-SSE Integration Architecture

#### 1.4.1 Architecture Overview

**Critical Architectural Principle**: The MCP (Model Context Protocol) server uses HTTP/JSON-RPC transport, NOT SSE transport. SSE events are generated by Next.js API routes based on MCP tool execution progress, published via Redis Pub/Sub, and streamed to browser clients. This separation ensures:

- **Decoupling**: MCP server remains independent of client connection management
- **Scalability**: Redis Pub/Sub enables horizontal scaling of Next.js API routes
- **Resilience**: Client reconnection doesn't impact MCP tool execution
- **Flexibility**: Multiple clients can subscribe to same job progress

#### 1.4.2 End-to-End Data Flow

```
┌─────────────────┐           ┌──────────────────┐           ┌─────────────────┐           ┌──────────────┐
│  MCP Server     │           │   Backend API    │           │  Redis Pub/Sub  │           │   Browser    │
│ (HTTP/JSON-RPC) │           │   (FastAPI)      │           │                 │           │  (Next.js)   │
└────────┬────────┘           └────────┬─────────┘           └────────┬────────┘           └──────┬───────┘
         │                             │                             │                            │
         │  1. POST /mcp/invoke-tool   │                             │                            │
         │<────────────────────────────│                             │                            │
         │                             │                             │                            │
         │  2. Tool execution starts   │                             │                            │
         │  progress_callback(10%)     │                             │                            │
         ├────────────────────────────>│                             │                            │
         │                             │  3. PUBLISH job:123:progress│                            │
         │                             ├────────────────────────────>│                            │
         │                             │                             │  4. Notify subscribers     │
         │                             │                             ├───────────────────────────>│
         │                             │                             │                            │
         │  5. progress_callback(50%)  │                             │                            │
         ├────────────────────────────>│  6. PUBLISH job:123:progress│                            │
         │                             ├────────────────────────────>│  7. SSE: event: progress  │
         │                             │                             ├───────────────────────────>│
         │                             │                             │    data: {percent: 50...}  │
         │                             │                             │                            │
         │  8. Tool completion         │                             │                            │
         ├────────────────────────────>│  9. PUBLISH job:123:complete│                            │
         │                             ├────────────────────────────>│ 10. SSE: event: complete  │
         │                             │                             ├───────────────────────────>│
         │                             │                             │                            │
         │ 11. Error in tool execution │                             │                            │
         ├────────────────────────────>│ 12. PUBLISH job:123:error   │                            │
         │                             ├────────────────────────────>│ 13. SSE: event: error     │
         │                             │                             ├───────────────────────────>│
         │                             │                             │                            │
```

**Flow Explanation**:

1. **MCP Tool Invocation**: Backend FastAPI invokes MCP tool via HTTP/JSON-RPC
2. **Progress Callbacks**: MCP server executes tool and calls progress callbacks at checkpoints
3. **Redis Publishing**: Backend converts progress callbacks to Redis Pub/Sub messages
4. **SSE Streaming**: Next.js API routes subscribe to Redis channels and stream events via SSE
5. **Browser Consumption**: React components consume SSE events and update UI

#### 1.4.3 Event Mapping: MCP → SSE

| MCP Event/Stage | MCP Data | SSE Event Type | SSE Event Data | Mapping Logic |
|----------------|----------|----------------|----------------|---------------|
| Tool Invocation Start | `{ tool: "docling_convert", status: "started" }` | `progress` | `{ stage: "parsing", percent: 0, message: "Starting conversion..." }` | Initialization event |
| Docling Parsing Stage | `{ stage: "parsing", progress: 0.25 }` | `progress` | `{ stage: "parsing", percent: 25, message: "Parsing document structure..." }` | Linear mapping: `percent = progress * 100` |
| Docling Conversion Stage | `{ stage: "conversion", progress: 0.60 }` | `progress` | `{ stage: "conversion", percent: 60, message: "Converting to target format..." }` | Stage-specific messages |
| Docling Export Stage | `{ stage: "export", progress: 0.85 }` | `progress` | `{ stage: "export", percent: 85, message: "Exporting results..." }` | Final stage handling |
| MCP Tool Completion | `{ status: "completed", results: [...] }` | `complete` | `{ jobId, status: "COMPLETED", results: [...] }` | Success completion |
| MCP Tool Error | `{ error: { code: "E302", message: "..." } }` | `error` | `{ code: "E302", message: "...", userMessage: "...", retryable: true }` | Error enrichment with user-friendly messages |
| MCP Connection Timeout | `{ error: "timeout" }` | `error` | `{ code: "E501", message: "MCP server timeout", userMessage: "Request timed out", retryable: true }` | Infrastructure error handling |
| MCP Checkpoint | `{ checkpoint: "pre_conversion", state: {...} }` | `state_sync` | `{ jobId, status, progress, checkpoint: "pre_conversion" }` | State synchronization for recovery |

#### 1.4.4 Error Propagation Patterns

**Error Classification and Mapping**:

```typescript
// MCP Error → SSE Error Event Mapping
const mcpErrorToSSE = (mcpError: MCPError): SSEErrorEvent => {
  // MCP tool execution errors
  if (mcpError.code === 'TOOL_EXECUTION_FAILED') {
    return {
      code: 'E302',
      message: mcpError.message,
      userMessage: 'Unable to process your document',
      suggestedAction: 'Try uploading a different file format',
      retryable: true,
      mcpDetails: mcpError.details, // Preserve original error
    };
  }

  // MCP connection timeout
  if (mcpError.code === 'TIMEOUT') {
    return {
      code: 'E501',
      message: 'MCP server timeout',
      userMessage: 'Request timed out. Please try again.',
      suggestedAction: 'Retry your request',
      retryable: true,
      mcpDetails: { timeout: mcpError.timeout },
    };
  }

  // MCP server unavailable
  if (mcpError.code === 'CONNECTION_REFUSED') {
    return {
      code: 'E502',
      message: 'MCP server unavailable',
      userMessage: 'Service temporarily unavailable',
      suggestedAction: 'Please try again in a few moments',
      retryable: true,
      mcpDetails: mcpError.details,
    };
  }

  // Default error mapping
  return {
    code: 'E500',
    message: mcpError.message || 'Unknown MCP error',
    userMessage: 'An unexpected error occurred',
    suggestedAction: 'Contact support if the issue persists',
    retryable: false,
    mcpDetails: mcpError,
  };
};
```

**Error Propagation Flow**:

1. MCP server throws error during tool execution
2. Backend FastAPI catches error, enriches with user-friendly messages
3. Backend publishes error event to Redis: `PUBLISH job:123:error {enriched_error}`
4. Next.js SSE endpoint receives error from Redis subscription
5. SSE streams error event to browser: `event: error\ndata: {code, userMessage, ...}`
6. React error boundary catches error, displays ErrorAlert component
7. User sees actionable error message with retry option (if retryable)

#### 1.4.5 State Synchronization Patterns

**Checkpoint-Based Synchronization**:

MCP tools support checkpointing for long-running operations. Checkpoints enable state recovery on reconnection:

```typescript
// MCP Checkpoint → SSE State Sync
interface MCPCheckpoint {
  checkpoint_id: string;
  stage: 'parsing' | 'conversion' | 'export';
  progress: number;
  state: {
    parsed_pages?: number;
    total_pages?: number;
    current_format?: string;
    // ... stage-specific state
  };
}

// Mapped to SSE state_sync event
interface SSEStateSyncEvent {
  jobId: string;
  status: JobStatus;
  progress: {
    stage: string;
    percent: number;
    message: string;
  };
  checkpoint?: {
    id: string;
    stage: string;
    state: Record<string, any>;
  };
  timestamp: string;
}
```

**Synchronization Scenarios**:

1. **Client Reconnection**: On SSE reconnect, backend queries last MCP checkpoint from Redis
   - Redis key: `job:123:checkpoint:latest`
   - SSE sends `state_sync` event with latest checkpoint data
   - Client reconstructs progress state without duplicate events

2. **MCP Tool Restart**: If MCP server restarts mid-execution
   - Backend detects connection loss via health check
   - Backend attempts MCP reconnection with checkpoint resume
   - If successful, tool resumes from checkpoint; otherwise, error event sent

3. **Progress Gaps**: If SSE connection drops briefly (< 30s)
   - Client automatically reconnects (exponential backoff)
   - Backend sends `state_sync` with current progress
   - Client updates UI to latest state, avoiding progress jumps

**State Consistency Guarantees**:

- **At-Most-Once Progress Events**: Duplicate progress events are deduplicated by `eventId`
- **Monotonic Progress**: Progress percentage never decreases (enforced by backend validation)
- **Checkpoint Idempotency**: Replaying from checkpoint produces identical state
- **Event Ordering**: Redis Pub/Sub preserves event order within a job channel

### 1.5 Test Strategy

- **Server-Side**: Vitest with MSW and Redis mock
- **Client-Side**: React Testing Library with EventSource mock
- **E2E**: Playwright with real SSE connections
- **Test Directory**: `test/sse/`

### 1.6 Test Utilities

The following test utilities are used throughout this document:

```typescript
// Test utility functions
async function createJob(options: { sessionId?: string; status: string }): Promise<Job>;
async function startProcessing(jobId: string): Promise<void>;
function subscribeToJob(jobId: string, callback?: (event: MessageEvent) => void): EventSource;
async function waitForEvent(jobId: string, eventType: string): Promise<any>;
async function publishProgress(jobId: string, data: ProgressData): Promise<string>;
async function getBufferedEvents(jobId: string): Promise<Event[]>;
async function simulateConnectionDrop(jobId: string): Promise<void>;
async function waitForReconnection(jobId: string): Promise<void>;
function interceptRequest(url: string, handler: (req: Request) => void): void;
async function parseSSEResponse(response: Response): Promise<Event[]>;
function mockServerUnavailable(): void;
function mockSSEUnavailable(): void;
function forcePollMode(): void;
async function simulateProcessingError(jobId: string, error: { code: string }): Promise<void>;
async function simulateRetry(jobId: string): Promise<void>;
function sleep(ms: number): Promise<void>;
function getActiveSSEConnections(): number;
async function publishProgressEvent(jobId: string, data: ProgressData): Promise<void>;
```

---

## 2. SSE Connection Tests

### 2.1 Connection Establishment

---

### SSE-CONN-001: Establish SSE Connection

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-001 |
| **Title** | Establish SSE Connection |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-501, Section 7.2 |

**Test Steps**:

```typescript
it('establishes SSE connection and receives connected event', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: MessageEvent[] = [];
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  eventSource.addEventListener('connected', (e) => {
    events.push(e);
  });

  await waitFor(() => {
    expect(events).toHaveLength(1);
    expect(events[0].type).toBe('connected');
  });

  eventSource.close();
});
```

**Expected Result**:
- EventSource connects successfully
- `connected` event received immediately

---

### SSE-CONN-002: SSE Response Headers

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-002 |
| **Title** | Verify SSE Response Headers |
| **Priority** | P1 - High |
| **Spec Reference** | Section 7.2.1 |

**Test Steps**:

```typescript
it('returns correct SSE headers', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const response = await fetch(`/api/v1/process/${job.id}/events`);

  expect(response.headers.get('Content-Type')).toBe('text/event-stream');
  expect(response.headers.get('Cache-Control')).toBe('no-cache');
  expect(response.headers.get('Connection')).toBe('keep-alive');
});
```

---

### SSE-CONN-003: Session Validation

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-003 |
| **Title** | Validate Session for SSE Connection |
| **Priority** | P1 - High (Security) |
| **Spec Reference** | Session isolation |

**Test Steps**:

```typescript
it('rejects SSE connection for wrong session', async () => {
  const job = await createJob({ sessionId: 'session-a', status: 'PROCESSING' });

  const response = await fetch(`/api/v1/process/${job.id}/events`, {
    headers: { Cookie: 'session=session-b' }, // Different session
  });

  expect(response.status).toBe(404);
});
```

---

### SSE-CONN-004: Job Not Found

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-004 |
| **Title** | Handle Non-Existent Job |
| **Priority** | P1 - High |
| **Spec Reference** | E501 |

**Test Steps**:

```typescript
it('returns 404 for non-existent job', async () => {
  const response = await fetch('/api/v1/process/non-existent-uuid/events');

  expect(response.status).toBe(404);
});
```

---

### SSE-CONN-005: Connection Limit

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-005 |
| **Title** | Limit Concurrent SSE Connections |
| **Priority** | P2 - Medium |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('limits concurrent connections per session', async () => {
  const job = await createJob({ sessionId: 'test', status: 'PROCESSING' });

  // Open maximum allowed connections
  const connections = [];
  for (let i = 0; i < 5; i++) {
    connections.push(new EventSource(`/api/v1/process/${job.id}/events`));
  }

  // 6th connection should be rejected or oldest closed
  const response = await fetch(`/api/v1/process/${job.id}/events`);

  // Either 429 or old connection closed
  expect([429, 200]).toContain(response.status);

  connections.forEach(c => c.close());
});
```

---

### SSE-CONN-006: Connected Event Validation

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-006 |
| **Title** | Verify Connected Event Structure |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 7.2.1 |

**Test Steps**:

```typescript
it('connected event has correct structure', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);
  let connectedEvent: any = null;

  eventSource.addEventListener('connected', (e) => {
    connectedEvent = JSON.parse(e.data);
  });

  await waitFor(() => expect(connectedEvent).not.toBeNull());

  expect(connectedEvent).toMatchObject({
    connectionId: expect.any(String),
    timestamp: expect.any(String),
  });

  // Verify connectionId is a valid UUID or identifier
  expect(connectedEvent.connectionId).toMatch(/^[a-zA-Z0-9-]+$/);
  // Verify timestamp is valid ISO 8601
  expect(new Date(connectedEvent.timestamp).toISOString()).toBe(connectedEvent.timestamp);

  eventSource.close();
});
```

---

### SSE-CONN-007: Server Resource Cleanup on Disconnect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-007 |
| **Title** | Server Cleans Up Resources on Client Disconnect |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('server cleans up resources when client disconnects', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  await waitFor(() => expect(eventSource.readyState).toBe(EventSource.OPEN));

  // Verify connection is tracked
  let activeConnections = await getServerActiveConnections(job.id);
  expect(activeConnections).toBe(1);

  // Close connection
  eventSource.close();

  // Wait for cleanup
  await sleep(100);

  // Verify resources cleaned up
  activeConnections = await getServerActiveConnections(job.id);
  expect(activeConnections).toBe(0);
});
```

---

### SSE-CONN-008: AbortController Request Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-008 |
| **Title** | Route Handler AbortController Support |
| **Priority** | P1 - High |
| **Spec Reference** | Next.js Route Handler specification |

**Test Steps**:

```typescript
it('handles AbortController signal for request cancellation', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const controller = new AbortController();

  const fetchPromise = fetch(`/api/v1/process/${job.id}/events`, {
    signal: controller.signal,
  });

  // Allow connection to establish
  await sleep(100);

  // Abort the request
  controller.abort();

  await expect(fetchPromise).rejects.toThrow('aborted');

  // Verify server-side cleanup occurred
  const activeConnections = await getServerActiveConnections(job.id);
  expect(activeConnections).toBe(0);
});
```

---

### SSE-CONN-009: CORS Headers Validation

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-009 |
| **Title** | Verify CORS Headers for SSE Endpoint |
| **Priority** | P1 - High |
| **Spec Reference** | Cross-origin security |

**Test Steps**:

```typescript
it('returns correct CORS headers for SSE endpoint', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const response = await fetch(`/api/v1/process/${job.id}/events`, {
    method: 'OPTIONS',
  });

  // SSE should allow same-origin requests
  expect(response.headers.get('Access-Control-Allow-Origin')).toMatch(/^(https?:\/\/localhost|\*)$/);
  expect(response.headers.get('Access-Control-Allow-Methods')).toContain('GET');
  expect(response.headers.get('Access-Control-Allow-Headers')).toContain('Last-Event-ID');
});
```

---

### SSE-CONN-010: Backpressure Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CONN-010 |
| **Title** | Handle Slow Client Backpressure |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('handles backpressure from slow clients', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Create a slow-consuming client connection
  const response = await fetch(`/api/v1/process/${job.id}/events`);
  const reader = response.body!.getReader();

  // Publish many events rapidly
  for (let i = 0; i < 100; i++) {
    await publishProgress(job.id, { stage: 'test', percent: i });
  }

  // Read events slowly
  await sleep(1000);

  // Server should not crash or block other clients
  const secondClient = new EventSource(`/api/v1/process/${job.id}/events`);

  await waitFor(() => expect(secondClient.readyState).toBe(EventSource.OPEN));

  reader.cancel();
  secondClient.close();
});
```

---

## 3. Progress Event Tests

### 3.1 Progress Event Format

---

### SSE-PROG-001: Progress Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-001 |
| **Title** | Verify Progress Event Structure |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 4.4 |

**Test Steps**:

```typescript
it('progress event has correct structure', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const progressEvent = await waitForEvent(job.id, 'progress');

  expect(progressEvent).toMatchObject({
    stage: expect.stringMatching(/^(upload|parsing|conversion|export|saving|complete)$/),
    percent: expect.any(Number),
    message: expect.any(String),
  });

  expect(progressEvent.percent).toBeGreaterThanOrEqual(0);
  expect(progressEvent.percent).toBeLessThanOrEqual(100);
});
```

---

### SSE-PROG-002: Stage Progression Order

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-002 |
| **Title** | Verify Stage Progression Order |
| **Priority** | P1 - High |
| **Spec Reference** | FR-502 |

**Test Steps**:

```typescript
it('stages progress in correct order', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const stages: string[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    const data = JSON.parse(e.data);
    if (!stages.includes(data.stage)) {
      stages.push(data.stage);
    }
  });

  await waitForEvent(job.id, 'complete');

  const expectedOrder = ['upload', 'parsing', 'conversion', 'export', 'saving'];
  expectedOrder.forEach((stage, index) => {
    expect(stages.indexOf(stage)).toBeLessThanOrEqual(
      stages.indexOf(expectedOrder[index + 1] || 'complete')
    );
  });
});
```

---

### SSE-PROG-003: Percent Range by Stage

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-003 |
| **Title** | Verify Percent Ranges per Stage |
| **Priority** | P1 - High |
| **Spec Reference** | FR-502 Progress Stages table |

**Test Steps**:

```typescript
describe('Stage Percent Ranges', () => {
  const stageRanges = [
    { stage: 'upload', min: 0, max: 10 },
    { stage: 'parsing', min: 10, max: 40 },
    { stage: 'conversion', min: 40, max: 80 },
    { stage: 'export', min: 80, max: 95 },
    { stage: 'saving', min: 95, max: 99 },
  ];

  stageRanges.forEach(({ stage, min, max }) => {
    it(`${stage} stage stays within ${min}-${max}%`, async () => {
      const job = await createJob({ status: 'PROCESSING' });
      startProcessing(job.id);

      const percents: number[] = [];
      const eventSource = subscribeToJob(job.id);

      eventSource.addEventListener('progress', (e) => {
        const data = JSON.parse(e.data);
        if (data.stage === stage) {
          percents.push(data.percent);
        }
      });

      await waitForEvent(job.id, 'complete');

      percents.forEach(percent => {
        expect(percent).toBeGreaterThanOrEqual(min);
        expect(percent).toBeLessThanOrEqual(max);
      });
    });
  });
});
```

---

### SSE-PROG-004: Progress Never Decreases (MAJ-UI-002)

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-004 |
| **Title** | Progress Never Goes Backwards |
| **Priority** | P1 - High |
| **Spec Reference** | MAJ-UI-002, Section 6.2.10 |

**Test Steps**:

```typescript
it('progress percent never decreases', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  let lastPercent = -1;
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    const data = JSON.parse(e.data);
    expect(data.percent).toBeGreaterThanOrEqual(lastPercent);
    lastPercent = data.percent;
  });

  await waitForEvent(job.id, 'complete');
});
```

---

### SSE-PROG-005: Complete Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-005 |
| **Title** | Verify Complete Event Structure |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-501 |

**Test Steps**:

```typescript
it('complete event contains result metadata', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const completeEvent = await waitForEvent(job.id, 'complete');

  expect(completeEvent).toMatchObject({
    jobId: job.id,
    status: 'COMPLETE',
    results: expect.arrayContaining([
      expect.objectContaining({
        format: expect.stringMatching(/^(MARKDOWN|HTML|JSON)$/),
        size: expect.any(Number),
      }),
    ]),
  });
});
```

---

### SSE-PROG-006: Error Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-006 |
| **Title** | Verify Error Event Structure |
| **Priority** | P1 - High |
| **Spec Reference** | FR-801 |

**Test Steps**:

```typescript
it('error event contains error details', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  simulateProcessingError(job.id, { code: 'E302' });

  const errorEvent = await waitForEvent(job.id, 'error');

  expect(errorEvent).toMatchObject({
    code: 'E302',
    message: expect.any(String),
    userMessage: expect.any(String),
    suggestedAction: expect.any(String),
    retryable: expect.any(Boolean),
  });
});
```

---

### SSE-PROG-007: Retry Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-007 |
| **Title** | Verify Retry Event Structure |
| **Priority** | P1 - High |
| **Spec Reference** | FR-803 |

**Test Steps**:

```typescript
it('retry event contains retry information', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  simulateRetry(job.id);

  const retryEvent = await waitForEvent(job.id, 'retry');

  expect(retryEvent).toMatchObject({
    attempt: expect.any(Number),
    maxRetries: 3,
    delay: expect.any(Number),
    reason: expect.any(String),
    nextRetryAt: expect.any(String), // ISO 8601 timestamp
  });

  expect(retryEvent.attempt).toBeGreaterThanOrEqual(1);
  expect(retryEvent.attempt).toBeLessThanOrEqual(3);
  // Verify delay follows exponential backoff pattern
  expect(retryEvent.delay).toBeGreaterThanOrEqual(1000);
  // Verify nextRetryAt is a valid ISO timestamp
  expect(new Date(retryEvent.nextRetryAt).toISOString()).toBe(retryEvent.nextRetryAt);
});
```

---

### SSE-PROG-008: Heartbeat Events

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PROG-008 |
| **Title** | Verify Heartbeat Events |
| **Priority** | P1 - High |
| **Spec Reference** | SSE_HEARTBEAT_INTERVAL_MS |

**Test Steps**:

```typescript
it('sends heartbeat events at configured interval', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const heartbeats: number[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('heartbeat', () => {
    heartbeats.push(Date.now());
  });

  // Wait for 3 heartbeats
  await new Promise(r => setTimeout(r, 50000));

  expect(heartbeats.length).toBeGreaterThanOrEqual(3);

  // Verify interval (15s with tolerance)
  for (let i = 1; i < heartbeats.length; i++) {
    const diff = heartbeats[i] - heartbeats[i - 1];
    expect(diff).toBeGreaterThan(14000);
    expect(diff).toBeLessThan(16000);
  }
}, 60000);
```

---

## 4. State Sync Event Tests

### 4.1 State Synchronization on Reconnect

The `state_sync` event is critical for reconnection data integrity. When a client reconnects with a `Last-Event-ID`, the server must send a `state_sync` event to ensure the client has consistent state before resuming normal event delivery.

---

### SSE-SYNC-001: State Sync Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SYNC-001 |
| **Title** | Verify State Sync Event Structure |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 4.4, Reconnection Protocol |

**Test Steps**:

```typescript
it('state_sync event has correct structure', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for some progress
  await sleep(2000);

  // Get current event ID
  let lastEventId: string | null = null;
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('progress', (e) => {
    lastEventId = e.lastEventId;
  });

  await waitFor(() => expect(lastEventId).not.toBeNull());
  eventSource.close();

  // Reconnect with Last-Event-ID
  const reconnectSource = new EventSource(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': lastEventId! },
  });

  let stateSyncEvent: any = null;
  reconnectSource.addEventListener('state_sync', (e) => {
    stateSyncEvent = JSON.parse(e.data);
  });

  await waitFor(() => expect(stateSyncEvent).not.toBeNull());

  expect(stateSyncEvent).toMatchObject({
    jobId: job.id,
    status: expect.stringMatching(/^(PROCESSING|COMPLETE|FAILED)$/),
    progress: expect.objectContaining({
      stage: expect.any(String),
      percent: expect.any(Number),
    }),
  });

  reconnectSource.close();
});
```

---

### SSE-SYNC-002: State Sync Sent Before Buffered Events

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SYNC-002 |
| **Title** | State Sync Precedes Buffered Events on Reconnect |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 4.4, Event Ordering |

**Test Steps**:

```typescript
it('sends state_sync before buffered events on reconnect', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Publish multiple events
  const eventIds: string[] = [];
  for (let i = 0; i < 10; i++) {
    const id = await publishProgress(job.id, { stage: 'test', percent: i * 10 });
    eventIds.push(id);
  }

  // Reconnect from middle of event stream
  const events: { type: string; id?: string }[] = [];
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': eventIds[4] },
  });

  eventSource.addEventListener('state_sync', (e) => {
    events.push({ type: 'state_sync', id: e.lastEventId });
  });

  eventSource.addEventListener('progress', (e) => {
    events.push({ type: 'progress', id: e.lastEventId });
  });

  await waitFor(() => events.length >= 2);

  // First event must be state_sync
  expect(events[0].type).toBe('state_sync');
  // Progress events follow
  expect(events.slice(1).every(e => e.type === 'progress')).toBe(true);

  eventSource.close();
});
```

---

### SSE-SYNC-003: State Sync with Complete Job

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SYNC-003 |
| **Title** | State Sync Includes Results for Completed Jobs |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 4.4 |

**Test Steps**:

```typescript
it('state_sync includes results for completed jobs', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for completion
  await waitForEvent(job.id, 'complete');

  // Reconnect to completed job
  let stateSyncEvent: any = null;
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': 'some-old-id' },
  });

  eventSource.addEventListener('state_sync', (e) => {
    stateSyncEvent = JSON.parse(e.data);
  });

  await waitFor(() => expect(stateSyncEvent).not.toBeNull());

  expect(stateSyncEvent).toMatchObject({
    jobId: job.id,
    status: 'COMPLETE',
    progress: { stage: 'complete', percent: 100 },
    results: expect.arrayContaining([
      expect.objectContaining({
        format: expect.any(String),
        size: expect.any(Number),
      }),
    ]),
  });

  eventSource.close();
});
```

---

### SSE-SYNC-004: State Sync with Failed Job

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SYNC-004 |
| **Title** | State Sync Includes Error for Failed Jobs |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 4.4 |

**Test Steps**:

```typescript
it('state_sync includes error for failed jobs', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  simulateProcessingError(job.id, { code: 'E302' });

  // Wait for error
  await waitForEvent(job.id, 'error');

  // Reconnect to failed job
  let stateSyncEvent: any = null;
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': 'some-old-id' },
  });

  eventSource.addEventListener('state_sync', (e) => {
    stateSyncEvent = JSON.parse(e.data);
  });

  await waitFor(() => expect(stateSyncEvent).not.toBeNull());

  expect(stateSyncEvent).toMatchObject({
    jobId: job.id,
    status: 'FAILED',
    error: expect.objectContaining({
      code: 'E302',
      message: expect.any(String),
    }),
  });

  eventSource.close();
});
```

---

### SSE-SYNC-005: State Sync on Buffer Exhaustion

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SYNC-005 |
| **Title** | Send State Sync When Requested Events No Longer Buffered |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-503, Buffer management |

**Test Steps**:

```typescript
it('sends state_sync when Last-Event-ID not in buffer', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Publish more events than buffer can hold (buffer size = 100)
  for (let i = 0; i < 150; i++) {
    await publishProgress(job.id, { stage: 'test', percent: i % 100 });
  }

  // Try to reconnect with an event ID that's been evicted
  const oldEventId = `${job.id.substring(0, 8)}-1000000000000-0001`;

  let stateSyncReceived = false;
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': oldEventId },
  });

  eventSource.addEventListener('state_sync', () => {
    stateSyncReceived = true;
  });

  await waitFor(() => expect(stateSyncReceived).toBe(true));

  eventSource.close();
});
```

---

## 5. Cancelled Event Tests

### 5.1 Cancellation Event Structure

The `cancelled` event (FR-406) signals that job processing was cancelled by user action. This event must include comprehensive cancellation details to enable proper UI updates and audit logging.

---

### SSE-CANCEL-001: Cancelled Event Structure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CANCEL-001 |
| **Title** | Verify Cancelled Event Structure |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-406 |

**Test Steps**:

```typescript
it('cancelled event has correct structure', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for processing to start
  await waitFor(() => getJobStatus(job.id) === 'PROCESSING');

  // Cancel the job
  await cancelJob(job.id);

  const cancelledEvent = await waitForEvent(job.id, 'cancelled');

  expect(cancelledEvent).toMatchObject({
    jobId: job.id,
    cancelledAt: expect.any(String),
    cancelledBy: expect.stringMatching(/^(user|system|timeout)$/),
    reason: expect.any(String),
  });

  // Verify cancelledAt is valid ISO timestamp
  expect(new Date(cancelledEvent.cancelledAt).toISOString()).toBe(cancelledEvent.cancelledAt);
});
```

---

### SSE-CANCEL-002: Cancelled Event Stops Progress Updates

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CANCEL-002 |
| **Title** | No Progress Events After Cancellation |
| **Priority** | P1 - High |
| **Spec Reference** | FR-406 |

**Test Steps**:

```typescript
it('no progress events after cancellation', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const events: string[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', () => events.push('progress'));
  eventSource.addEventListener('cancelled', () => events.push('cancelled'));

  // Wait for some progress
  await waitFor(() => events.filter(e => e === 'progress').length >= 3);

  // Cancel the job
  await cancelJob(job.id);

  // Wait for cancelled event
  await waitFor(() => events.includes('cancelled'));

  // Record event count at cancellation
  const eventsAtCancellation = events.length;

  // Wait a bit to ensure no more events
  await sleep(2000);

  // Should have no new progress events after cancellation
  const eventsAfterCancellation = events.slice(eventsAtCancellation);
  expect(eventsAfterCancellation.filter(e => e === 'progress')).toHaveLength(0);

  eventSource.close();
});
```

---

### SSE-CANCEL-003: Cancelled Event with Partial Results

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CANCEL-003 |
| **Title** | Cancelled Event May Include Partial Results |
| **Priority** | P1 - High |
| **Spec Reference** | FR-406 |

**Test Steps**:

```typescript
it('cancelled event includes partial results if available', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait until export stage (partial results available)
  await waitFor(async () => {
    const progress = await getJobProgress(job.id);
    return progress.stage === 'export';
  });

  // Cancel during export
  await cancelJob(job.id);

  const cancelledEvent = await waitForEvent(job.id, 'cancelled');

  // May have partial results if cancellation occurred late
  if (cancelledEvent.partialResults) {
    expect(cancelledEvent.partialResults).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          format: expect.any(String),
          size: expect.any(Number),
        }),
      ])
    );
  }
});
```

---

### SSE-CANCEL-004: Cancel Idempotent

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CANCEL-004 |
| **Title** | Multiple Cancel Requests Are Idempotent |
| **Priority** | P1 - High |
| **Spec Reference** | FR-406 |

**Test Steps**:

```typescript
it('multiple cancel requests send only one cancelled event', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const cancelledEvents: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('cancelled', (e) => {
    cancelledEvents.push(JSON.parse(e.data));
  });

  // Send multiple cancel requests
  await Promise.all([
    cancelJob(job.id),
    cancelJob(job.id),
    cancelJob(job.id),
  ]);

  // Wait for event(s)
  await sleep(2000);

  // Should receive exactly one cancelled event
  expect(cancelledEvents).toHaveLength(1);

  eventSource.close();
});
```

---

### SSE-CANCEL-005: Cancel Completed Job Has No Effect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CANCEL-005 |
| **Title** | Cannot Cancel Already Completed Job |
| **Priority** | P1 - High |
| **Spec Reference** | FR-406 |

**Test Steps**:

```typescript
it('cancelling completed job has no effect', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for completion
  await waitForEvent(job.id, 'complete');

  const events: string[] = [];
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('cancelled', () => events.push('cancelled'));

  // Try to cancel completed job
  const response = await cancelJob(job.id);

  // Should fail or return status indicating job already complete
  expect([400, 409]).toContain(response.status);

  // No cancelled event should be sent
  await sleep(1000);
  expect(events).not.toContain('cancelled');

  eventSource.close();
});
```

---

## 6. Event Buffering Tests

### 6.1 Event ID Format

---

### SSE-BUF-001: Event ID Format

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-001 |
| **Title** | Verify Event ID Format |
| **Priority** | P1 - High |
| **Spec Reference** | Section 4.4.1 |

**Test Steps**:

```typescript
it('event ID follows correct format', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  let eventId: string | null = null;
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  eventSource.addEventListener('progress', (e) => {
    eventId = e.lastEventId;
  });

  await waitFor(() => expect(eventId).not.toBeNull());

  // Format: {jobId-8chars}-{timestamp}-{sequence-4digits}
  const pattern = /^[a-f0-9]{8}-\d+-\d{4}$/;
  expect(eventId).toMatch(pattern);

  eventSource.close();
});
```

---

### SSE-BUF-002: Event ID Monotonically Increasing

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-002 |
| **Title** | Event IDs Are Monotonically Increasing |
| **Priority** | P1 - High |
| **Spec Reference** | Section 4.4.1 |

**Test Steps**:

```typescript
it('event IDs increase monotonically', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const eventIds: string[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.onmessage = (e) => {
    if (e.lastEventId) {
      eventIds.push(e.lastEventId);
    }
  };

  await waitForEvent(job.id, 'complete');

  // Verify sequence numbers increase
  for (let i = 1; i < eventIds.length; i++) {
    const prev = parseInt(eventIds[i - 1].split('-')[2]);
    const curr = parseInt(eventIds[i].split('-')[2]);
    expect(curr).toBeGreaterThan(prev);
  }
});
```

---

### SSE-BUF-003: Event Buffer Size Limit

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-003 |
| **Title** | Event Buffer Respects Size Limit |
| **Priority** | P1 - High |
| **Spec Reference** | SSE_EVENT_BUFFER_SIZE |

**Test Steps**:

```typescript
it('buffers maximum 100 events', async () => {
  const jobId = 'buffer-test-job';

  // Publish 150 events
  for (let i = 0; i < 150; i++) {
    await publishProgress(jobId, { stage: 'test', percent: i });
  }

  const bufferedEvents = await getBufferedEvents(jobId);

  expect(bufferedEvents.length).toBeLessThanOrEqual(100);
});
```

---

### SSE-BUF-004: Event Buffer TTL

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-004 |
| **Title** | Event Buffer Expires After TTL |
| **Priority** | P1 - High |
| **Spec Reference** | SSE_EVENT_BUFFER_TTL_MS |

**Test Steps**:

```typescript
it('buffer expires after configured TTL', async () => {
  const jobId = 'ttl-test-job';

  await publishProgress(jobId, { stage: 'test', percent: 50 });

  // Immediately verify event exists
  let events = await getBufferedEvents(jobId);
  expect(events.length).toBe(1);

  // Wait for TTL (5 minutes in prod, shortened for test)
  await sleep(6000); // 6 seconds with test TTL of 5s

  events = await getBufferedEvents(jobId);
  expect(events.length).toBe(0);
}, 10000);
```

---

### SSE-BUF-005: Out-of-Order Event Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-005 |
| **Title** | Handle Out-of-Order Events from Concurrent Publishers |
| **Priority** | P1 - High |
| **Spec Reference** | Section 4.4.1 |

**Test Steps**:

```typescript
it('handles out-of-order events correctly', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Simulate concurrent publishers sending events with slightly out-of-order timestamps
  await Promise.all([
    publishProgress(job.id, { stage: 'parsing', percent: 20 }),
    publishProgress(job.id, { stage: 'parsing', percent: 25 }),
    publishProgress(job.id, { stage: 'parsing', percent: 22 }),
  ]);

  const events: number[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    const data = JSON.parse(e.data);
    events.push(data.percent);
  });

  await waitFor(() => events.length >= 3);

  // Events should be delivered in buffer order (sorted by event ID)
  for (let i = 1; i < events.length; i++) {
    // Progress percent should not go backwards within same stage
    expect(events[i]).toBeGreaterThanOrEqual(events[i - 1]);
  }

  eventSource.close();
});
```

---

### SSE-BUF-006: Event Deduplication

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-006 |
| **Title** | Buffer Deduplicates Events by ID |
| **Priority** | P1 - High |
| **Spec Reference** | Section 4.4.1 |

**Test Steps**:

```typescript
it('buffer deduplicates events with same ID', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Manually publish events with duplicate IDs (simulating network retry)
  const eventId = `${job.id.substring(0, 8)}-${Date.now()}-0001`;
  await publishEventWithId(job.id, eventId, { stage: 'test', percent: 50 });
  await publishEventWithId(job.id, eventId, { stage: 'test', percent: 50 }); // Duplicate

  const bufferedEvents = await getBufferedEvents(job.id);

  // Should only have one event with this ID
  const eventsWithId = bufferedEvents.filter(e => e.id === eventId);
  expect(eventsWithId).toHaveLength(1);
});
```

---

### SSE-BUF-007: Sorted Set Memory Management

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-BUF-007 |
| **Title** | Redis Sorted Set Memory Management |
| **Priority** | P1 - High |
| **Spec Reference** | Redis buffer implementation |

**Test Steps**:

```typescript
it('maintains sorted set size within memory limits', async () => {
  const jobId = 'memory-test-job';

  // Publish 500 events rapidly
  for (let i = 0; i < 500; i++) {
    await publishProgress(jobId, { stage: 'test', percent: i % 100 });
  }

  // Check Redis sorted set size
  const setSize = await redis.zcard(`hx-docling:job:${jobId}:events`);

  // Should be trimmed to max buffer size (100)
  expect(setSize).toBeLessThanOrEqual(100);

  // Oldest events should be removed
  const events = await getBufferedEvents(jobId);
  const firstEventSequence = parseInt(events[0].id.split('-')[2]);
  expect(firstEventSequence).toBeGreaterThan(400); // Should have removed early events
});
```

---

## 7. Reconnection Tests

### 7.1 Client Reconnection

---

### SSE-REC-001: Automatic Reconnection

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-001 |
| **Title** | Client Reconnects Automatically |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('reconnects automatically on connection drop', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  let connectionCount = 0;
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  eventSource.addEventListener('connected', () => {
    connectionCount++;
  });

  // Wait for initial connection
  await waitFor(() => expect(connectionCount).toBe(1));

  // Simulate server dropping connection
  await simulateConnectionDrop(job.id);

  // Wait for reconnection
  await waitFor(() => expect(connectionCount).toBe(2), { timeout: 5000 });

  eventSource.close();
});
```

---

### SSE-REC-002: Last-Event-ID on Reconnect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-002 |
| **Title** | Sends Last-Event-ID on Reconnect |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('sends Last-Event-ID header on reconnect', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  let lastEventId: string | null = null;
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    lastEventId = e.lastEventId;
  });

  await waitFor(() => expect(lastEventId).not.toBeNull());

  // Capture reconnect request
  let reconnectHeaders: Headers | null = null;
  interceptRequest(`/api/v1/process/${job.id}/events`, (req) => {
    reconnectHeaders = req.headers;
  });

  // Force reconnection
  await simulateConnectionDrop(job.id);
  await waitForReconnection(job.id);

  expect(reconnectHeaders?.get('Last-Event-ID')).toBe(lastEventId);
});
```

---

### SSE-REC-003: Resume from Last-Event-ID

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-003 |
| **Title** | Server Resumes from Last-Event-ID |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('server sends events after Last-Event-ID', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Publish 10 events
  const eventIds: string[] = [];
  for (let i = 0; i < 10; i++) {
    const id = await publishProgress(job.id, { stage: 'test', percent: i * 10 });
    eventIds.push(id);
  }

  // Connect with Last-Event-ID pointing to event 5
  const response = await fetch(`/api/v1/process/${job.id}/events`, {
    headers: { 'Last-Event-ID': eventIds[4] },
  });

  const events = await parseSSEResponse(response);

  // Should receive events 6-10 (after event 5)
  expect(events.length).toBeGreaterThanOrEqual(5);
  expect(events[0].id).toBe(eventIds[5]);
});
```

---

### SSE-REC-004: Exponential Backoff on Retry

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-004 |
| **Title** | Exponential Backoff on Connection Failure |
| **Priority** | P1 - High |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('applies exponential backoff on reconnection', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Make server unavailable
  mockServerUnavailable();

  const reconnectAttempts: number[] = [];
  const { useSSE } = await import('@/hooks/useSSE');
  const { connectionStatus } = useSSE(job.id, {
    onReconnectAttempt: (attempt) => {
      reconnectAttempts.push(Date.now());
    },
  });

  // Wait for several reconnection attempts
  await sleep(10000);

  // Verify backoff (1s base, 2s, 4s, 8s with 2x multiplier and 30s max)
  // Per specification: SSE_RECONNECT_BASE_DELAY_MS = 1000
  expect(reconnectAttempts.length).toBeGreaterThanOrEqual(3);

  const delay1 = reconnectAttempts[1] - reconnectAttempts[0];
  const delay2 = reconnectAttempts[2] - reconnectAttempts[1];

  // First delay should be ~1s (with tolerance)
  expect(delay1).toBeGreaterThanOrEqual(900);
  expect(delay1).toBeLessThanOrEqual(1500);
  // Second delay should be ~2s (double the first)
  expect(delay2).toBeGreaterThanOrEqual(delay1 * 1.5);
}, 15000);
```

---

### SSE-REC-005: Max Reconnection Attempts

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-005 |
| **Title** | Stop After Max Reconnection Attempts |
| **Priority** | P1 - High |
| **Spec Reference** | SSE_MAX_RECONNECT_ATTEMPTS |

**Test Steps**:

```typescript
it('stops reconnecting after 10 attempts', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  mockServerUnavailable();

  let attemptCount = 0;
  let fallbackTriggered = false;

  const { useSSE } = await import('@/hooks/useSSE');
  useSSE(job.id, {
    onReconnectAttempt: () => attemptCount++,
    onFallbackToPolling: () => fallbackTriggered = true,
  });

  // Wait for all attempts to exhaust
  await waitFor(() => expect(fallbackTriggered).toBe(true), { timeout: 60000 });

  expect(attemptCount).toBe(10);
}, 70000);
```

---

### SSE-REC-006: No Duplicate Events After Reconnect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REC-006 |
| **Title** | No Duplicate Events After Reconnection |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.2.10 (MAJ-UI-009) |

**Test Steps**:

```typescript
it('filters duplicate events after reconnection', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const eventIds = new Set<string>();
  let duplicateFound = false;

  const { useSSE } = await import('@/hooks/useSSE');
  useSSE(job.id, {
    onProgress: (event) => {
      if (eventIds.has(event.id)) {
        duplicateFound = true;
      }
      eventIds.add(event.id);
    },
  });

  // Wait for some events
  await sleep(2000);

  // Force reconnection
  await simulateConnectionDrop(job.id);
  await waitForReconnection(job.id);

  // Continue receiving events
  await waitForEvent(job.id, 'complete');

  expect(duplicateFound).toBe(false);
});
```

---

## 8. Polling Fallback Tests

### 8.1 Fallback Activation

---

### SSE-POLL-001: Fallback to Polling After Max Retries

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-POLL-001 |
| **Title** | Fallback to Polling |
| **Priority** | P1 - High |
| **Spec Reference** | FR-504 |

**Test Steps**:

```typescript
it('falls back to polling after SSE retries exhausted', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  mockSSEUnavailable();

  let pollingStarted = false;
  const { useSSE } = await import('@/hooks/useSSE');
  const { connectionStatus } = useSSE(job.id, {
    onConnectionChange: (status) => {
      if (status === 'polling') {
        pollingStarted = true;
      }
    },
  });

  await waitFor(() => expect(pollingStarted).toBe(true), { timeout: 60000 });
}, 70000);
```

---

### SSE-POLL-002: Polling Interval

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-POLL-002 |
| **Title** | Verify Polling Interval |
| **Priority** | P1 - High |
| **Spec Reference** | FR-504 (2s interval) |

**Test Steps**:

```typescript
it('polls at 2 second intervals', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Force polling mode
  forcePollMode();

  const pollRequests: number[] = [];
  interceptRequest(`/api/v1/jobs/${job.id}`, () => {
    pollRequests.push(Date.now());
  });

  const { useSSE } = await import('@/hooks/useSSE');
  useSSE(job.id);

  // Wait for several polls
  await sleep(7000);

  expect(pollRequests.length).toBeGreaterThanOrEqual(3);

  for (let i = 1; i < pollRequests.length; i++) {
    const diff = pollRequests[i] - pollRequests[i - 1];
    expect(diff).toBeGreaterThanOrEqual(1800);
    expect(diff).toBeLessThanOrEqual(2200);
  }
}, 10000);
```

---

### SSE-POLL-003: Polling UI Indicator

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-POLL-003 |
| **Title** | Show Polling Mode UI |
| **Priority** | P1 - High |
| **Spec Reference** | FR-504 |

**Test Steps**:

```typescript
it('displays compatibility mode indicator', async ({ page }) => {
  const job = await createJob({ status: 'PROCESSING' });

  // Block SSE endpoint
  await page.route('**/events', route => route.abort());

  await page.goto('/');
  await uploadFile(page, 'test.pdf');
  await page.click('button:has-text("Process")');

  // Wait for fallback
  await page.waitForSelector('[data-testid="connection-status"]:has-text("Using backup connection")');
});
```

---

### SSE-POLL-004: Polling Completes Processing

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-POLL-004 |
| **Title** | Processing Completes via Polling |
| **Priority** | P1 - High |
| **Spec Reference** | FR-504 |

**Test Steps**:

```typescript
it('processing completes successfully in polling mode', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  forcePollMode();

  let completed = false;
  const { useSSE } = await import('@/hooks/useSSE');
  useSSE(job.id, {
    onComplete: () => completed = true,
  });

  startProcessing(job.id);

  await waitFor(() => expect(completed).toBe(true), { timeout: 120000 });
}, 130000);
```

---

## 9. Client-Side Hook Tests

### 9.1 useSSE Hook Tests

---

### SSE-HOOK-001: Initial State

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-001 |
| **Title** | useSSE Initial State |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('returns correct initial state', () => {
  const { result } = renderHook(() => useSSE('test-job-id'));

  expect(result.current.progress).toEqual({
    stage: null,
    percent: 0,
    message: '',
  });
  expect(result.current.connectionStatus).toBe('disconnected');
  expect(result.current.error).toBeNull();
});
```

---

### SSE-HOOK-002: Connection Status Updates

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-002 |
| **Title** | Connection Status State Machine |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('updates connection status correctly', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const { result } = renderHook(() => useSSE(job.id));

  // Initial
  expect(result.current.connectionStatus).toBe('disconnected');

  // After connection
  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });

  // Simulate disconnect
  await simulateConnectionDrop(job.id);

  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('reconnecting');
  });
});
```

---

### SSE-HOOK-003: Progress State Updates

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-003 |
| **Title** | Progress State Updates |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('updates progress from SSE events', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const { result } = renderHook(() => useSSE(job.id));

  startProcessing(job.id);

  await waitFor(() => {
    expect(result.current.progress.percent).toBeGreaterThan(0);
    expect(result.current.progress.stage).not.toBeNull();
  });
});
```

---

### SSE-HOOK-004: Disconnect Cleanup

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-004 |
| **Title** | Cleanup on Unmount |
| **Priority** | P1 - High |
| **Spec Reference** | React hook lifecycle |

**Test Steps**:

```typescript
it('closes connection on unmount', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const { unmount, result } = renderHook(() => useSSE(job.id));

  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });

  const activeConnections = getActiveSSEConnections();
  expect(activeConnections).toBe(1);

  unmount();

  await waitFor(() => {
    expect(getActiveSSEConnections()).toBe(0);
  });
});
```

---

### SSE-HOOK-005: Manual Disconnect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-005 |
| **Title** | Manual Disconnect Function |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('disconnect() closes connection', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const { result } = renderHook(() => useSSE(job.id));

  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });

  act(() => {
    result.current.disconnect();
  });

  expect(result.current.connectionStatus).toBe('disconnected');
});
```

---

### SSE-HOOK-006: Reconnecting State

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-006 |
| **Title** | Hook Exposes Reconnecting State |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('exposes reconnecting state during reconnection', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const { result } = renderHook(() => useSSE(job.id));

  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });

  // Simulate connection drop
  await simulateConnectionDrop(job.id);

  // Should transition to reconnecting
  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('reconnecting');
  });

  // Should eventually reconnect
  await waitFor(() => {
    expect(result.current.connectionStatus).toBe('connected');
  });
});
```

---

### SSE-HOOK-007: Reconnection Attempt Counter

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-007 |
| **Title** | Hook Exposes Reconnection Attempt Count |
| **Priority** | P1 - High |
| **Spec Reference** | Section 6.3.3 |

**Test Steps**:

```typescript
it('exposes reconnection attempt count', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  mockServerUnavailable();

  const { result } = renderHook(() => useSSE(job.id));

  // Wait for reconnection attempts
  await sleep(5000);

  expect(result.current.reconnectAttempts).toBeGreaterThan(0);
  expect(result.current.reconnectAttempts).toBeLessThanOrEqual(10);
});
```

---

### SSE-HOOK-008: State Sync Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HOOK-008 |
| **Title** | Hook Processes State Sync Events |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 6.3.3, Reconnection Protocol |

**Test Steps**:

```typescript
it('processes state_sync events to restore state', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const { result, rerender } = renderHook(() => useSSE(job.id));

  // Wait for progress
  await waitFor(() => {
    expect(result.current.progress.percent).toBeGreaterThan(50);
  });

  // Record current state
  const progressBeforeReconnect = result.current.progress.percent;

  // Simulate disconnect and reconnect
  await simulateConnectionDrop(job.id);
  await waitForReconnection(job.id);

  // After reconnect, state should be restored via state_sync
  await waitFor(() => {
    expect(result.current.progress.percent).toBeGreaterThanOrEqual(progressBeforeReconnect);
  });
});
```

---

## 10. Redis Pub/Sub Integration Tests

### 10.1 Event Publishing

---

### SSE-PUB-001: Publish Progress Event

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-001 |
| **Title** | Publish Progress to Redis |
| **Priority** | P1 - High |
| **Spec Reference** | Section 7.2 |

**Test Steps**:

```typescript
it('publishes progress event to Redis channel', async () => {
  const jobId = 'test-job-123';

  const subscriber = new Redis();
  const messages: any[] = [];

  await subscriber.subscribe(`hx-docling:job:${jobId}:progress`);
  subscriber.on('message', (channel, message) => {
    messages.push(JSON.parse(message));
  });

  await publishProgressEvent(jobId, {
    stage: 'conversion',
    percent: 50,
    message: 'Converting...',
  });

  await waitFor(() => expect(messages.length).toBe(1));

  expect(messages[0]).toMatchObject({
    stage: 'conversion',
    percent: 50,
  });

  subscriber.disconnect();
});
```

---

### SSE-PUB-002: Subscribe to Job Channel

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-002 |
| **Title** | Subscribe to Job Progress Channel |
| **Priority** | P1 - High |
| **Spec Reference** | Section 7.2 |

**Test Steps**:

```typescript
it('API subscribes to correct Redis channel', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Spy on Redis subscribe
  const subscribeSpy = jest.spyOn(redis, 'subscribe');

  // Connect to SSE endpoint
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  await waitFor(() => {
    expect(subscribeSpy).toHaveBeenCalledWith(
      expect.stringContaining(`job:${job.id}:progress`)
    );
  });

  eventSource.close();
});
```

---

### SSE-PUB-003: Unsubscribe on Disconnect

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-003 |
| **Title** | Unsubscribe on Client Disconnect |
| **Priority** | P1 - High |
| **Spec Reference** | Resource cleanup |

**Test Steps**:

```typescript
it('unsubscribes from Redis on client disconnect', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const unsubscribeSpy = jest.spyOn(redis, 'unsubscribe');

  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  await waitFor(() => {
    expect(eventSource.readyState).toBe(EventSource.OPEN);
  });

  eventSource.close();

  await waitFor(() => {
    expect(unsubscribeSpy).toHaveBeenCalledWith(
      expect.stringContaining(`job:${job.id}:progress`)
    );
  });
});
```

---

### SSE-PUB-004: Multiple Subscribers

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-004 |
| **Title** | Multiple Clients Receive Events |
| **Priority** | P2 - Medium |
| **Spec Reference** | Multi-tab support (MAJ-12) |

**Test Steps**:

```typescript
it('all connected clients receive events', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventsClient1: any[] = [];
  const eventsClient2: any[] = [];

  const client1 = subscribeToJob(job.id, (e) => eventsClient1.push(e));
  const client2 = subscribeToJob(job.id, (e) => eventsClient2.push(e));

  await waitFor(() => {
    expect(client1.readyState).toBe(EventSource.OPEN);
    expect(client2.readyState).toBe(EventSource.OPEN);
  });

  // Publish event
  await publishProgressEvent(job.id, { stage: 'test', percent: 50 });

  await waitFor(() => {
    expect(eventsClient1.length).toBeGreaterThan(0);
    expect(eventsClient2.length).toBeGreaterThan(0);
  });

  client1.close();
  client2.close();
});
```

---

### SSE-PUB-005: Error Event Serialization

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-005 |
| **Title** | Error Events Serialize Correctly |
| **Priority** | P1 - High |
| **Spec Reference** | Section 7.2, Error handling |

**Test Steps**:

```typescript
it('serializes error events with full details', async () => {
  const jobId = 'error-test-job';

  const subscriber = new Redis();
  const messages: any[] = [];

  await subscriber.subscribe(`hx-docling:job:${jobId}:progress`);
  subscriber.on('message', (channel, message) => {
    messages.push(JSON.parse(message));
  });

  // Publish error event
  await publishErrorEvent(jobId, {
    code: 'E302',
    message: 'Conversion failed',
    userMessage: 'Unable to process document',
    suggestedAction: 'Try a different file format',
    retryable: true,
    details: { stage: 'conversion', fileType: 'pdf' },
  });

  await waitFor(() => expect(messages.length).toBe(1));

  // All fields should be serialized
  expect(messages[0]).toMatchObject({
    type: 'error',
    code: 'E302',
    message: expect.any(String),
    userMessage: expect.any(String),
    suggestedAction: expect.any(String),
    retryable: true,
    details: expect.any(Object),
  });

  subscriber.disconnect();
});
```

---

### SSE-PUB-006: Channel Cleanup on Job Completion

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-006 |
| **Title** | Redis Channel Cleanup After Job Completion |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('cleans up Redis channels after job completion', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for completion
  await waitForEvent(job.id, 'complete');

  // Wait for cleanup delay
  await sleep(5000);

  // Channel should have no subscribers
  const channelInfo = await redis.pubsub('NUMSUB', `hx-docling:job:${job.id}:progress`);
  expect(channelInfo[1]).toBe(0);

  // Event buffer should be cleaned up
  const bufferSize = await redis.zcard(`hx-docling:job:${job.id}:events`);
  expect(bufferSize).toBe(0);
});
```

---

### SSE-PUB-007: Multi-Instance Event Distribution

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PUB-007 |
| **Title** | Events Distributed Across Multiple Server Instances |
| **Priority** | P1 - High |
| **Spec Reference** | Scalability requirements |

**Test Steps**:

```typescript
it('distributes events to clients on different server instances', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Simulate two server instances with separate connections
  const instance1Events: any[] = [];
  const instance2Events: any[] = [];

  // Instance 1 client
  const client1 = new EventSource(`http://instance1:3000/api/v1/process/${job.id}/events`);
  client1.addEventListener('progress', (e) => instance1Events.push(JSON.parse(e.data)));

  // Instance 2 client
  const client2 = new EventSource(`http://instance2:3000/api/v1/process/${job.id}/events`);
  client2.addEventListener('progress', (e) => instance2Events.push(JSON.parse(e.data)));

  await waitFor(() => {
    expect(client1.readyState).toBe(EventSource.OPEN);
    expect(client2.readyState).toBe(EventSource.OPEN);
  });

  // Publish event (should reach both instances via Redis)
  await publishProgressEvent(job.id, { stage: 'test', percent: 50 });

  await waitFor(() => {
    expect(instance1Events.length).toBeGreaterThan(0);
    expect(instance2Events.length).toBeGreaterThan(0);
  });

  // Both should receive same event
  expect(instance1Events[0].percent).toBe(instance2Events[0].percent);

  client1.close();
  client2.close();
});
```

---

## 11. Redis Circuit Breaker Tests

### 11.1 Circuit Breaker Behavior

Circuit breaker tests validate that Redis failures are handled gracefully without crashing the application or leaving clients in undefined states.

---

### SSE-REDIS-001: Circuit Breaker Opens on Failures

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-001 |
| **Title** | Circuit Breaker Opens After Consecutive Failures |
| **Priority** | P0 - Critical |
| **Spec Reference** | Redis resilience requirements |

**Test Steps**:

```typescript
it('circuit breaker opens after consecutive Redis failures', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Simulate Redis failures
  mockRedisUnavailable();

  const events: string[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('error', () => events.push('error'));

  // Attempt multiple operations
  for (let i = 0; i < 5; i++) {
    await publishProgress(job.id, { stage: 'test', percent: i * 10 }).catch(() => {});
  }

  // Circuit breaker should be open
  const circuitState = await getCircuitBreakerState('redis');
  expect(circuitState).toBe('open');

  eventSource.close();
});
```

---

### SSE-REDIS-002: Graceful Degradation on Redis Failure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-002 |
| **Title** | SSE Degrades Gracefully When Redis Unavailable |
| **Priority** | P0 - Critical |
| **Spec Reference** | Redis resilience requirements |

**Test Steps**:

```typescript
it('degrades gracefully when Redis unavailable', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventSource = subscribeToJob(job.id);

  await waitFor(() => expect(eventSource.readyState).toBe(EventSource.OPEN));

  // Make Redis unavailable
  mockRedisUnavailable();

  // Should receive fallback events or switch to polling
  let fallbackReceived = false;
  eventSource.addEventListener('fallback', () => {
    fallbackReceived = true;
  });

  await sleep(5000);

  // Either received fallback event or connection still maintained
  expect(eventSource.readyState).not.toBe(EventSource.CLOSED);

  eventSource.close();
});
```

---

### SSE-REDIS-003: Circuit Breaker Recovery

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-003 |
| **Title** | Circuit Breaker Recovers When Redis Restored |
| **Priority** | P0 - Critical |
| **Spec Reference** | Redis resilience requirements |

**Test Steps**:

```typescript
it('circuit breaker recovers when Redis restored', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Open circuit breaker
  mockRedisUnavailable();
  for (let i = 0; i < 5; i++) {
    await publishProgress(job.id, { stage: 'test', percent: i }).catch(() => {});
  }

  expect(await getCircuitBreakerState('redis')).toBe('open');

  // Restore Redis
  restoreRedis();

  // Wait for half-open state
  await sleep(30000); // Circuit breaker reset time

  // Attempt operation - should succeed and close circuit
  await publishProgress(job.id, { stage: 'test', percent: 50 });

  expect(await getCircuitBreakerState('redis')).toBe('closed');
}, 60000);
```

---

### SSE-REDIS-004: Redis Connection Pool Exhaustion

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-004 |
| **Title** | Handle Redis Connection Pool Exhaustion |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('handles Redis connection pool exhaustion gracefully', async () => {
  // Create many SSE connections to exhaust pool
  const jobs = await Promise.all(
    Array.from({ length: 50 }, () => createJob({ status: 'PROCESSING' }))
  );

  const connections = jobs.map(job =>
    new EventSource(`/api/v1/process/${job.id}/events`)
  );

  await sleep(2000);

  // All connections should either be open or gracefully rejected
  connections.forEach(conn => {
    expect([EventSource.OPEN, EventSource.CLOSED]).toContain(conn.readyState);
  });

  // New connection should either work or fail gracefully
  const newJob = await createJob({ status: 'PROCESSING' });
  const response = await fetch(`/api/v1/process/${newJob.id}/events`);

  // Should not crash - either 200 or 503
  expect([200, 503]).toContain(response.status);

  connections.forEach(conn => conn.close());
});
```

---

### SSE-REDIS-005: Redis Reconnection During SSE Stream

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-005 |
| **Title** | SSE Survives Redis Reconnection |
| **Priority** | P1 - High |
| **Spec Reference** | Redis resilience requirements |

**Test Steps**:

```typescript
it('SSE survives Redis reconnection', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Wait for some events
  await waitFor(() => events.length >= 3);
  const eventsBeforeDisconnect = events.length;

  // Simulate Redis disconnect and reconnect
  await simulateRedisDisconnect();
  await sleep(1000);
  await simulateRedisReconnect();

  // Should continue receiving events after reconnect
  await waitFor(() => events.length > eventsBeforeDisconnect, { timeout: 10000 });

  eventSource.close();
});
```

---

### SSE-REDIS-006: Redis Cluster Failover

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-006 |
| **Title** | Handle Redis Cluster Failover |
| **Priority** | P1 - High |
| **Spec Reference** | High availability requirements |

**Test Steps**:

```typescript
it('handles Redis cluster failover transparently', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  await waitFor(() => events.length >= 3);

  // Simulate cluster failover
  await simulateRedisClusterFailover();

  // Events should continue after brief pause
  const eventsBeforeFailover = events.length;
  await sleep(5000);

  // Should resume receiving events
  await waitFor(() => events.length > eventsBeforeFailover, { timeout: 15000 });

  eventSource.close();
}, 30000);
```

### 11.2 Circuit Breaker State Transitions

These tests validate the correct behavior of circuit breaker state transitions following the standard circuit breaker pattern: Closed -> Open -> Half-Open -> Closed/Open.

---

### SSE-REDIS-007: Closed to Open Transition on Failure Threshold

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-007 |
| **Title** | Circuit Breaker Transitions from Closed to Open on Failure Threshold |
| **Priority** | P0 - Critical |
| **Spec Reference** | Circuit breaker pattern, Redis resilience |

**Test Steps**:

```typescript
it('transitions from closed to open state after failure threshold', async () => {
  const circuitBreaker = getRedisCircuitBreaker();

  // Verify initial state is closed
  expect(circuitBreaker.state).toBe('closed');
  expect(circuitBreaker.failureCount).toBe(0);

  // Configure failure threshold (default: 5 failures)
  const failureThreshold = circuitBreaker.options.failureThreshold;

  // Simulate failures up to threshold
  mockRedisUnavailable();

  for (let i = 0; i < failureThreshold; i++) {
    await publishProgress('test-job', { stage: 'test', percent: 10 }).catch(() => {});

    if (i < failureThreshold - 1) {
      // Should still be closed until threshold reached
      expect(circuitBreaker.state).toBe('closed');
      expect(circuitBreaker.failureCount).toBe(i + 1);
    }
  }

  // After threshold, circuit should be open
  expect(circuitBreaker.state).toBe('open');
  expect(circuitBreaker.isOpen()).toBe(true);

  // Subsequent calls should fail fast without attempting Redis
  const startTime = Date.now();
  await publishProgress('test-job', { stage: 'test', percent: 20 }).catch(() => {});
  const elapsed = Date.now() - startTime;

  // Should fail immediately (< 50ms) due to circuit breaker
  expect(elapsed).toBeLessThan(50);
});
```

**Expected Result**:
- Circuit breaker starts in closed state
- Failure count increments with each failure
- Transitions to open state after failure threshold reached
- Subsequent calls fail fast without attempting Redis connection

---

### SSE-REDIS-008: Open to Half-Open Transition After Timeout

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-008 |
| **Title** | Circuit Breaker Transitions from Open to Half-Open After Reset Timeout |
| **Priority** | P0 - Critical |
| **Spec Reference** | Circuit breaker pattern, Redis resilience |

**Test Steps**:

```typescript
it('transitions from open to half-open after reset timeout', async () => {
  const circuitBreaker = getRedisCircuitBreaker();
  const resetTimeout = circuitBreaker.options.resetTimeout; // e.g., 30000ms

  // Open the circuit breaker
  mockRedisUnavailable();
  for (let i = 0; i < 5; i++) {
    await publishProgress('test-job', { stage: 'test', percent: i }).catch(() => {});
  }

  expect(circuitBreaker.state).toBe('open');
  const openedAt = circuitBreaker.lastStateChange;

  // Wait for reset timeout period
  await sleep(resetTimeout + 100);

  // Circuit should transition to half-open on next call attempt
  restoreRedis();

  // This call triggers the half-open probe
  const probePromise = publishProgress('test-job', { stage: 'probe', percent: 50 });

  // State should be half-open during probe
  expect(circuitBreaker.state).toBe('half-open');

  await probePromise;

  // Verify timing - should have waited for reset timeout
  expect(circuitBreaker.lastStateChange.getTime()).toBeGreaterThan(openedAt.getTime() + resetTimeout);
}, 60000);
```

**Expected Result**:
- Circuit breaker remains open until reset timeout expires
- After timeout, transitions to half-open state on next call
- Half-open state allows a probe request through

---

### SSE-REDIS-009: Half-Open to Closed Transition on Success

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-009 |
| **Title** | Circuit Breaker Transitions from Half-Open to Closed on Successful Probe |
| **Priority** | P0 - Critical |
| **Spec Reference** | Circuit breaker pattern, Redis resilience |

**Test Steps**:

```typescript
it('transitions from half-open to closed on successful probe', async () => {
  const circuitBreaker = getRedisCircuitBreaker();

  // Open the circuit
  mockRedisUnavailable();
  for (let i = 0; i < 5; i++) {
    await publishProgress('test-job', { stage: 'test', percent: i }).catch(() => {});
  }

  expect(circuitBreaker.state).toBe('open');

  // Wait for reset timeout
  await sleep(circuitBreaker.options.resetTimeout + 100);

  // Restore Redis before probe
  restoreRedis();

  // Execute successful probe
  await publishProgress('test-job', { stage: 'probe', percent: 50 });

  // Circuit should be closed after successful probe
  expect(circuitBreaker.state).toBe('closed');
  expect(circuitBreaker.failureCount).toBe(0);
  expect(circuitBreaker.isOpen()).toBe(false);

  // Normal operations should work
  const result = await publishProgress('test-job', { stage: 'normal', percent: 60 });
  expect(result).toBeDefined();
}, 60000);
```

**Expected Result**:
- Successful probe request closes the circuit
- Failure count resets to zero
- Normal operations resume

---

### SSE-REDIS-010: Half-Open to Open Transition on Probe Failure

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-010 |
| **Title** | Circuit Breaker Returns to Open State on Failed Probe |
| **Priority** | P0 - Critical |
| **Spec Reference** | Circuit breaker pattern, Redis resilience |

**Test Steps**:

```typescript
it('returns to open state when probe fails during half-open', async () => {
  const circuitBreaker = getRedisCircuitBreaker();

  // Open the circuit
  mockRedisUnavailable();
  for (let i = 0; i < 5; i++) {
    await publishProgress('test-job', { stage: 'test', percent: i }).catch(() => {});
  }

  expect(circuitBreaker.state).toBe('open');

  // Wait for reset timeout
  await sleep(circuitBreaker.options.resetTimeout + 100);

  // Keep Redis unavailable - probe will fail
  // Execute probe (will fail)
  await publishProgress('test-job', { stage: 'probe', percent: 50 }).catch(() => {});

  // Circuit should return to open state
  expect(circuitBreaker.state).toBe('open');
  expect(circuitBreaker.isOpen()).toBe(true);

  // Reset timeout should be extended
  const newResetTime = circuitBreaker.nextResetTime;
  expect(newResetTime.getTime()).toBeGreaterThan(Date.now());
}, 60000);
```

**Expected Result**:
- Failed probe returns circuit to open state
- Reset timeout is extended
- Circuit remains open until next reset timeout period

---

### SSE-REDIS-011: Failure Counting and Reset Behavior

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-011 |
| **Title** | Verify Failure Counting and Success-Based Reset |
| **Priority** | P1 - High |
| **Spec Reference** | Circuit breaker pattern, Redis resilience |

**Test Steps**:

```typescript
it('correctly counts failures and resets on success', async () => {
  const circuitBreaker = getRedisCircuitBreaker();

  // Start with closed circuit
  expect(circuitBreaker.state).toBe('closed');
  expect(circuitBreaker.failureCount).toBe(0);

  // Cause some failures (but below threshold)
  mockRedisUnavailable();
  for (let i = 0; i < 3; i++) {
    await publishProgress('test-job', { stage: 'test', percent: i }).catch(() => {});
  }

  expect(circuitBreaker.failureCount).toBe(3);
  expect(circuitBreaker.state).toBe('closed'); // Still closed (threshold is 5)

  // Restore Redis and succeed
  restoreRedis();
  await publishProgress('test-job', { stage: 'test', percent: 50 });

  // Failure count should reset on success
  expect(circuitBreaker.failureCount).toBe(0);
  expect(circuitBreaker.state).toBe('closed');

  // Verify consecutive failure requirement
  mockRedisUnavailable();
  await publishProgress('test-job', { stage: 'test', percent: 10 }).catch(() => {});
  expect(circuitBreaker.failureCount).toBe(1);

  restoreRedis();
  await publishProgress('test-job', { stage: 'test', percent: 20 });
  expect(circuitBreaker.failureCount).toBe(0);
});
```

**Expected Result**:
- Failure count increments with each failure
- Successful operations reset the failure count
- Only consecutive failures trigger circuit open

---

### SSE-REDIS-012: Circuit Breaker Metrics and Telemetry

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-012 |
| **Title** | Verify Circuit Breaker Emits Proper Metrics and Telemetry |
| **Priority** | P1 - High |
| **Spec Reference** | Observability requirements, monitoring |

**Test Steps**:

```typescript
it('emits proper metrics and telemetry for circuit breaker events', async () => {
  const circuitBreaker = getRedisCircuitBreaker();
  const metricsCollector = getMetricsCollector();

  // Clear existing metrics
  metricsCollector.clear();

  // Cause circuit to open
  mockRedisUnavailable();
  for (let i = 0; i < 5; i++) {
    await publishProgress('test-job', { stage: 'test', percent: i }).catch(() => {});
  }

  // Verify failure metrics
  const failureMetrics = metricsCollector.getMetrics('redis.circuit_breaker.failure');
  expect(failureMetrics.count).toBe(5);
  expect(failureMetrics.labels).toMatchObject({
    service: 'redis',
    operation: 'publish',
  });

  // Verify state change metric
  const stateChangeMetrics = metricsCollector.getMetrics('redis.circuit_breaker.state_change');
  expect(stateChangeMetrics).toContainEqual({
    from: 'closed',
    to: 'open',
    timestamp: expect.any(Number),
  });

  // Wait for half-open
  await sleep(circuitBreaker.options.resetTimeout + 100);
  restoreRedis();
  await publishProgress('test-job', { stage: 'probe', percent: 50 });

  // Verify recovery metrics
  const recoveryMetrics = metricsCollector.getMetrics('redis.circuit_breaker.recovery');
  expect(recoveryMetrics.count).toBe(1);
  expect(recoveryMetrics.duration_ms).toBeGreaterThan(0);

  // Verify overall circuit breaker stats
  const stats = circuitBreaker.getStats();
  expect(stats).toMatchObject({
    totalFailures: 5,
    totalSuccesses: expect.any(Number),
    stateTransitions: expect.any(Number),
    lastFailureAt: expect.any(Date),
    lastSuccessAt: expect.any(Date),
  });
}, 60000);
```

**Expected Result**:
- Failure events emit metrics with proper labels
- State transitions are recorded with timestamps
- Recovery events include duration metrics
- Aggregate statistics are available

---

### 11.3 Cache Invalidation Tests

These tests validate that Redis cache invalidation works correctly, ensuring data consistency when cached values become stale.

---

### SSE-CACHE-001: Cache Invalidation on Data Update

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-001 |
| **Title** | Cache Invalidates When Underlying Data Updates |
| **Priority** | P0 - Critical |
| **Spec Reference** | Cache consistency requirements |

**Test Steps**:

```typescript
it('invalidates cache when underlying data is updated', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  const cacheKey = `job:${job.id}:progress`;

  // Populate cache with initial progress
  await publishProgress(job.id, { stage: 'parsing', percent: 30 });

  // Verify cache is populated
  let cachedValue = await redisClient.get(cacheKey);
  expect(JSON.parse(cachedValue)).toMatchObject({
    stage: 'parsing',
    percent: 30,
  });

  // Update the progress (should invalidate/update cache)
  await publishProgress(job.id, { stage: 'conversion', percent: 60 });

  // Cache should reflect new value
  cachedValue = await redisClient.get(cacheKey);
  expect(JSON.parse(cachedValue)).toMatchObject({
    stage: 'conversion',
    percent: 60,
  });

  // Verify SSE clients receive updated value
  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('state_sync', (e) => {
    events.push(JSON.parse(e.data));
  });

  await waitFor(() => events.length >= 1);
  expect(events[0].progress.percent).toBe(60);

  eventSource.close();
});
```

**Expected Result**:
- Cache is updated when data changes
- SSE clients receive updated values
- No stale data served after update

---

### SSE-CACHE-002: Cache Invalidation on Data Delete

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-002 |
| **Title** | Cache Invalidates When Data is Deleted |
| **Priority** | P0 - Critical |
| **Spec Reference** | Cache consistency requirements |

**Test Steps**:

```typescript
it('invalidates cache when data is deleted', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  const cacheKey = `job:${job.id}:progress`;

  // Populate cache
  await publishProgress(job.id, { stage: 'parsing', percent: 50 });

  // Verify cache exists
  expect(await redisClient.exists(cacheKey)).toBe(1);

  // Delete job data
  await deleteJob(job.id);

  // Cache should be invalidated
  expect(await redisClient.exists(cacheKey)).toBe(0);

  // Related cache keys should also be invalidated
  const relatedKeys = await redisClient.keys(`job:${job.id}:*`);
  expect(relatedKeys).toHaveLength(0);

  // Attempting to fetch deleted data should not return stale cache
  const result = await getJobProgress(job.id);
  expect(result).toBeNull();
});
```

**Expected Result**:
- Cache is deleted when underlying data is deleted
- Related cache keys are also cleared
- No stale data returned for deleted entities

---

### SSE-CACHE-003: TTL-Based Cache Expiration

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-003 |
| **Title** | Cache Expires Based on TTL Configuration |
| **Priority** | P1 - High |
| **Spec Reference** | Cache TTL requirements |

**Test Steps**:

```typescript
it('cache expires based on configured TTL', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  const cacheKey = `job:${job.id}:progress`;
  const cacheTTL = 5; // 5 seconds for test

  // Set cache with short TTL
  await redisClient.setex(cacheKey, cacheTTL, JSON.stringify({
    stage: 'parsing',
    percent: 30,
    cachedAt: Date.now(),
  }));

  // Verify cache exists
  expect(await redisClient.exists(cacheKey)).toBe(1);

  // Verify TTL is set correctly
  const ttl = await redisClient.ttl(cacheKey);
  expect(ttl).toBeLessThanOrEqual(cacheTTL);
  expect(ttl).toBeGreaterThan(0);

  // Wait for TTL to expire
  await sleep((cacheTTL + 1) * 1000);

  // Cache should be expired
  expect(await redisClient.exists(cacheKey)).toBe(0);

  // Next request should fetch fresh data
  const freshData = await getJobProgress(job.id);
  expect(freshData).toBeDefined();

  // Cache should be repopulated
  expect(await redisClient.exists(cacheKey)).toBe(1);
}, 15000);
```

**Expected Result**:
- Cache entries have proper TTL set
- Entries expire after TTL
- Fresh data is fetched and cached after expiration

---

### SSE-CACHE-004: Manual Cache Purge

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-004 |
| **Title** | Manual Cache Purge Clears All Cached Data |
| **Priority** | P1 - High |
| **Spec Reference** | Cache management requirements |

**Test Steps**:

```typescript
it('manual cache purge clears all cached job data', async () => {
  // Create multiple jobs with cached data
  const jobs = await Promise.all([
    createJob({ status: 'PROCESSING' }),
    createJob({ status: 'PROCESSING' }),
    createJob({ status: 'PROCESSING' }),
  ]);

  // Populate cache for all jobs
  for (const job of jobs) {
    await publishProgress(job.id, { stage: 'parsing', percent: 30 });
  }

  // Verify all caches are populated
  for (const job of jobs) {
    expect(await redisClient.exists(`job:${job.id}:progress`)).toBe(1);
  }

  // Count total cache keys before purge
  const keysBefore = await redisClient.keys('job:*');
  expect(keysBefore.length).toBeGreaterThanOrEqual(3);

  // Execute manual cache purge
  await purgeCache({ pattern: 'job:*' });

  // All job-related cache should be cleared
  const keysAfter = await redisClient.keys('job:*');
  expect(keysAfter).toHaveLength(0);

  // System should continue functioning
  for (const job of jobs) {
    const progress = await getJobProgress(job.id);
    expect(progress).toBeDefined(); // Fetches from database
  }
});
```

**Expected Result**:
- Manual purge clears all matching cache keys
- System continues functioning after purge
- Fresh data is fetched from source

---

### SSE-CACHE-005: Cascade Cache Invalidation

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-005 |
| **Title** | Related Cache Entries Invalidate in Cascade |
| **Priority** | P1 - High |
| **Spec Reference** | Cache consistency, data relationships |

**Test Steps**:

```typescript
it('invalidates related cache entries in cascade', async () => {
  const sessionId = 'test-session-001';

  // Create multiple jobs for same session
  const jobs = await Promise.all([
    createJob({ sessionId, status: 'PROCESSING' }),
    createJob({ sessionId, status: 'PROCESSING' }),
  ]);

  // Populate individual job caches
  for (const job of jobs) {
    await publishProgress(job.id, { stage: 'parsing', percent: 30 });
  }

  // Populate session-level cache (aggregated view)
  const sessionCacheKey = `session:${sessionId}:jobs`;
  await redisClient.set(sessionCacheKey, JSON.stringify(jobs.map(j => j.id)));

  // Verify all caches exist
  for (const job of jobs) {
    expect(await redisClient.exists(`job:${job.id}:progress`)).toBe(1);
  }
  expect(await redisClient.exists(sessionCacheKey)).toBe(1);

  // Invalidate session (should cascade to all related jobs)
  await invalidateSession(sessionId);

  // Session cache should be cleared
  expect(await redisClient.exists(sessionCacheKey)).toBe(0);

  // All job caches for this session should be cleared
  for (const job of jobs) {
    expect(await redisClient.exists(`job:${job.id}:progress`)).toBe(0);
  }

  // Other sessions should not be affected
  const otherSessionKey = 'session:other-session:jobs';
  await redisClient.set(otherSessionKey, '[]');
  await invalidateSession(sessionId);
  expect(await redisClient.exists(otherSessionKey)).toBe(1);
});
```

**Expected Result**:
- Invalidating parent entity cascades to children
- Related cache entries are cleared together
- Unrelated cache entries are preserved

---

### SSE-CACHE-006: Cache Invalidation Verification

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CACHE-006 |
| **Title** | Verify Cache Invalidation Completes Before Response |
| **Priority** | P0 - Critical |
| **Spec Reference** | Data consistency, cache coherency |

**Test Steps**:

```typescript
it('ensures cache invalidation completes before returning response', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  const cacheKey = `job:${job.id}:progress`;

  // Set initial cache value
  await redisClient.set(cacheKey, JSON.stringify({
    stage: 'parsing',
    percent: 30,
  }));

  // Start concurrent readers
  const readers: Promise<any>[] = [];
  for (let i = 0; i < 10; i++) {
    readers.push(getJobProgress(job.id));
  }

  // Update progress (triggers invalidation)
  const updatePromise = publishProgress(job.id, { stage: 'conversion', percent: 60 });

  // Wait for update to complete
  await updatePromise;

  // All subsequent reads should see new value
  for (let i = 0; i < 5; i++) {
    const progress = await getJobProgress(job.id);
    expect(progress.percent).toBe(60);
    expect(progress.stage).toBe('conversion');
  }

  // No reader should see stale data after update completes
  const cachedValue = await redisClient.get(cacheKey);
  expect(JSON.parse(cachedValue).percent).toBe(60);
});
```

**Expected Result**:
- Cache invalidation is synchronous with update
- No stale data returned after update completes
- Read-after-write consistency guaranteed

---

### 11.4 Redis Failover and Recovery Tests

These tests validate the system's behavior during Redis failures, ensuring graceful degradation and proper recovery.

---

### SSE-REDIS-013: Connection Failure Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-013 |
| **Title** | Handle Redis Connection Failure Gracefully |
| **Priority** | P0 - Critical |
| **Spec Reference** | Redis resilience, high availability |

**Test Steps**:

```typescript
it('handles Redis connection failure gracefully', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const errors: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  eventSource.addEventListener('error', (e) => {
    errors.push(e);
  });

  // Verify normal operation
  await publishProgress(job.id, { stage: 'parsing', percent: 20 });
  await waitFor(() => events.length >= 1);

  // Simulate connection failure
  await terminateRedisConnection();

  // Attempt operations during failure
  const failedOps: Error[] = [];
  for (let i = 0; i < 3; i++) {
    try {
      await publishProgress(job.id, { stage: 'test', percent: 30 + i * 10 });
    } catch (e) {
      failedOps.push(e as Error);
    }
  }

  // Operations should fail gracefully (not crash)
  expect(failedOps.length).toBeGreaterThan(0);
  failedOps.forEach(err => {
    expect(err.message).toMatch(/connection|unavailable|ECONNREFUSED/i);
  });

  // SSE connection should remain open (not crash client)
  expect(eventSource.readyState).not.toBe(EventSource.CLOSED);

  eventSource.close();
});
```

**Expected Result**:
- Connection failures are caught and handled
- No unhandled exceptions or crashes
- SSE connections remain stable
- Clear error messages provided

---

### SSE-REDIS-014: Automatic Reconnection After Outage

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-014 |
| **Title** | Automatically Reconnect After Redis Outage |
| **Priority** | P0 - Critical |
| **Spec Reference** | Redis resilience, automatic recovery |

**Test Steps**:

```typescript
it('automatically reconnects after Redis outage', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  const redisClient = getRedisClient();

  // Verify initial connection
  expect(redisClient.isReady).toBe(true);

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Publish initial event
  await publishProgress(job.id, { stage: 'parsing', percent: 20 });
  await waitFor(() => events.length >= 1);

  // Simulate Redis outage
  await simulateRedisOutage();
  expect(redisClient.isReady).toBe(false);

  // Wait for reconnection attempts
  const reconnectStart = Date.now();

  // Restore Redis
  await sleep(2000);
  await restoreRedisService();

  // Wait for automatic reconnection
  await waitFor(() => redisClient.isReady === true, { timeout: 30000 });

  const reconnectDuration = Date.now() - reconnectStart;

  // Verify reconnection occurred within acceptable time
  expect(reconnectDuration).toBeLessThan(30000);

  // Operations should work after reconnection
  await publishProgress(job.id, { stage: 'conversion', percent: 60 });
  await waitFor(() => events.some(e => e.percent === 60));

  // Verify reconnection metrics
  const metrics = await getRedisMetrics();
  expect(metrics.reconnections).toBeGreaterThan(0);

  eventSource.close();
}, 60000);
```

**Expected Result**:
- System detects Redis outage
- Automatic reconnection attempts occur
- Connection restored within acceptable time
- Operations resume after recovery

---

### SSE-REDIS-015: Graceful Degradation to In-Memory Fallback

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-015 |
| **Title** | Degrade Gracefully to In-Memory Event Store |
| **Priority** | P0 - Critical |
| **Spec Reference** | Resilience requirements, graceful degradation |

**Test Steps**:

```typescript
it('degrades gracefully to in-memory event store when Redis unavailable', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Verify Redis mode initially
  const initialMode = getEventStoreMode();
  expect(initialMode).toBe('redis');

  // Make Redis unavailable
  mockRedisUnavailable();

  // Wait for failover
  await sleep(5000);

  // Verify fallback to in-memory mode
  const fallbackMode = getEventStoreMode();
  expect(fallbackMode).toBe('memory');

  // Operations should continue in memory mode
  await publishProgressInMemory(job.id, { stage: 'parsing', percent: 30 });
  await publishProgressInMemory(job.id, { stage: 'conversion', percent: 60 });

  // Events should still be delivered (via fallback mechanism)
  await waitFor(() => events.length >= 1, { timeout: 10000 });

  // Verify degradation warning is logged
  const logs = getRecentLogs();
  expect(logs).toContainEqual(expect.objectContaining({
    level: 'warn',
    message: expect.stringMatching(/degraded.*memory|fallback/i),
  }));

  // Restore Redis and verify recovery
  restoreRedis();
  await sleep(5000);

  const recoveredMode = getEventStoreMode();
  expect(recoveredMode).toBe('redis');

  eventSource.close();
}, 30000);
```

**Expected Result**:
- System detects Redis unavailability
- Falls back to in-memory event store
- Operations continue in degraded mode
- Warning logged for operators
- Recovers to Redis when available

---

### SSE-REDIS-016: Data Consistency After Recovery

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REDIS-016 |
| **Title** | Ensure Data Consistency After Redis Recovery |
| **Priority** | P0 - Critical |
| **Spec Reference** | Data consistency, recovery procedures |

**Test Steps**:

```typescript
it('maintains data consistency after Redis recovery', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Record initial state
  const initialProgress = { stage: 'parsing', percent: 20 };
  await publishProgress(job.id, initialProgress);

  // Verify initial state in Redis
  const cachedBefore = await redisClient.get(`job:${job.id}:progress`);
  expect(JSON.parse(cachedBefore).percent).toBe(20);

  // Simulate Redis failure and recovery
  await simulateRedisOutage();

  // Continue processing during outage (in-memory or database)
  await updateJobProgressInDB(job.id, { stage: 'conversion', percent: 60 });

  // Restore Redis
  await restoreRedisService();
  await waitFor(() => getRedisClient().isReady === true, { timeout: 30000 });

  // Synchronize state after recovery
  await syncJobStateToRedis(job.id);

  // Verify Redis has correct (latest) state
  const cachedAfter = await redisClient.get(`job:${job.id}:progress`);
  expect(JSON.parse(cachedAfter)).toMatchObject({
    stage: 'conversion',
    percent: 60,
  });

  // Verify database and Redis are consistent
  const dbState = await db.job.findUnique({ where: { id: job.id } });
  expect(dbState.progress).toBe(60);
  expect(dbState.currentStage).toBe('conversion');

  // SSE clients should receive correct state on reconnect
  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);
  eventSource.addEventListener('state_sync', (e) => {
    events.push(JSON.parse(e.data));
  });

  await waitFor(() => events.length >= 1);
  expect(events[0].progress.percent).toBe(60);

  eventSource.close();
}, 60000);
```

**Expected Result**:
- State changes during outage are preserved
- Redis state synchronized after recovery
- Database remains source of truth
- SSE clients receive correct state
- No data loss or inconsistency

---

## 12. Database Integration Tests

### 12.1 Database-SSE Synchronization

These tests validate that SSE events are properly correlated with database state changes, ensuring consistency between the two systems.

---

### SSE-DB-001: Job Status Change Triggers SSE Event

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-DB-001 |
| **Title** | Database Status Update Triggers SSE Event |
| **Priority** | P0 - Critical |
| **Spec Reference** | Database-SSE integration |

**Test Steps**:

```typescript
it('database status update triggers SSE event', async () => {
  const job = await createJob({ status: 'PENDING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Update job status in database
  await db.job.update({
    where: { id: job.id },
    data: { status: 'PROCESSING', progress: 10 },
  });

  // SSE event should be triggered
  await waitFor(() => events.some(e => e.percent === 10));

  eventSource.close();
});
```

---

### SSE-DB-002: SSE Event Matches Database State

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-DB-002 |
| **Title** | SSE Event Data Matches Database State |
| **Priority** | P0 - Critical |
| **Spec Reference** | Data consistency |

**Test Steps**:

```typescript
it('SSE event data matches database state', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  let lastEvent: any = null;
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    lastEvent = JSON.parse(e.data);
  });

  await waitFor(() => lastEvent?.percent > 50);

  // Fetch database state
  const dbJob = await db.job.findUnique({ where: { id: job.id } });

  // SSE event should match database
  expect(lastEvent.percent).toBe(dbJob.progress);
  expect(lastEvent.stage).toBe(dbJob.currentStage);

  eventSource.close();
});
```

---

### SSE-DB-003: Complete Event Contains Database Results

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-DB-003 |
| **Title** | Complete Event Contains Persisted Results |
| **Priority** | P0 - Critical |
| **Spec Reference** | Data consistency |

**Test Steps**:

```typescript
it('complete event contains results stored in database', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  const completeEvent = await waitForEvent(job.id, 'complete');

  // Verify results are in database
  const dbResults = await db.result.findMany({
    where: { jobId: job.id },
  });

  // Event results should match database
  expect(completeEvent.results.length).toBe(dbResults.length);
  completeEvent.results.forEach((eventResult: any, index: number) => {
    expect(eventResult.format).toBe(dbResults[index].format);
    expect(eventResult.size).toBe(dbResults[index].size);
  });
});
```

---

### SSE-DB-004: Transaction Rollback Prevents SSE Event

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-DB-004 |
| **Title** | Database Transaction Rollback Prevents SSE Event |
| **Priority** | P0 - Critical |
| **Spec Reference** | Transaction boundaries |

**Test Steps**:

```typescript
it('database transaction rollback prevents SSE event', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  await waitFor(() => events.length >= 1);
  const eventCountBefore = events.length;

  // Start transaction that will be rolled back
  try {
    await db.$transaction(async (tx) => {
      await tx.job.update({
        where: { id: job.id },
        data: { status: 'COMPLETE', progress: 100 },
      });

      // This will trigger event publication
      await publishProgress(job.id, { stage: 'complete', percent: 100 });

      // Force rollback
      throw new Error('Simulated transaction failure');
    });
  } catch {
    // Expected
  }

  // Wait to ensure no event was sent
  await sleep(1000);

  // No new events should have been received
  // (In a proper implementation, event publishing is within transaction)
  const dbJob = await db.job.findUnique({ where: { id: job.id } });
  expect(dbJob.status).not.toBe('COMPLETE'); // Transaction rolled back

  eventSource.close();
});
```

---

### SSE-DB-005: Browser Refresh Recovery from Database

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-DB-005 |
| **Title** | Browser Refresh Recovers State from Database |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-503, State recovery |

**Test Steps**:

```typescript
it('browser refresh recovers state from database', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for significant progress
  await waitFor(async () => {
    const dbJob = await db.job.findUnique({ where: { id: job.id } });
    return dbJob.progress > 50;
  });

  // Simulate browser refresh - new connection with no Last-Event-ID
  const events: any[] = [];
  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  eventSource.addEventListener('state_sync', (e) => {
    events.push({ type: 'state_sync', data: JSON.parse(e.data) });
  });

  eventSource.addEventListener('progress', (e) => {
    events.push({ type: 'progress', data: JSON.parse(e.data) });
  });

  await waitFor(() => events.length >= 1);

  // Should receive state_sync with current database state
  const stateSync = events.find(e => e.type === 'state_sync');
  expect(stateSync).toBeDefined();

  const dbJob = await db.job.findUnique({ where: { id: job.id } });
  expect(stateSync.data.progress.percent).toBe(dbJob.progress);

  eventSource.close();
});
```

---

### SSE-TX-001: Atomic Event Publishing

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-TX-001 |
| **Title** | Event Publishing is Atomic with State Change |
| **Priority** | P0 - Critical |
| **Spec Reference** | ACID compliance |

**Test Steps**:

```typescript
it('event publishing is atomic with database state change', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Perform atomic update and event publish
  await db.$transaction(async (tx) => {
    await tx.job.update({
      where: { id: job.id },
      data: { progress: 75, currentStage: 'export' },
    });
    await publishProgressInTransaction(tx, job.id, { stage: 'export', percent: 75 });
  });

  // Event should be received
  await waitFor(() => events.some(e => e.percent === 75));

  // Database should match
  const dbJob = await db.job.findUnique({ where: { id: job.id } });
  expect(dbJob.progress).toBe(75);

  eventSource.close();
});
```

---

### SSE-TX-002: Concurrent Update Handling

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-TX-002 |
| **Title** | Handle Concurrent Database Updates |
| **Priority** | P1 - High |
| **Spec Reference** | Concurrency handling |

**Test Steps**:

```typescript
it('handles concurrent database updates correctly', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Concurrent updates
  await Promise.all([
    updateJobProgress(job.id, 50),
    updateJobProgress(job.id, 55),
    updateJobProgress(job.id, 60),
  ]);

  await sleep(1000);

  // Final database state should be deterministic
  const dbJob = await db.job.findUnique({ where: { id: job.id } });

  // Events should reflect valid progression
  const percentages = events.map(e => e.percent);
  // Should not have decreasing values (after sorting by event ID)
  const sortedEvents = events.sort((a, b) => a.id.localeCompare(b.id));
  for (let i = 1; i < sortedEvents.length; i++) {
    expect(sortedEvents[i].percent).toBeGreaterThanOrEqual(sortedEvents[i - 1].percent);
  }

  eventSource.close();
});
```

---

### SSE-TX-003: Optimistic Locking Conflict Resolution

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-TX-003 |
| **Title** | Handle Optimistic Locking Conflicts |
| **Priority** | P1 - High |
| **Spec Reference** | Concurrency handling |

**Test Steps**:

```typescript
it('handles optimistic locking conflicts gracefully', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Create optimistic locking conflict
  const job1 = await db.job.findUnique({ where: { id: job.id } });
  const job2 = await db.job.findUnique({ where: { id: job.id } });

  // Both try to update
  await Promise.allSettled([
    db.job.update({
      where: { id: job.id, version: job1.version },
      data: { progress: 50, version: { increment: 1 } },
    }),
    db.job.update({
      where: { id: job.id, version: job2.version },
      data: { progress: 60, version: { increment: 1 } },
    }),
  ]);

  // One should succeed, one should fail
  const dbJob = await db.job.findUnique({ where: { id: job.id } });
  expect([50, 60]).toContain(dbJob.progress);

  // SSE events should be consistent with final state
  await sleep(500);
  const lastEvent = events[events.length - 1];
  expect(lastEvent.percent).toBe(dbJob.progress);

  eventSource.close();
});
```

---

### SSE-REFRESH-001: Refresh During Processing

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REFRESH-001 |
| **Title** | Browser Refresh During Processing |
| **Priority** | P1 - High |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('browser refresh during processing recovers correctly', async ({ page }) => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  await page.goto(`/process/${job.id}`);

  // Wait for progress
  await page.waitForSelector('[data-testid="progress-bar"]');
  const progressBefore = await page.locator('[data-testid="progress-percent"]').textContent();

  // Refresh the page
  await page.reload();

  // Should show current progress after refresh
  await page.waitForSelector('[data-testid="progress-bar"]');
  const progressAfter = await page.locator('[data-testid="progress-percent"]').textContent();

  expect(parseInt(progressAfter!)).toBeGreaterThanOrEqual(parseInt(progressBefore!));
});
```

---

### SSE-REFRESH-002: Refresh After Completion

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REFRESH-002 |
| **Title** | Browser Refresh After Completion Shows Results |
| **Priority** | P1 - High |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('browser refresh after completion shows results', async ({ page }) => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  await page.goto(`/process/${job.id}`);

  // Wait for completion
  await page.waitForSelector('[data-testid="results-container"]', { timeout: 120000 });

  // Refresh the page
  await page.reload();

  // Should show results immediately
  await page.waitForSelector('[data-testid="results-container"]');
  const resultsVisible = await page.isVisible('[data-testid="download-button"]');
  expect(resultsVisible).toBe(true);
});
```

---

### SSE-REFRESH-003: Refresh After Error

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-REFRESH-003 |
| **Title** | Browser Refresh After Error Shows Error State |
| **Priority** | P1 - High |
| **Spec Reference** | FR-503 |

**Test Steps**:

```typescript
it('browser refresh after error shows error state', async ({ page }) => {
  const job = await createJob({ status: 'PROCESSING' });
  simulateProcessingError(job.id, { code: 'E302' });

  await page.goto(`/process/${job.id}`);

  // Wait for error state
  await page.waitForSelector('[data-testid="error-message"]');

  // Refresh the page
  await page.reload();

  // Should show error state
  await page.waitForSelector('[data-testid="error-message"]');
  const errorCode = await page.locator('[data-testid="error-code"]').textContent();
  expect(errorCode).toBe('E302');
});
```

---

## 13. Component Integration Tests

### 13.1 UI Component Tests

These tests validate that UI components correctly render SSE event data and respond to state changes.

---

### SSE-COMP-001: ProgressCard Renders Progress Events

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-COMP-001 |
| **Title** | ProgressCard Component Renders SSE Progress |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-502, UI Components |

**Test Steps**:

```typescript
it('ProgressCard renders SSE progress events', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ProgressCard jobId={job.id} />);

  // Initially shows 0%
  expect(screen.getByTestId('progress-percent')).toHaveTextContent('0%');

  // Publish progress event
  await publishProgress(job.id, { stage: 'parsing', percent: 25, message: 'Parsing document...' });

  await waitFor(() => {
    expect(screen.getByTestId('progress-percent')).toHaveTextContent('25%');
    expect(screen.getByTestId('progress-stage')).toHaveTextContent('parsing');
    expect(screen.getByTestId('progress-message')).toHaveTextContent('Parsing document...');
  });
});
```

---

### SSE-COMP-002: StatusBadge Updates on State Change

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-COMP-002 |
| **Title** | StatusBadge Component Updates on SSE Events |
| **Priority** | P1 - High |
| **Spec Reference** | UI Components |

**Test Steps**:

```typescript
it('StatusBadge updates when SSE events change status', async () => {
  const job = await createJob({ status: 'PENDING' });

  render(<StatusBadge jobId={job.id} />);

  expect(screen.getByTestId('status-badge')).toHaveTextContent('Pending');
  expect(screen.getByTestId('status-badge')).toHaveClass('bg-gray-100');

  // Transition to processing
  await publishProgress(job.id, { stage: 'parsing', percent: 10 });

  await waitFor(() => {
    expect(screen.getByTestId('status-badge')).toHaveTextContent('Processing');
    expect(screen.getByTestId('status-badge')).toHaveClass('bg-blue-100');
  });

  // Transition to complete
  await publishComplete(job.id, { results: [] });

  await waitFor(() => {
    expect(screen.getByTestId('status-badge')).toHaveTextContent('Complete');
    expect(screen.getByTestId('status-badge')).toHaveClass('bg-green-100');
  });
});
```

---

### SSE-COMP-003: ErrorAlert Displays Error Events

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-COMP-003 |
| **Title** | ErrorAlert Component Displays SSE Error Events |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-801, UI Components |

**Test Steps**:

```typescript
it('ErrorAlert displays SSE error events with details', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ErrorAlert jobId={job.id} />);

  // Initially no error
  expect(screen.queryByTestId('error-alert')).not.toBeInTheDocument();

  // Publish error event
  await publishErrorEvent(job.id, {
    code: 'E302',
    message: 'Conversion failed',
    userMessage: 'Unable to process your document',
    suggestedAction: 'Try uploading a different file',
    retryable: true,
  });

  await waitFor(() => {
    expect(screen.getByTestId('error-alert')).toBeInTheDocument();
    expect(screen.getByTestId('error-code')).toHaveTextContent('E302');
    expect(screen.getByTestId('error-user-message')).toHaveTextContent('Unable to process your document');
    expect(screen.getByTestId('error-action')).toHaveTextContent('Try uploading a different file');
    expect(screen.getByTestId('retry-button')).toBeEnabled();
  });
});
```

---

### SSE-COMP-004: ConnectionStatus Indicator

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-COMP-004 |
| **Title** | ConnectionStatus Component Shows Connection State |
| **Priority** | P1 - High |
| **Spec Reference** | UI Components |

**Test Steps**:

```typescript
it('ConnectionStatus shows connection state changes', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ConnectionStatus jobId={job.id} />);

  // Initially disconnected
  expect(screen.getByTestId('connection-status')).toHaveTextContent('Connecting...');

  // Wait for connection
  await waitFor(() => {
    expect(screen.getByTestId('connection-status')).toHaveTextContent('Connected');
    expect(screen.getByTestId('connection-indicator')).toHaveClass('bg-green-500');
  });

  // Simulate disconnect
  await simulateConnectionDrop(job.id);

  await waitFor(() => {
    expect(screen.getByTestId('connection-status')).toHaveTextContent('Reconnecting...');
    expect(screen.getByTestId('connection-indicator')).toHaveClass('bg-yellow-500');
  });
});
```

---

### SSE-COMP-005: ResultsPanel Renders Complete Event

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-COMP-005 |
| **Title** | ResultsPanel Component Renders Complete Event Data |
| **Priority** | P0 - Critical |
| **Spec Reference** | FR-501, UI Components |

**Test Steps**:

```typescript
it('ResultsPanel renders results from complete event', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ResultsPanel jobId={job.id} />);

  // Initially no results
  expect(screen.queryByTestId('results-list')).not.toBeInTheDocument();

  // Publish complete event
  await publishComplete(job.id, {
    results: [
      { format: 'MARKDOWN', size: 1024, url: '/api/v1/results/1' },
      { format: 'HTML', size: 2048, url: '/api/v1/results/2' },
    ],
  });

  await waitFor(() => {
    expect(screen.getByTestId('results-list')).toBeInTheDocument();
    expect(screen.getAllByTestId('result-item')).toHaveLength(2);
    expect(screen.getByText('MARKDOWN')).toBeInTheDocument();
    expect(screen.getByText('HTML')).toBeInTheDocument();
  });
});
```

---

## 14. MCP-to-SSE Integration Tests

### 14.1 End-to-End MCP-SSE Integration

These tests validate the complete integration flow from MCP tool invocation through progress callbacks, Redis Pub/Sub publishing, SSE streaming, and client-side event consumption.

---

### SSE-MCP-001: MCP Progress Callback to SSE Event Mapping

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-001 |
| **Title** | MCP Progress Callback Correctly Maps to SSE Progress Event |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 1.4.3 (Event Mapping), Section 5.4 (MCP Integration) |

**Test Steps**:

```typescript
it('MCP progress callback maps to SSE progress event', async () => {
  // Setup: Mock MCP server with progress callbacks
  const mcpServer = mockMCPServer();
  const job = await createJob({ status: 'PROCESSING' });

  // Setup SSE subscription
  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Invoke MCP tool with progress callbacks
  await mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/doc.pdf',
    onProgress: (progress: MCPProgressEvent) => {
      // Callback triggered by MCP server
      expect(progress).toMatchObject({
        stage: expect.stringMatching(/parsing|conversion|export/),
        progress: expect.any(Number),
      });
    },
  });

  // Simulate MCP progress callback at 25%
  await mcpServer.emitProgress({
    jobId: job.id,
    stage: 'parsing',
    progress: 0.25,
  });

  // Wait for SSE event
  await waitFor(() => {
    expect(events).toHaveLength(1);
  });

  const progressEvent = JSON.parse(events[0].data);
  expect(progressEvent).toMatchObject({
    stage: 'parsing',
    percent: 25, // MCP progress 0.25 → SSE percent 25
    message: expect.stringContaining('Parsing'),
  });

  // Simulate MCP progress callback at 60%
  await mcpServer.emitProgress({
    jobId: job.id,
    stage: 'conversion',
    progress: 0.60,
  });

  await waitFor(() => {
    expect(events).toHaveLength(2);
  });

  const conversionEvent = JSON.parse(events[1].data);
  expect(conversionEvent).toMatchObject({
    stage: 'conversion',
    percent: 60,
    message: expect.stringContaining('Converting'),
  });

  eventSource.close();
});
```

**Expected Result**:
- MCP progress callbacks (0-1.0 scale) correctly map to SSE progress events (0-100 scale)
- Stage names preserved: `parsing`, `conversion`, `export`
- User-friendly messages generated for each stage
- Event ordering preserved (parsing → conversion → export)

---

### SSE-MCP-002: MCP Completion to SSE Complete Event

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-002 |
| **Title** | MCP Tool Completion Triggers SSE Complete Event |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 1.4.3 (Event Mapping), FR-501 |

**Test Steps**:

```typescript
it('MCP tool completion triggers SSE complete event with results', async () => {
  const mcpServer = mockMCPServer();
  const job = await createJob({ status: 'PROCESSING' });

  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Invoke MCP tool
  const mcpPromise = mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/doc.pdf',
    outputFormats: ['MARKDOWN', 'HTML'],
  });

  // Simulate successful completion with results
  await mcpServer.completeWithResults({
    jobId: job.id,
    status: 'completed',
    results: [
      { format: 'MARKDOWN', url: '/results/doc.md', size: 2048 },
      { format: 'HTML', url: '/results/doc.html', size: 4096 },
    ],
  });

  await mcpPromise;

  // Wait for SSE complete event
  const completeEvent = await waitForEvent(job.id, 'complete');

  expect(completeEvent.type).toBe('complete');
  expect(completeEvent.data).toMatchObject({
    jobId: job.id,
    status: 'COMPLETED',
    results: [
      { format: 'MARKDOWN', url: '/results/doc.md', size: 2048 },
      { format: 'HTML', url: '/results/doc.html', size: 4096 },
    ],
  });

  // Verify job status updated in database
  const updatedJob = await db.jobs.findById(job.id);
  expect(updatedJob.status).toBe('COMPLETED');
  expect(updatedJob.results).toHaveLength(2);

  eventSource.close();
});
```

**Expected Result**:
- MCP completion successfully triggers SSE `complete` event
- Result data correctly transferred from MCP to SSE event
- Job status updated to `COMPLETED` in database
- All output formats included in results array

---

### SSE-MCP-003: MCP Error to SSE Error Event with Enrichment

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-003 |
| **Title** | MCP Tool Errors Map to SSE Error Events with User-Friendly Messages |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 1.4.4 (Error Propagation), FR-801 |

**Test Steps**:

```typescript
it('MCP tool errors map to SSE error events with enrichment', async () => {
  const mcpServer = mockMCPServer();
  const job = await createJob({ status: 'PROCESSING' });

  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Invoke MCP tool
  const mcpPromise = mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/corrupted.pdf',
  });

  // Simulate MCP tool execution failure
  await mcpServer.emitError({
    jobId: job.id,
    code: 'TOOL_EXECUTION_FAILED',
    message: 'Failed to parse PDF: corrupted file structure',
    details: { parsedPages: 2, totalPages: 10 },
  });

  await expect(mcpPromise).rejects.toThrow('TOOL_EXECUTION_FAILED');

  // Wait for SSE error event
  const errorEvent = await waitForEvent(job.id, 'error');

  expect(errorEvent.type).toBe('error');
  expect(errorEvent.data).toMatchObject({
    code: 'E302', // MCP error code mapped to user-facing code
    message: 'Failed to parse PDF: corrupted file structure',
    userMessage: 'Unable to process your document', // User-friendly message
    suggestedAction: 'Try uploading a different file format',
    retryable: true,
    mcpDetails: {
      // Original MCP error preserved
      parsedPages: 2,
      totalPages: 10,
    },
  });

  // Verify job status updated to FAILED
  const updatedJob = await db.jobs.findById(job.id);
  expect(updatedJob.status).toBe('FAILED');
  expect(updatedJob.error).toMatchObject({
    code: 'E302',
    message: expect.any(String),
  });

  eventSource.close();
});
```

**Expected Result**:
- MCP tool execution errors correctly map to SSE error events
- Error codes enriched with user-facing codes (E302, E501, E502)
- User-friendly messages added (`userMessage`, `suggestedAction`)
- Original MCP error details preserved in `mcpDetails` field
- Retryability correctly determined based on error type

---

### SSE-MCP-004: MCP Timeout Handling via SSE

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-004 |
| **Title** | MCP Server Timeout Generates SSE Error Event |
| **Priority** | P1 - High |
| **Spec Reference** | Section 1.4.4 (Error Propagation), NFR-104 |

**Test Steps**:

```typescript
it('MCP server timeout generates SSE error event', async () => {
  const mcpServer = mockMCPServer({ timeout: 100 }); // 100ms timeout
  const job = await createJob({ status: 'PROCESSING' });

  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Invoke MCP tool that will timeout
  const mcpPromise = mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/large-doc.pdf',
  });

  // Simulate MCP server hanging (no response)
  await mcpServer.simulateHang();

  // Wait for timeout to trigger
  await sleep(150);

  await expect(mcpPromise).rejects.toThrow('TIMEOUT');

  // Wait for SSE error event
  const errorEvent = await waitForEvent(job.id, 'error');

  expect(errorEvent.type).toBe('error');
  expect(errorEvent.data).toMatchObject({
    code: 'E501', // MCP timeout mapped to E501
    message: 'MCP server timeout',
    userMessage: 'Request timed out. Please try again.',
    suggestedAction: 'Retry your request',
    retryable: true,
    mcpDetails: {
      timeout: 100,
    },
  });

  // Verify job marked as FAILED with timeout error
  const updatedJob = await db.jobs.findById(job.id);
  expect(updatedJob.status).toBe('FAILED');
  expect(updatedJob.error.code).toBe('E501');

  eventSource.close();
});
```

**Expected Result**:
- MCP server timeout correctly detected (100ms in test)
- SSE error event generated with code `E501`
- User-friendly timeout message provided
- Job marked as `FAILED` with retryable flag set
- Timeout duration preserved in `mcpDetails`

---

### SSE-MCP-005: MCP Checkpoint to SSE State Sync

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-005 |
| **Title** | MCP Checkpoint Events Map to SSE State Sync Events |
| **Priority** | P1 - High |
| **Spec Reference** | Section 1.4.5 (State Synchronization), FR-503 |

**Test Steps**:

```typescript
it('MCP checkpoint events map to SSE state_sync events', async () => {
  const mcpServer = mockMCPServer({ checkpointingEnabled: true });
  const job = await createJob({ status: 'PROCESSING' });

  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Invoke MCP tool with checkpointing
  await mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/multi-page.pdf',
    enableCheckpoints: true,
  });

  // Simulate MCP checkpoint after parsing stage
  await mcpServer.emitCheckpoint({
    jobId: job.id,
    checkpoint_id: 'checkpoint_1_parsing',
    stage: 'parsing',
    progress: 0.40,
    state: {
      parsed_pages: 5,
      total_pages: 10,
      current_format: 'PDF',
    },
  });

  // Wait for SSE state_sync event
  const stateSyncEvent = await waitForEvent(job.id, 'state_sync');

  expect(stateSyncEvent.type).toBe('state_sync');
  expect(stateSyncEvent.data).toMatchObject({
    jobId: job.id,
    status: 'PROCESSING',
    progress: {
      stage: 'parsing',
      percent: 40, // MCP progress 0.40 → SSE percent 40
      message: expect.stringContaining('Parsing'),
    },
    checkpoint: {
      id: 'checkpoint_1_parsing',
      stage: 'parsing',
      state: {
        parsed_pages: 5,
        total_pages: 10,
        current_format: 'PDF',
      },
    },
    timestamp: expect.any(String),
  });

  // Verify checkpoint stored in Redis for recovery
  const storedCheckpoint = await redis.get(`job:${job.id}:checkpoint:latest`);
  expect(storedCheckpoint).toBeTruthy();
  expect(JSON.parse(storedCheckpoint)).toMatchObject({
    checkpoint_id: 'checkpoint_1_parsing',
    stage: 'parsing',
  });

  eventSource.close();
});
```

**Expected Result**:
- MCP checkpoint events correctly map to SSE `state_sync` events
- Checkpoint state data fully preserved in SSE event
- Progress data correctly converted (0-1.0 → 0-100 scale)
- Checkpoint stored in Redis with key `job:{jobId}:checkpoint:latest`
- Client can reconstruct full state from checkpoint on reconnection

---

### SSE-MCP-006: End-to-End MCP-SSE Flow Validation

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-MCP-006 |
| **Title** | Complete MCP-to-SSE Integration Flow (E2E) |
| **Priority** | P0 - Critical |
| **Spec Reference** | Section 1.4.2 (End-to-End Data Flow), FR-501, FR-502 |

**Test Steps**:

```typescript
it('validates complete MCP-to-SSE integration flow end-to-end', async () => {
  const mcpServer = mockMCPServer();
  const job = await createJob({ status: 'PENDING' });

  const events: MessageEvent[] = [];
  const eventSource = subscribeToJob(job.id, (event) => events.push(event));

  // Step 1: Invoke MCP tool
  const mcpPromise = mcpServer.invokeTool('docling_convert', {
    jobId: job.id,
    inputUrl: '/test/document.pdf',
    outputFormats: ['MARKDOWN', 'HTML'],
  });

  // Step 2: Simulate MCP progress callbacks (parsing → conversion → export)
  await mcpServer.emitProgress({ jobId: job.id, stage: 'parsing', progress: 0.10 });
  await sleep(50);
  await mcpServer.emitProgress({ jobId: job.id, stage: 'parsing', progress: 0.30 });
  await sleep(50);
  await mcpServer.emitProgress({ jobId: job.id, stage: 'conversion', progress: 0.50 });
  await sleep(50);
  await mcpServer.emitProgress({ jobId: job.id, stage: 'conversion', progress: 0.70 });
  await sleep(50);
  await mcpServer.emitProgress({ jobId: job.id, stage: 'export', progress: 0.90 });
  await sleep(50);

  // Step 3: Complete MCP tool execution
  await mcpServer.completeWithResults({
    jobId: job.id,
    status: 'completed',
    results: [
      { format: 'MARKDOWN', url: '/results/doc.md', size: 3072 },
      { format: 'HTML', url: '/results/doc.html', size: 5120 },
    ],
  });

  await mcpPromise;

  // Step 4: Validate all SSE events received in correct order
  await waitFor(() => {
    expect(events.length).toBeGreaterThanOrEqual(6); // 5 progress + 1 complete
  });

  // Validate connected event
  const connectedEvent = events.find((e) => e.type === 'connected');
  expect(connectedEvent).toBeDefined();

  // Validate progress events (monotonically increasing)
  const progressEvents = events
    .filter((e) => e.type === 'message' && JSON.parse(e.data).stage)
    .map((e) => JSON.parse(e.data));

  expect(progressEvents).toHaveLength(5);
  expect(progressEvents[0]).toMatchObject({ stage: 'parsing', percent: 10 });
  expect(progressEvents[1]).toMatchObject({ stage: 'parsing', percent: 30 });
  expect(progressEvents[2]).toMatchObject({ stage: 'conversion', percent: 50 });
  expect(progressEvents[3]).toMatchObject({ stage: 'conversion', percent: 70 });
  expect(progressEvents[4]).toMatchObject({ stage: 'export', percent: 90 });

  // Validate monotonic progress (no decreases)
  for (let i = 1; i < progressEvents.length; i++) {
    expect(progressEvents[i].percent).toBeGreaterThanOrEqual(progressEvents[i - 1].percent);
  }

  // Validate complete event
  const completeEvent = events.find((e) => e.type === 'complete');
  expect(completeEvent).toBeDefined();
  const completeData = JSON.parse(completeEvent.data);
  expect(completeData).toMatchObject({
    jobId: job.id,
    status: 'COMPLETED',
    results: [
      { format: 'MARKDOWN', url: '/results/doc.md', size: 3072 },
      { format: 'HTML', url: '/results/doc.html', size: 5120 },
    ],
  });

  // Step 5: Verify final job state in database
  const finalJob = await db.jobs.findById(job.id);
  expect(finalJob.status).toBe('COMPLETED');
  expect(finalJob.progress).toBe(100);
  expect(finalJob.results).toHaveLength(2);

  // Step 6: Verify Redis cleanup
  const jobChannel = `job:${job.id}:progress`;
  const subscribers = await redis.pubsub('NUMSUB', jobChannel);
  expect(subscribers[1]).toBe(0); // No active subscribers after completion

  eventSource.close();
});
```

**Expected Result**:
- Complete MCP-to-SSE integration flow executes successfully
- All progress events received in correct order (parsing → conversion → export)
- Progress is monotonically increasing (no backward progress)
- Complete event includes all expected result data
- Job status correctly updated to `COMPLETED` in database
- Redis pub/sub channel cleaned up after completion
- No event loss or duplication throughout the flow

---

## 15. Accessibility Tests

### 15.1 WCAG Compliance Tests

These tests ensure SSE-driven UI updates are accessible to all users, including those using assistive technologies.

---

### SSE-A11Y-001: Progress Updates Announced to Screen Readers

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-A11Y-001 |
| **Title** | Progress Updates Use ARIA Live Regions |
| **Priority** | P1 - High |
| **Spec Reference** | WCAG 2.1 AA |

**Test Steps**:

```typescript
it('progress updates are announced via ARIA live regions', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ProgressCard jobId={job.id} />);

  // Live region should exist
  const liveRegion = screen.getByRole('status');
  expect(liveRegion).toHaveAttribute('aria-live', 'polite');

  // Publish progress
  await publishProgress(job.id, { stage: 'parsing', percent: 50, message: '50% complete' });

  await waitFor(() => {
    expect(liveRegion).toHaveTextContent('50% complete');
  });
});
```

---

### SSE-A11Y-002: Error Messages Accessible

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-A11Y-002 |
| **Title** | Error Messages Are Accessible |
| **Priority** | P1 - High |
| **Spec Reference** | WCAG 2.1 AA |

**Test Steps**:

```typescript
it('error messages are properly announced', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ErrorAlert jobId={job.id} />);

  await publishErrorEvent(job.id, {
    code: 'E302',
    userMessage: 'Document processing failed',
  });

  await waitFor(() => {
    const alert = screen.getByRole('alert');
    expect(alert).toHaveAttribute('aria-live', 'assertive');
    expect(alert).toHaveTextContent('Document processing failed');
  });
});
```

---

### SSE-A11Y-003: Keyboard Navigation During Progress

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-A11Y-003 |
| **Title** | Keyboard Navigation Maintained During Updates |
| **Priority** | P1 - High |
| **Spec Reference** | WCAG 2.1 AA |

**Test Steps**:

```typescript
it('keyboard focus is not disrupted by SSE updates', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  render(<ProcessingPage jobId={job.id} />);

  // Focus on cancel button
  const cancelButton = screen.getByTestId('cancel-button');
  cancelButton.focus();
  expect(document.activeElement).toBe(cancelButton);

  // Publish multiple progress updates
  for (let i = 0; i < 10; i++) {
    await publishProgress(job.id, { stage: 'parsing', percent: i * 10 });
    await sleep(100);
  }

  // Focus should remain on cancel button
  expect(document.activeElement).toBe(cancelButton);
});
```

---

### SSE-A11Y-004: Reduced Motion Support

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-A11Y-004 |
| **Title** | Progress Animations Respect Reduced Motion |
| **Priority** | P1 - High |
| **Spec Reference** | WCAG 2.1 AA |

**Test Steps**:

```typescript
it('respects prefers-reduced-motion setting', async () => {
  // Set reduced motion preference
  window.matchMedia = jest.fn().mockImplementation(query => ({
    matches: query === '(prefers-reduced-motion: reduce)',
    media: query,
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
  }));

  const job = await createJob({ status: 'PROCESSING' });

  render(<ProgressCard jobId={job.id} />);

  await publishProgress(job.id, { stage: 'parsing', percent: 50 });

  await waitFor(() => {
    const progressBar = screen.getByRole('progressbar');
    const styles = window.getComputedStyle(progressBar);
    // Should not have transition animation
    expect(styles.transition).toBe('none');
  });
});
```

---

## 16. Job State Machine Tests

### 16.1 State Transition Tests

These tests validate that SSE events correctly reflect job state machine transitions.

---

### SSE-STATE-001: Valid State Transitions

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-STATE-001 |
| **Title** | SSE Events Reflect Valid State Transitions |
| **Priority** | P0 - Critical |
| **Spec Reference** | Job state machine |

**Test Steps**:

```typescript
describe('Valid State Transitions', () => {
  const validTransitions = [
    ['PENDING', 'PROCESSING'],
    ['PROCESSING', 'COMPLETE'],
    ['PROCESSING', 'FAILED'],
    ['PROCESSING', 'CANCELLED'],
    ['FAILED', 'RETRY_1'],
    ['RETRY_1', 'PROCESSING'],
  ];

  validTransitions.forEach(([from, to]) => {
    it(`transitions from ${from} to ${to}`, async () => {
      const job = await createJob({ status: from });

      const events: any[] = [];
      const eventSource = subscribeToJob(job.id);

      eventSource.onmessage = (e) => {
        events.push(JSON.parse(e.data));
      };

      // Trigger state transition
      await transitionJobState(job.id, to);

      await waitFor(() => {
        const statusEvent = events.find(e => e.status === to);
        expect(statusEvent).toBeDefined();
      });

      eventSource.close();
    });
  });
});
```

---

### SSE-STATE-002: Invalid State Transitions Prevented

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-STATE-002 |
| **Title** | Invalid State Transitions Are Prevented |
| **Priority** | P1 - High |
| **Spec Reference** | Job state machine |

**Test Steps**:

```typescript
describe('Invalid State Transitions', () => {
  const invalidTransitions = [
    ['COMPLETE', 'PROCESSING'],
    ['CANCELLED', 'PROCESSING'],
    ['PENDING', 'COMPLETE'],
    ['FAILED', 'COMPLETE'],
  ];

  invalidTransitions.forEach(([from, to]) => {
    it(`prevents transition from ${from} to ${to}`, async () => {
      const job = await createJob({ status: from });

      const events: any[] = [];
      const eventSource = subscribeToJob(job.id);

      eventSource.onmessage = (e) => {
        events.push(JSON.parse(e.data));
      };

      // Attempt invalid transition
      const result = await transitionJobState(job.id, to).catch(e => e);

      expect(result).toBeInstanceOf(Error);

      // No event for invalid transition
      await sleep(500);
      expect(events.filter(e => e.status === to)).toHaveLength(0);

      eventSource.close();
    });
  });
});
```

---

### SSE-STATE-003: Retry State Sequence

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-STATE-003 |
| **Title** | Retry States Follow Correct Sequence |
| **Priority** | P1 - High |
| **Spec Reference** | FR-803 |

**Test Steps**:

```typescript
it('retry states follow RETRY_1 -> RETRY_2 -> RETRY_3 -> FAILED sequence', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const states: string[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.onmessage = (e) => {
    const data = JSON.parse(e.data);
    if (data.status && !states.includes(data.status)) {
      states.push(data.status);
    }
  };

  // Simulate failures that trigger retries
  await simulateProcessingFailure(job.id);
  await sleep(2000);
  await simulateProcessingFailure(job.id);
  await sleep(2000);
  await simulateProcessingFailure(job.id);
  await sleep(2000);
  await simulateProcessingFailure(job.id);

  await waitFor(() => states.includes('FAILED'));

  // Verify retry sequence
  expect(states).toContain('RETRY_1');
  expect(states).toContain('RETRY_2');
  expect(states).toContain('RETRY_3');
  expect(states).toContain('FAILED');

  // Verify order
  expect(states.indexOf('RETRY_1')).toBeLessThan(states.indexOf('RETRY_2'));
  expect(states.indexOf('RETRY_2')).toBeLessThan(states.indexOf('RETRY_3'));
  expect(states.indexOf('RETRY_3')).toBeLessThan(states.indexOf('FAILED'));

  eventSource.close();
});
```

---

### SSE-STATE-004: Checkpoint Recovery State

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-STATE-004 |
| **Title** | Checkpoint Recovery Resumes from Correct State |
| **Priority** | P1 - High |
| **Spec Reference** | Checkpoint system |

**Test Steps**:

```typescript
it('checkpoint recovery resumes from last checkpoint state', async () => {
  const job = await createJob({ status: 'PROCESSING' });
  startProcessing(job.id);

  // Wait for checkpoint
  await waitFor(async () => {
    const checkpoint = await getLatestCheckpoint(job.id);
    return checkpoint?.stage === 'conversion';
  });

  // Simulate failure
  await simulateProcessingFailure(job.id);

  // Wait for retry
  await waitFor(async () => {
    const dbJob = await db.job.findUnique({ where: { id: job.id } });
    return dbJob.status === 'RETRY_1';
  });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Should resume from checkpoint, not start
  await waitFor(() => events.length >= 1);

  // First progress event should be at or after checkpoint stage
  expect(['conversion', 'export', 'saving']).toContain(events[0].stage);

  eventSource.close();
});
```

---

### SSE-STATE-005: Terminal State No Further Updates

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-STATE-005 |
| **Title** | No Progress Updates After Terminal State |
| **Priority** | P1 - High |
| **Spec Reference** | Job state machine |

**Test Steps**:

```typescript
describe('Terminal States', () => {
  const terminalStates = ['COMPLETE', 'FAILED', 'CANCELLED'];

  terminalStates.forEach(terminalState => {
    it(`no progress events after ${terminalState}`, async () => {
      const job = await createJob({ status: terminalState });

      const events: any[] = [];
      const eventSource = subscribeToJob(job.id);

      eventSource.addEventListener('progress', (e) => {
        events.push(JSON.parse(e.data));
      });

      // Try to publish progress
      await publishProgress(job.id, { stage: 'test', percent: 50 }).catch(() => {});

      await sleep(1000);

      // Should not receive progress events
      expect(events.filter(e => e.type === 'progress')).toHaveLength(0);

      eventSource.close();
    });
  });
});
```

---

## 17. Infrastructure Health Tests

### 17.1 Health Monitoring Tests

These tests validate operational monitoring and health check functionality for SSE infrastructure.

---

### SSE-HEALTH-001: SSE Endpoint Health Check

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HEALTH-001 |
| **Title** | SSE Endpoint Included in Health Check |
| **Priority** | P0 - Critical |
| **Spec Reference** | Operational requirements |

**Test Steps**:

```typescript
it('health check includes SSE endpoint status', async () => {
  const response = await fetch('/api/health');
  const health = await response.json();

  expect(health.sse).toBeDefined();
  expect(health.sse.status).toBe('healthy');
  expect(health.sse.activeConnections).toBeGreaterThanOrEqual(0);
  expect(health.sse.redisConnected).toBe(true);
});
```

---

### SSE-HEALTH-002: Prometheus Metrics Exposed

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-HEALTH-002 |
| **Title** | SSE Metrics Exposed for Prometheus |
| **Priority** | P1 - High |
| **Spec Reference** | Monitoring requirements |

**Test Steps**:

```typescript
it('exposes SSE metrics for Prometheus', async () => {
  const response = await fetch('/api/metrics');
  const metrics = await response.text();

  // SSE connection metrics
  expect(metrics).toContain('sse_active_connections');
  expect(metrics).toContain('sse_total_connections');
  expect(metrics).toContain('sse_connection_duration_seconds');

  // Event metrics
  expect(metrics).toContain('sse_events_published_total');
  expect(metrics).toContain('sse_events_delivered_total');

  // Error metrics
  expect(metrics).toContain('sse_connection_errors_total');
  expect(metrics).toContain('sse_event_delivery_errors_total');
});
```

---

### SSE-LOG-001: Structured Logging

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-LOG-001 |
| **Title** | SSE Events Generate Structured Logs |
| **Priority** | P1 - High |
| **Spec Reference** | Operational requirements |

**Test Steps**:

```typescript
it('generates structured logs for SSE events', async () => {
  const logCapture: any[] = [];
  const originalLog = console.log;
  console.log = (msg) => {
    try { logCapture.push(JSON.parse(msg)); } catch {}
  };

  const job = await createJob({ status: 'PROCESSING' });
  const eventSource = subscribeToJob(job.id);

  await waitFor(() => eventSource.readyState === EventSource.OPEN);
  await publishProgress(job.id, { stage: 'test', percent: 50 });
  await sleep(500);

  eventSource.close();
  console.log = originalLog;

  // Check for structured log entries
  const connectionLog = logCapture.find(l => l.event === 'sse_connection_established');
  expect(connectionLog).toBeDefined();
  expect(connectionLog.jobId).toBe(job.id);

  const eventLog = logCapture.find(l => l.event === 'sse_event_published');
  expect(eventLog).toBeDefined();
});
```

---

### SSE-CLEAN-001: Idle Connection Cleanup

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CLEAN-001 |
| **Title** | Idle SSE Connections Are Cleaned Up |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('cleans up idle connections after timeout', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventSource = subscribeToJob(job.id);
  await waitFor(() => eventSource.readyState === EventSource.OPEN);

  const initialConnections = await getServerActiveConnections(job.id);
  expect(initialConnections).toBe(1);

  // Wait for idle timeout (configured as 5 minutes, shortened in test)
  await sleep(6000);

  // Connection should be closed by server
  expect(eventSource.readyState).toBe(EventSource.CLOSED);

  // Server connections should be cleaned
  const finalConnections = await getServerActiveConnections(job.id);
  expect(finalConnections).toBe(0);
}, 10000);
```

---

### SSE-CLEAN-002: Orphaned Subscription Cleanup

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CLEAN-002 |
| **Title** | Orphaned Redis Subscriptions Cleaned Up |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('cleans up orphaned Redis subscriptions', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Create connection that will be orphaned
  const eventSource = subscribeToJob(job.id);
  await waitFor(() => eventSource.readyState === EventSource.OPEN);

  // Force close without proper cleanup
  (eventSource as any)._forceClose();

  // Wait for cleanup cycle
  await sleep(10000);

  // Redis subscription should be cleaned up
  const subscriptions = await redis.pubsub('NUMSUB', `hx-docling:job:${job.id}:progress`);
  expect(subscriptions[1]).toBe(0);
}, 15000);
```

---

### SSE-CLEAN-003: Memory Leak Prevention

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-CLEAN-003 |
| **Title** | No Memory Leaks from SSE Connections |
| **Priority** | P1 - High |
| **Spec Reference** | Resource management |

**Test Steps**:

```typescript
it('no memory leaks from repeated connections', async () => {
  const initialMemory = process.memoryUsage().heapUsed;

  // Create and destroy many connections
  for (let i = 0; i < 100; i++) {
    const job = await createJob({ status: 'PROCESSING' });
    const eventSource = subscribeToJob(job.id);
    await waitFor(() => eventSource.readyState === EventSource.OPEN);
    eventSource.close();
    await sleep(10);
  }

  // Force garbage collection if available
  if (global.gc) global.gc();

  await sleep(1000);

  const finalMemory = process.memoryUsage().heapUsed;

  // Memory increase should be minimal (< 50MB)
  const memoryIncrease = finalMemory - initialMemory;
  expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
});
```

---

## 18. Load and Performance Tests

### 18.1 Load Testing

These tests validate SSE infrastructure under high load conditions.

---

### SSE-LOAD-001: Concurrent Connection Load

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-LOAD-001 |
| **Title** | Handle 100 Concurrent SSE Connections |
| **Priority** | P1 - High |
| **Spec Reference** | NFR-103 |

**Test Steps**:

```typescript
it('handles 100 concurrent SSE connections', async () => {
  const jobs = await Promise.all(
    Array.from({ length: 100 }, () => createJob({ status: 'PROCESSING' }))
  );

  const connections = jobs.map(job =>
    subscribeToJob(job.id)
  );

  // Wait for all connections to establish
  await waitFor(() =>
    connections.every(c => c.readyState === EventSource.OPEN)
  );

  // All connections should be open
  const openConnections = connections.filter(c => c.readyState === EventSource.OPEN);
  expect(openConnections.length).toBe(100);

  // Publish event to all jobs
  await Promise.all(
    jobs.map(job => publishProgress(job.id, { stage: 'test', percent: 50 }))
  );

  // All should receive events
  await sleep(2000);

  connections.forEach(c => c.close());
}, 30000);
```

---

### SSE-LOAD-002: High Event Throughput

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-LOAD-002 |
| **Title** | Handle High Event Throughput |
| **Priority** | P1 - High |
| **Spec Reference** | NFR-104 |

**Test Steps**:

```typescript
it('handles 1000 events per second', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  let receivedCount = 0;
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', () => {
    receivedCount++;
  });

  await waitFor(() => eventSource.readyState === EventSource.OPEN);

  const startTime = Date.now();

  // Publish 1000 events as fast as possible
  const publishPromises = Array.from({ length: 1000 }, (_, i) =>
    publishProgress(job.id, { stage: 'test', percent: i % 100 })
  );

  await Promise.all(publishPromises);

  // Wait for delivery
  await waitFor(() => receivedCount >= 900, { timeout: 10000 });

  const duration = Date.now() - startTime;

  // Should complete within reasonable time
  expect(duration).toBeLessThan(10000);
  // At least 90% delivery rate
  expect(receivedCount).toBeGreaterThanOrEqual(900);

  eventSource.close();
}, 15000);
```

---

### SSE-LOAD-003: Load Balancer Compatibility

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-LOAD-003 |
| **Title** | SSE Works Through Load Balancer |
| **Priority** | P1 - High |
| **Spec Reference** | Deployment requirements |

**Test Steps**:

```typescript
it('SSE connections work through load balancer', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Connect through load balancer
  const eventSource = new EventSource(
    `${LOAD_BALANCER_URL}/api/v1/process/${job.id}/events`
  );

  let connected = false;
  let eventsReceived = 0;

  eventSource.addEventListener('connected', () => {
    connected = true;
  });

  eventSource.addEventListener('progress', () => {
    eventsReceived++;
  });

  await waitFor(() => connected);

  // Publish events
  await publishProgress(job.id, { stage: 'test', percent: 50 });

  await waitFor(() => eventsReceived >= 1);

  expect(eventsReceived).toBeGreaterThanOrEqual(1);

  eventSource.close();
});
```

---

### SSE-PERF-001: Connection Establishment Time

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PERF-001 |
| **Title** | SSE Connection Establishes Within SLA |
| **Priority** | P1 - High |
| **Spec Reference** | NFR-103 |

**Test Steps**:

```typescript
it('SSE connection establishes within 1 second', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const startTime = Date.now();

  const eventSource = new EventSource(`/api/v1/process/${job.id}/events`);

  await waitFor(() => eventSource.readyState === EventSource.OPEN);

  const connectionTime = Date.now() - startTime;

  expect(connectionTime).toBeLessThan(1000);

  eventSource.close();
});
```

---

### SSE-PERF-002: Event Delivery Latency

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-PERF-002 |
| **Title** | Event Delivery Within Latency SLA |
| **Priority** | P1 - High |
| **Spec Reference** | NFR-104 |

**Test Steps**:

```typescript
it('events delivered within 100ms', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const eventSource = subscribeToJob(job.id);
  await waitFor(() => eventSource.readyState === EventSource.OPEN);

  const latencies: number[] = [];

  eventSource.addEventListener('progress', (e) => {
    const data = JSON.parse(e.data);
    const latency = Date.now() - data.publishedAt;
    latencies.push(latency);
  });

  // Publish events with timestamp
  for (let i = 0; i < 10; i++) {
    await publishProgress(job.id, {
      stage: 'test',
      percent: i * 10,
      publishedAt: Date.now(),
    });
    await sleep(100);
  }

  await waitFor(() => latencies.length >= 10);

  // P95 latency should be under 100ms
  const sorted = latencies.sort((a, b) => a - b);
  const p95 = sorted[Math.floor(sorted.length * 0.95)];

  expect(p95).toBeLessThan(100);

  eventSource.close();
});
```

---

## 19. Security Tests

### 19.1 Security Validation Tests

These tests validate security controls for SSE endpoints.

---

### SSE-SEC-001: Rate Limiting

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SEC-001 |
| **Title** | SSE Endpoint Rate Limited |
| **Priority** | P1 - High |
| **Spec Reference** | Security requirements |

**Test Steps**:

```typescript
it('rate limits excessive SSE connection attempts', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  // Attempt many rapid connections
  const responses = await Promise.all(
    Array.from({ length: 50 }, () =>
      fetch(`/api/v1/process/${job.id}/events`).then(r => r.status)
    )
  );

  // Some should be rate limited
  const rateLimited = responses.filter(s => s === 429);
  expect(rateLimited.length).toBeGreaterThan(0);
});
```

---

### SSE-SEC-002: Cross-Session Access Prevention

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SEC-002 |
| **Title** | Cannot Access Other Session's Job SSE |
| **Priority** | P0 - Critical |
| **Spec Reference** | Session isolation |

**Test Steps**:

```typescript
it('cannot access SSE for another session job', async () => {
  // Create job in session A
  const jobA = await createJob({ sessionId: 'session-a', status: 'PROCESSING' });

  // Try to access from session B
  const response = await fetch(`/api/v1/process/${jobA.id}/events`, {
    headers: {
      Cookie: 'session=session-b',
    },
  });

  expect(response.status).toBe(404);
});
```

---

### SSE-SEC-003: Event Data Sanitization

| Attribute | Value |
|-----------|-------|
| **Test ID** | SSE-SEC-003 |
| **Title** | SSE Event Data Is Sanitized |
| **Priority** | P1 - High |
| **Spec Reference** | Security requirements |

**Test Steps**:

```typescript
it('sanitizes event data to prevent injection', async () => {
  const job = await createJob({ status: 'PROCESSING' });

  const events: any[] = [];
  const eventSource = subscribeToJob(job.id);

  eventSource.addEventListener('progress', (e) => {
    events.push(JSON.parse(e.data));
  });

  // Publish event with potentially malicious content
  await publishProgress(job.id, {
    stage: 'test',
    percent: 50,
    message: '<script>alert("xss")</script>',
  });

  await waitFor(() => events.length >= 1);

  // Message should be sanitized
  expect(events[0].message).not.toContain('<script>');

  eventSource.close();
});
```

---

## 20. Test Summary

### Test Count by Category

| Category | Test Count | Status |
|----------|-----------|--------|
| SSE Connection Tests (Section 2) | 10 | Enhanced |
| Progress Event Tests (Section 3) | 8 | Complete |
| State Sync Event Tests (Section 4) | 5 | Complete |
| Cancelled Event Tests (Section 5) | 5 | Complete |
| Event Buffering Tests (Section 6) | 7 | Enhanced |
| Reconnection Tests (Section 7) | 6 | Complete |
| Polling Fallback Tests (Section 8) | 4 | Complete |
| Client-Side Hook Tests (Section 9) | 8 | Enhanced |
| Redis Pub/Sub Tests (Section 10) | 7 | Enhanced |
| Redis Circuit Breaker Tests (Section 11) | 16 | **ENHANCED** |
| Cache Invalidation Tests (Section 11.3) | 6 | **NEW** |
| Database Integration Tests (Section 12) | 11 | Complete |
| Component Integration Tests (Section 13) | 5 | Complete |
| **MCP-to-SSE Integration Tests (Section 14)** | **6** | **NEW** |
| Accessibility Tests (Section 15) | 4 | Complete |
| Job State Machine Tests (Section 16) | 5 | Complete |
| Infrastructure Health Tests (Section 17) | 6 | Complete |
| Load and Performance Tests (Section 18) | 5 | Complete |
| Security Tests (Section 19) | 3 | Complete |
| **Total** | **127** | |

### Test Count by Priority

| Priority | Count | Percentage |
|----------|-------|------------|
| P0 - Critical | 47 | 37.0% |
| P1 - High | 75 | 59.1% |
| P2 - Medium | 5 | 3.9% |
| **Total** | **127** | 100% |

### Coverage by Feature Area

| Feature Area | Tests | Coverage Status |
|--------------|-------|-----------------|
| SSE Protocol & Connection | 10 | Complete |
| Event Types (all 8 types) | 18 | Complete |
| Event Buffering & Ordering | 7 | Complete |
| Reconnection & Recovery | 11 | Complete |
| Polling Fallback | 4 | Complete |
| Client Hooks (useSSE) | 8 | Complete |
| Redis Pub/Sub Integration | 13 | Complete |
| Redis Circuit Breaker & Resilience | 16 | **ENHANCED** |
| Redis Cache Invalidation | 6 | **NEW** |
| Redis Failover & Recovery | 4 | **NEW** |
| Database-SSE Synchronization | 11 | Complete |
| Component Rendering | 5 | Complete |
| **MCP-to-SSE Integration** | **6** | **NEW** |
| Accessibility (WCAG 2.1 AA) | 4 | Complete |
| Job State Machine | 5 | Complete |
| Infrastructure/Operations | 6 | Complete |
| Performance & Load | 5 | Complete |
| Security | 3 | Complete |

### Requirements Traceability

| Requirement | Test Coverage | Tests |
|-------------|--------------|-------|
| FR-501 (Real-time Progress) | Complete | SSE-PROG-001 to SSE-PROG-008, SSE-COMP-001 |
| FR-502 (Progress Stages) | Complete | SSE-PROG-002, SSE-PROG-003 |
| FR-503 (Reconnection) | Complete | SSE-REC-001 to SSE-REC-006, SSE-SYNC-001 to SSE-SYNC-005 |
| FR-504 (Polling Fallback) | Complete | SSE-POLL-001 to SSE-POLL-004 |
| FR-406 (Cancellation) | Complete | SSE-CANCEL-001 to SSE-CANCEL-005 |
| FR-801 (Error Handling) | Complete | SSE-PROG-006, SSE-COMP-003 |
| FR-803 (Retry Logic) | Complete | SSE-PROG-007, SSE-STATE-003 |
| NFR-103 (Performance) | Complete | SSE-PERF-001, SSE-LOAD-001 |
| NFR-104 (Latency) | Complete | SSE-PERF-002, SSE-LOAD-002 |
| MAJ-UI-002 (No Backwards Progress) | Complete | SSE-PROG-004 |
| MAJ-UI-009 (No Duplicates) | Complete | SSE-REC-006, SSE-BUF-006 |
| Session Isolation | Complete | SSE-CONN-003, SSE-SEC-002 |
| WCAG 2.1 AA | Complete | SSE-A11Y-001 to SSE-A11Y-004 |

### Gap Analysis vs. Review Findings

| Review Gap | Status | Tests Added |
|------------|--------|-------------|
| state_sync Event Tests | RESOLVED | SSE-SYNC-001 to SSE-SYNC-005 |
| cancelled Event Tests | RESOLVED | SSE-CANCEL-001 to SSE-CANCEL-005 |
| Database Integration | RESOLVED | SSE-DB-001 to SSE-DB-005, SSE-TX-001 to SSE-TX-003, SSE-REFRESH-001 to SSE-REFRESH-003 |
| Redis Circuit Breaker | RESOLVED | SSE-REDIS-001 to SSE-REDIS-006 |
| **A-04: Circuit Breaker State Transitions** | **RESOLVED** | SSE-REDIS-007 to SSE-REDIS-012 (6 tests) |
| **A-04: Cache Invalidation** | **RESOLVED** | SSE-CACHE-001 to SSE-CACHE-006 (6 tests) |
| **A-04: Redis Failover & Recovery** | **RESOLVED** | SSE-REDIS-013 to SSE-REDIS-016 (4 tests) |
| Component Integration | RESOLVED | SSE-COMP-001 to SSE-COMP-005 |
| Accessibility | RESOLVED | SSE-A11Y-001 to SSE-A11Y-004 |
| Job State Machine | RESOLVED | SSE-STATE-001 to SSE-STATE-005 |
| Infrastructure Health | RESOLVED | SSE-HEALTH-001 to SSE-HEALTH-002, SSE-LOG-001, SSE-CLEAN-001 to SSE-CLEAN-003 |
| Load Testing | RESOLVED | SSE-LOAD-001 to SSE-LOAD-003 |
| Performance Metrics | RESOLVED | SSE-PERF-001, SSE-PERF-002 |
| Security Tests | RESOLVED | SSE-SEC-001 to SSE-SEC-003 |
| Route Handler Cleanup | RESOLVED | SSE-CONN-007 to SSE-CONN-010 |
| Backoff Timing Fix | RESOLVED | SSE-REC-004 (corrected to 1s base) |
| Retry Schema Fix | RESOLVED | SSE-PROG-007 (added reason, nextRetryAt) |
| MCP Architecture Docs | RESOLVED | Section 1.4 added |
| **A-09: MCP-to-SSE Integration Architecture** | **RESOLVED** | Section 1.4 enhanced with comprehensive architecture; SSE-MCP-001 to SSE-MCP-006 (6 tests) |

---

## Changelog

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0.0 | 2025-12-12 | Julia Santos | Initial SSE test cases (36 tests) |
| 2.0.0 | 2025-12-15 | Julia Santos | Comprehensive remediation based on 10-specialist review: Added 69 new tests across 9 new sections; Fixed backoff timing (SSE-REC-004); Enhanced retry schema (SSE-PROG-007); Added state_sync event type; Added MCP architecture documentation; Total tests: 105 |
| 2.1.0 | 2025-12-15 | Julia Santos | A-04 Remediation: Added 16 Redis resilience tests addressing consolidated review gaps. Circuit Breaker State Transitions (SSE-REDIS-007 to SSE-REDIS-012): Closed->Open, Open->Half-Open, Half-Open->Closed/Open transitions, failure counting, metrics/telemetry. Cache Invalidation (SSE-CACHE-001 to SSE-CACHE-006): Data update/delete invalidation, TTL expiration, manual purge, cascade invalidation, verification. Redis Failover (SSE-REDIS-013 to SSE-REDIS-016): Connection failure handling, automatic reconnection, graceful degradation to memory, data consistency after recovery. Total tests: 121 |
| 2.2.0 | 2025-12-15 | Julia Santos | A-09 Remediation: Enhanced MCP-to-SSE integration architecture documentation (Section 1.4) with comprehensive data flow diagrams, event mapping tables, error propagation patterns, and state synchronization patterns. Added Section 14 "MCP-to-SSE Integration Tests" with 6 end-to-end integration tests (SSE-MCP-001 to SSE-MCP-006): MCP progress callback mapping (SSE-MCP-001), completion events (SSE-MCP-002), error enrichment and propagation (SSE-MCP-003), timeout handling (SSE-MCP-004), checkpoint-based state synchronization (SSE-MCP-005), complete E2E flow validation (SSE-MCP-006). Tests validate critical integration points including MCP tool invocation, progress callbacks, Redis Pub/Sub publishing, SSE streaming, and client-side event consumption. Total tests: 127 (4 P0, 2 P1) |

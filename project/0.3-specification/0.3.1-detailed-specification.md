# Detailed Specification: HX Docling UI Application

**Document Type**: Detailed Technical Specification
**Version**: 1.2.1
**Status**: APPROVED
**Created**: 2025-12-11
**Last Updated**: 2025-12-12
**Author**: Alex Rivera (Platform Architect)
**Charter Reference**: `project/0.0-charter/0.1-hx-docling-ui-charter.md` v0.7.0
**Architecture Reference**: `project/0.2-architecture/0.2.1-solution-architecture.md` v2.1.0
**Agentic Patterns Reference**: `project/0.2-architecture/0.2.2-agentic-patterns.md` v2.1.0
**Target Audience**: Development Team, QA Engineers, Code Review Agents

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Functional Requirements](#2-functional-requirements)
3. [Non-Functional Requirements](#3-non-functional-requirements)
4. [API Specifications](#4-api-specifications)
5. [Data Models](#5-data-models)
6. [Component Specifications](#6-component-specifications)
7. [Integration Specifications](#7-integration-specifications)
8. [Security Specifications](#8-security-specifications)
9. [Accessibility Specifications](#9-accessibility-specifications)
10. [Testing Specifications](#10-testing-specifications)
11. [Quality Gates and Acceptance Criteria](#11-quality-gates-and-acceptance-criteria)
12. [Appendices](#12-appendices)
13. [Changelog](#13-changelog)

---

## 1. Executive Summary

### 1.1 Purpose

This document provides implementation-ready specifications for the HX Docling UI Application, translating the high-level requirements from the charter and architectural decisions from the solution architecture into concrete, testable specifications.

### 1.2 Scope

**Phase 1 Development** on hx-cc-server (192.168.10.224):
- Web-based document processing interface
- Integration with hx-docling-mcp-server (8 of 19 MCP tools)
- Persistent storage via PostgreSQL and Redis
- Real-time progress via SSE streaming
- History view with pagination

**Reference**: Charter Section 1.4, Solution Architecture Section 1.2

### 1.3 Document Conventions

| Convention | Meaning |
|------------|---------|
| **MUST** | Mandatory requirement (RFC 2119) |
| **SHOULD** | Recommended but not mandatory |
| **MAY** | Optional feature |
| `[CHARTER: X.X]` | Reference to charter section |
| `[ARCH: X.X]` | Reference to solution architecture section |
| `[PATTERN: X]` | Reference to agentic patterns document |

---

## 2. Functional Requirements

### 2.1 File Upload (FR-100 Series)

**Reference**: [CHARTER: 4.1.1], [ARCH: 5.1]

#### FR-101: Drag-and-Drop File Selection

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-101 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST accept file uploads via drag-and-drop interface |
| **Acceptance Criteria** | AC-101.1: User can drag file onto upload zone; AC-101.2: Visual feedback on drag-over; AC-101.3: File accepted on drop |
| **Component** | `UploadZone.tsx` (Client Component) |
| **Dependencies** | None |

**Implementation Notes**:
```typescript
// Required 'use client' directive
// Use react-dropzone for cross-browser compatibility
// Emit FILE_SELECTED event on successful drop
```

#### FR-102: Click-to-Browse File Selection

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-102 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST provide click-to-browse fallback for file selection |
| **Acceptance Criteria** | AC-102.1: Click on upload zone opens file browser; AC-102.2: Selected file populates upload zone |
| **Component** | `UploadZone.tsx` |
| **Dependencies** | FR-101 |

#### FR-103: File Type Validation

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-103 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST validate file type against allowed list before upload |
| **Acceptance Criteria** | AC-103.1: Accept: .pdf, .doc, .docx, .ppt, .pptx, .xls, .xlsx, .png, .jpg, .jpeg, .tiff; AC-103.2: Reject with error E002 for unsupported types |
| **Component** | `lib/validation/file.ts` |
| **Dependencies** | None |

**Validation Schema**:
```typescript
const ALLOWED_EXTENSIONS = [
  '.pdf',
  '.doc', '.docx',
  '.ppt', '.pptx',
  '.xls', '.xlsx',
  '.png', '.jpg', '.jpeg', '.tiff'
];

const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-excel',
  'image/png',
  'image/jpeg',
  'image/tiff',
];
```

#### FR-104: File Size Validation

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-104 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST enforce file size limits per document type |
| **Acceptance Criteria** | See size limits table below; AC-104.2: Reject with error E001 if exceeded |
| **Component** | `lib/validation/file.ts` |
| **Dependencies** | None |

**Size Limits** [CHARTER: 4.1.2]:

| Format | Max Size | Timeout |
|--------|----------|---------|
| PDF | 100 MB | 300s |
| Word (.doc, .docx) | 50 MB | 180s |
| Excel (.xls, .xlsx) | 50 MB | 180s |
| PowerPoint (.ppt, .pptx) | 50 MB | 180s |
| Images (.png, .jpg, .jpeg, .tiff) | 25 MB | 60s |

#### FR-105: File Preview Display

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-105 |
| **Priority** | P2 (High) |
| **Description** | System MUST display file metadata after selection |
| **Acceptance Criteria** | AC-105.1: Display file name; AC-105.2: Display file size (formatted); AC-105.3: Display file type icon |
| **Component** | `FilePreview.tsx` (Client Component) |
| **Dependencies** | FR-101 or FR-102 |

### 2.2 URL Input (FR-200 Series)

**Reference**: [CHARTER: 4.1.1], [ARCH: 5.1], [CHARTER: 11.3]

#### FR-201: URL Entry Field

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-201 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST provide text input for URL entry |
| **Acceptance Criteria** | AC-201.1: Input accepts URL strings; AC-201.2: Paste from clipboard supported; AC-201.3: Clear button provided |
| **Component** | `UrlInput.tsx` (Client Component) |
| **Dependencies** | None |

#### FR-202: URL Format Validation

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-202 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST validate URL format and protocol |
| **Acceptance Criteria** | AC-202.1: Accept http:// and https:// only; AC-202.2: Reject malformed URLs with E101; AC-202.3: Max length 2048 characters |
| **Component** | `lib/validation/url.ts` |
| **Dependencies** | None |

#### FR-203: SSRF Prevention

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-203 |
| **Priority** | P0 (Security Critical) |
| **Description** | System MUST block requests to private/internal addresses |
| **Acceptance Criteria** | AC-203.1: Block localhost/127.0.0.1; AC-203.2: Block 10.0.0.0/8; AC-203.3: Block 172.16.0.0/12; AC-203.4: Block 192.168.0.0/16; AC-203.5: Block 169.254.0.0/16; AC-203.6: Block *.hx.dev.local; AC-203.7: Return E104 for blocked URLs |
| **Component** | `lib/validation/url.ts` |
| **Dependencies** | FR-202 |

**Blocked Patterns**:
```typescript
function isURLBlocked(url: string): boolean {
  const hostname = new URL(url).hostname.toLowerCase();

  // Localhost variations
  if (hostname === 'localhost' || hostname === '127.0.0.1') return true;

  // Private IPv4 ranges (RFC 1918)
  if (/^(\d{1,3}\.){3}\d{1,3}$/.test(hostname)) {
    const [a, b] = hostname.split('.').map(Number);
    if (a === 10) return true;                        // 10.0.0.0/8
    if (a === 172 && b >= 16 && b <= 31) return true; // 172.16.0.0/12
    if (a === 192 && b === 168) return true;          // 192.168.0.0/16
    if (a === 169 && b === 254) return true;          // 169.254.0.0/16 (link-local)
  }

  // Internal HX domains
  if (hostname.endsWith('.hx.dev.local')) return true;

  return false;
}
```

#### FR-204: URL Preview

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-204 |
| **Priority** | P3 (Medium) |
| **Description** | System SHOULD display URL metadata preview before processing |
| **Acceptance Criteria** | AC-204.1: Fetch page title within 5s timeout; AC-204.2: Display domain name; AC-204.3: Graceful fallback if preview fails |
| **Component** | `UrlInput.tsx` |
| **Dependencies** | FR-201, FR-202 |

### 2.3 Input State Management (FR-300 Series)

**Reference**: [CHARTER: 6.3.1], [ARCH: 5.3]

#### FR-301: Mutual Exclusion of Inputs

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-301 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST enforce mutual exclusion between file and URL inputs |
| **Acceptance Criteria** | AC-301.1: Setting file clears URL; AC-301.2: Setting URL clears file; AC-301.3: Only one activeInput at a time |
| **Component** | `stores/documentStore.ts` |
| **Dependencies** | FR-101, FR-201 |

**Store Implementation**:
```typescript
interface DocumentState {
  file: File | null;
  url: string | null;
  activeInput: 'file' | 'url' | null;
  isProcessing: boolean;
}

const actions = {
  setFile: (file: File | null) => set({ file, url: null, activeInput: file ? 'file' : null }),
  setUrl: (url: string | null) => set({ url, file: null, activeInput: url ? 'url' : null }),
  clearInputs: () => set({ file: null, url: null, activeInput: null }),
};
```

#### FR-302: Processing Lock

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-302 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST prevent input changes during processing |
| **Acceptance Criteria** | AC-302.1: Input fields disabled when isProcessing=true; AC-302.2: Process button disabled when isProcessing=true |
| **Component** | `stores/documentStore.ts`, UI components |
| **Dependencies** | FR-301 |

### 2.4 Document Processing (FR-400 Series)

**Reference**: [CHARTER: 8.2], [ARCH: 9.1], [PATTERN: 3-5]

#### FR-401: Process Initiation

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-401 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST initiate MCP processing on user action |
| **Acceptance Criteria** | AC-401.1: Process button triggers /api/v1/process; AC-401.2: Job created in PENDING status; AC-401.3: Job transitions to PROCESSING |
| **Component** | `app/api/v1/process/route.ts` |
| **Dependencies** | FR-101 or FR-201 |

#### FR-402: MCP Tool Selection (Routing Pattern)

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-402 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST route to appropriate MCP tool based on input type |
| **Acceptance Criteria** | See routing table below |
| **Component** | `lib/mcp/router.ts` |
| **Dependencies** | FR-401 |

**Tool Routing Table** [PATTERN: 10]:

| Input | Extension/Pattern | MCP Tool | Timeout |
|-------|-------------------|----------|---------|
| File | .pdf | convert_pdf | Size-based |
| File | .doc, .docx | convert_docx | Size-based |
| File | .xls, .xlsx | convert_xlsx | Size-based |
| File | .ppt, .pptx | convert_pptx | Size-based |
| File | .png, .jpg, .jpeg, .tiff | convert_pdf (image mode) | Size-based |
| URL | http://, https:// | convert_url | 30s |

**Size-Based Timeout Logic**:
```typescript
function getTimeout(fileSize: number): number {
  if (fileSize < 10 * 1024 * 1024) return 60000;   // < 10 MB: 60s
  if (fileSize < 50 * 1024 * 1024) return 180000;  // 10-50 MB: 180s
  return 300000;                                    // 50-100 MB: 300s
}
```

#### FR-403: Conversion Execution

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-403 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST invoke MCP convert_* tool and receive DoclingDocument |
| **Acceptance Criteria** | AC-403.1: MCP initialized before tool call; AC-403.2: Tool parameters validated against schema; AC-403.3: DoclingDocument returned on success |
| **Component** | `lib/mcp/client.ts` |
| **Dependencies** | FR-402 |

#### FR-404: Export Generation (Prompt Chaining Pattern)

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-404 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST generate all export formats after conversion |
| **Acceptance Criteria** | AC-404.1: export_markdown called with DoclingDocument; AC-404.2: export_html called; AC-404.3: export_json called; AC-404.4: All exports executed (parallel with Promise.allSettled) |
| **Component** | `app/api/v1/process/route.ts` |
| **Dependencies** | FR-403 |

#### FR-405: Partial Result Handling

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-405 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST handle partial export failures gracefully |
| **Acceptance Criteria** | AC-405.1: If conversion succeeds but some exports fail, save successful exports; AC-405.2: Job status set to PARTIAL_COMPLETE; AC-405.3: UI indicates which exports failed |
| **Component** | `app/api/v1/process/route.ts`, `ResultsViewer.tsx` |
| **Dependencies** | FR-404 |

#### FR-406: Job Cancellation

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-406 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST allow users to cancel in-progress jobs |
| **Acceptance Criteria** | AC-406.1: Cancel button visible during PROCESSING state; AC-406.2: POST /api/v1/jobs/{id}/cancel sets job to CANCELLED; AC-406.3: MCP request aborted via AbortController; AC-406.4: SSE stream sends `cancelled` event; AC-406.5: Partial results cleaned up or preserved based on configuration |
| **Component** | `app/api/v1/jobs/[id]/cancel/route.ts`, `hooks/useProcess.ts` |
| **Dependencies** | FR-401, FR-501 |

**Cancellation Implementation**:
```typescript
// hooks/useProcess.ts - Cancellation support
interface UseProcessReturn {
  process: (jobId: string) => Promise<void>;
  cancel: () => void;  // Triggers cancellation
  isProcessing: boolean;
  isCancelling: boolean;  // New state
  progress: Progress | null;
  error: AppError | null;
}

// AbortController pattern for MCP requests
class MCPClient {
  private abortController: AbortController | null = null;

  async invoke(toolName: string, params: unknown): Promise<unknown> {
    this.abortController = new AbortController();

    try {
      return await this.request({
        jsonrpc: '2.0',
        method: 'tools/call',
        params: { name: toolName, arguments: params },
        id: generateId(),
      }, { signal: this.abortController.signal });
    } finally {
      this.abortController = null;
    }
  }

  abort(): void {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
}
```

**Cancellation State Transitions**:
```
PENDING -> CANCELLED (immediate)
UPLOADING -> CANCELLED (abort upload)
PROCESSING -> CANCELLED (abort MCP, cleanup partial)
RETRY_* -> CANCELLED (stop retry, cleanup partial)
```

**Cleanup Behavior**:
- `CLEANUP_ON_CANCEL=true` (default): Delete partial results, uploaded files
- `CLEANUP_ON_CANCEL=false`: Preserve partial results for inspection

### 2.5 Progress Tracking (FR-500 Series)

**Reference**: [CHARTER: 6.6], [ARCH: 9.2], [CHARTER: 6.8]

#### FR-501: SSE Connection Establishment

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-501 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST establish SSE connection for progress updates |
| **Acceptance Criteria** | AC-501.1: EventSource connects to /api/v1/process/{jobId}/events; AC-501.2: Connection confirmed within 500ms; AC-501.3: Connection status indicator shown |
| **Component** | `hooks/useSSE.ts` (Client Component) |
| **Dependencies** | FR-401 |

#### FR-502: Progress Event Handling

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-502 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST process and display progress events |
| **Acceptance Criteria** | AC-502.1: Parse event data (stage, percent, message); AC-502.2: Update ProgressCard component; AC-502.3: Never show backwards progress |
| **Component** | `hooks/useSSE.ts`, `ProgressCard.tsx` |
| **Dependencies** | FR-501 |

**Progress Stages** [CHARTER: 6.6]:

| Stage | Percent Range | Message |
|-------|---------------|---------|
| upload | 0-10% | "Uploading document..." |
| parsing | 10-40% | "Analyzing document structure..." |
| conversion | 40-80% | "Processing with AI..." |
| export | 80-95% | "Generating outputs..." |
| saving | 95-99% | "Saving results..." |
| complete | 100% | "Complete!" |

#### FR-503: SSE Reconnection

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-503 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST automatically reconnect on SSE disconnection |
| **Acceptance Criteria** | AC-503.1: Max 10 retry attempts; AC-503.2: Exponential backoff (1s, 2s, 4s, 8s, 16s, 30s max); AC-503.3: Last-Event-ID header sent on reconnect; AC-503.4: UI shows "Reconnecting..." during attempts |
| **Component** | `hooks/useSSE.ts`, `lib/sse/manager.ts` |
| **Dependencies** | FR-501 |

**Reconnection Configuration** [CHARTER: 6.8]:
```typescript
const SSE_CONFIG = {
  maxRetries: 10,
  backoffBase: 1000,      // 1 second
  backoffMax: 30000,      // 30 seconds
  backoffMultiplier: 2,
  gracePeriod: 30000,     // Total grace period
  pollingInterval: 2000,  // Fallback polling
};
```

#### FR-504: Polling Fallback

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-504 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST fall back to polling if SSE unavailable |
| **Acceptance Criteria** | AC-504.1: Detect SSE unavailability; AC-504.2: Switch to 2s polling interval; AC-504.3: UI shows "Using backup connection" |
| **Component** | `hooks/useSSE.ts` |
| **Dependencies** | FR-503 |

### 2.6 Results Display (FR-600 Series)

**Reference**: [CHARTER: 4.1.3], [CHARTER: 6.3.2], [ARCH: 5.1]

#### FR-601: Tabbed Results Viewer

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-601 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display results in tabbed interface |
| **Acceptance Criteria** | AC-601.1: Four tabs: Markdown, HTML, JSON, Raw; AC-601.2: Default tab: Markdown; AC-601.3: Tab order fixed, not reorderable; AC-601.4: Last selected tab remembered in session |
| **Component** | `ResultsViewer.tsx` (Client Component) |
| **Dependencies** | FR-404 |

#### FR-602: Markdown Rendering

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-602 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST render Markdown content as formatted HTML |
| **Acceptance Criteria** | AC-602.1: GFM syntax supported; AC-602.2: Code blocks with syntax highlighting; AC-602.3: Tables rendered; AC-602.4: Images rendered (base64 data URIs) |
| **Component** | `MarkdownView.tsx` (Server Component) |
| **Dependencies** | FR-601 |

#### FR-603: HTML Preview

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-603 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display HTML output in sandboxed iframe |
| **Acceptance Criteria** | AC-603.1: HTML rendered in iframe; AC-603.2: sandbox attribute applied; AC-603.3: Scrollable container |
| **Component** | `HtmlView.tsx` (Server Component) |
| **Dependencies** | FR-601 |

#### FR-604: JSON Display

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-604 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display JSON with syntax highlighting |
| **Acceptance Criteria** | AC-604.1: Pretty-printed (2-space indent); AC-604.2: Syntax highlighting; AC-604.3: Collapsible nodes (optional enhancement) |
| **Component** | `JsonView.tsx` (Server Component) |
| **Dependencies** | FR-601 |

#### FR-605: Raw DoclingDocument Display

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-605 |
| **Priority** | P2 (High) |
| **Description** | System MUST display raw MCP response for debugging |
| **Acceptance Criteria** | AC-605.1: Full DoclingDocument JSON displayed; AC-605.2: Pretty-printed; AC-605.3: Copy-to-clipboard button |
| **Component** | `RawView.tsx` (Server Component) |
| **Dependencies** | FR-601 |

#### FR-606: Download Functionality

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-606 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST enable download of results in selected format |
| **Acceptance Criteria** | AC-606.1: Download button per format; AC-606.2: File naming: {filename}_{timestamp}_{format}.{ext}; AC-606.3: Browser download dialog triggered |
| **Component** | `DownloadButton.tsx` (Client Component) |
| **Dependencies** | FR-601 |

**Download Naming Convention** [CHARTER: 4.1.3]:
```typescript
function generateDownloadFilename(
  originalName: string,
  format: 'markdown' | 'html' | 'json' | 'raw'
): string {
  const baseName = originalName.replace(/\.[^/.]+$/, '');
  const timestamp = format(new Date(), 'yyyyMMdd_HHmmss');
  const ext = format === 'markdown' ? 'md' : format === 'raw' ? 'json' : format;
  return `${baseName}_${timestamp}_${format}.${ext}`;
}
```

### 2.7 History View (FR-700 Series)

**Reference**: [CHARTER: 4.1.1], [CHARTER: 7.6.1]

#### FR-701: History Page

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-701 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display past processing jobs |
| **Acceptance Criteria** | AC-701.1: Table view with columns: File/URL, Status, Date, Actions; AC-701.2: Jobs filtered by current session; AC-701.3: Sorted by createdAt DESC |
| **Component** | `HistoryView.tsx` (Server Component) |
| **Dependencies** | None |

#### FR-702: Pagination

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-702 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST paginate history results |
| **Acceptance Criteria** | AC-702.1: Default page size 20; AC-702.2: Max page size 50; AC-702.3: Page navigation controls; AC-702.4: Total count displayed |
| **Component** | `Pagination.tsx` (Server Component), `/api/v1/history` |
| **Dependencies** | FR-701 |

**Pagination Query** [CHARTER: 7.6.1]:
```typescript
interface HistoryQuery {
  page: number;        // Default: 1
  pageSize: number;    // Default: 20, Max: 50
  sortBy: 'createdAt' | 'status';
  sortOrder: 'asc' | 'desc';
}

interface HistoryResponse {
  jobs: JobSummary[];  // Without full result content
  pagination: {
    page: number;
    pageSize: number;
    totalPages: number;
    totalCount: number;
    hasMore: boolean;
  };
}
```

#### FR-703: Job Detail View

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-703 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display full job details on selection |
| **Acceptance Criteria** | AC-703.1: Modal or dedicated view; AC-703.2: Show all result formats; AC-703.3: Download buttons available |
| **Component** | `JobDetail.tsx` (Client Component) |
| **Dependencies** | FR-701 |

#### FR-704: Re-Download Past Results

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-704 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST enable re-download of past job results |
| **Acceptance Criteria** | AC-704.1: Results retrievable by job ID; AC-704.2: All formats available for download; AC-704.3: Returns 404 if job not found or expired |
| **Component** | `/api/v1/jobs/[id]/route.ts` |
| **Dependencies** | FR-703 |

### 2.8 Error Handling (FR-800 Series)

**Reference**: [CHARTER: 8.6], [CHARTER: Appendix A], [PATTERN: 6]

#### FR-801: Error Display

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-801 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST display structured error information |
| **Acceptance Criteria** | AC-801.1: Error code displayed; AC-801.2: User-friendly message displayed; AC-801.3: Suggested action displayed |
| **Component** | `ErrorDisplay.tsx` (Client Component) |
| **Dependencies** | None |

#### FR-802: Error Recovery Actions

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-802 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST provide recovery actions based on error type |
| **Acceptance Criteria** | AC-802.1: Retryable errors show "Retry" button; AC-802.2: File errors show "Try Different File" button; AC-802.3: All errors show "Cancel" option |
| **Component** | `ErrorRecovery.tsx` (Client Component) |
| **Dependencies** | FR-801 |

#### FR-803: Automatic Retry

| Aspect | Specification |
|--------|---------------|
| **ID** | FR-803 |
| **Priority** | P1 (Critical) |
| **Description** | System MUST automatically retry transient errors |
| **Acceptance Criteria** | AC-803.1: Max 3 retry attempts; AC-803.2: Exponential backoff (1s, 2s, 4s); AC-803.3: Job status reflects retry state (RETRY_1, RETRY_2, RETRY_3) |
| **Component** | `lib/mcp/recovery.ts` |
| **Dependencies** | None |

**Job State Transitions for RETRY (MAJ-15)**:

| Current State | Error | Next State | SSE Event | Timing |
|--------------|-------|------------|-----------|--------|
| PROCESSING | Transient | RETRY_1 | `retry` | Immediate |
| RETRY_1 | Transient | RETRY_2 | `retry` | After 1s backoff |
| RETRY_2 | Transient | RETRY_3 | `retry` | After 2s backoff |
| RETRY_3 | Transient | ERROR | `error` | After 4s backoff |
| Any RETRY_* | Non-transient | ERROR | `error` | Immediate |
| Any RETRY_* | Success | PROCESSING | `progress` | Continue from checkpoint |

**Retry SSE Event Format**:
```typescript
// Event: retry
{
  "attempt": 1,           // Current retry attempt (1, 2, or 3)
  "maxRetries": 3,        // Maximum retry attempts allowed
  "nextRetryMs": 1000,    // Time until next retry (ms)
  "reason": "Connection timeout",  // Why retry is needed
  "stage": "conversion",  // Stage where error occurred
}
```

**Retry Implementation**:
```typescript
// lib/mcp/recovery.ts

const RETRY_CONFIG = {
  maxRetries: 3,              // 3 retries after initial attempt (4 total)
  backoffMs: [1000, 2000, 4000], // Delays before RETRY_1, RETRY_2, RETRY_3
};

async function executeWithRetry<T>(
  operation: () => Promise<T>,
  jobId: string,
  context: RetryContext
): Promise<T> {
  // Initial attempt (PROCESSING state)
  try {
    return await operation();
  } catch (error) {
    if (!isRetryable(error)) {
      throw error;
    }

    // Begin retry sequence
    let lastError: unknown = error;

    for (let retry = 0; retry < RETRY_CONFIG.maxRetries; retry++) {
      const backoffMs = RETRY_CONFIG.backoffMs[retry];
      const retryState = `RETRY_${retry + 1}` as JobStatus;  // RETRY_1, RETRY_2, RETRY_3

      // Update job status BEFORE waiting
      await prisma.job.update({
        where: { id: jobId },
        data: { status: retryState, retryCount: retry + 1 },
      });

      // Publish retry event
      await publishProgress(jobId, {
        type: 'retry',
        attempt: retry + 1,
        maxRetries: RETRY_CONFIG.maxRetries,
        nextRetryMs: backoffMs,
        reason: (lastError as Error).message,
      });

      // Wait before retrying
      await sleep(backoffMs);

      try {
        return await operation();
      } catch (retryError) {
        lastError = retryError;

        if (!isRetryable(retryError)) {
          throw retryError;
        }
        // Continue to next retry if available
      }
    }

    // All retries exhausted
    throw lastError;
  }
}
```

**Error Categories** [CHARTER: Appendix A]:

| Category | Code Range | Retryable | Example |
|----------|------------|-----------|---------|
| File Errors | E0xx | Varies | E001 (too large), E002 (unsupported) |
| URL Errors | E1xx | Varies | E101 (invalid), E104 (blocked) |
| MCP Errors | E2xx | Yes | E201 (unavailable), E202 (timeout) |
| Processing Errors | E3xx | Yes | E301 (timeout), E302 (conversion failed) |
| Database Errors | E4xx | Yes | E401 (connection), E403 (write failed) |
| Session Errors | E5xx | No | E501 (expired), E502 (invalid) |
| Rate Limiting | E6xx | Yes (delayed) | E601 (limit exceeded) |

---

## 3. Non-Functional Requirements

### 3.1 Performance Requirements (NFR-100 Series)

**Reference**: [CHARTER: 5.2], [CHARTER: 13.4]

#### NFR-101: Page Load Performance

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-101 |
| **Metric** | Largest Contentful Paint (LCP) |
| **Target** | < 2.5 seconds |
| **Measurement** | Lighthouse audit, broadband connection |
| **Conditions** | Initial page load, cache cleared |

#### NFR-102: First Contentful Paint

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-102 |
| **Metric** | First Contentful Paint (FCP) |
| **Target** | < 1.8 seconds |
| **Measurement** | Lighthouse audit |
| **Conditions** | Initial page load |

#### NFR-103: Time to First Progress

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-103 |
| **Metric** | Time from submit to first SSE event |
| **Target** | < 500ms |
| **Measurement** | Performance timing API |
| **Conditions** | Small file (< 1MB) |

#### NFR-104: SSE Reconnection Time

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-104 |
| **Metric** | Time to successful reconnection |
| **Target** | < 30 seconds |
| **Measurement** | Network simulation |
| **Conditions** | After network interruption |

#### NFR-105: Client Bundle Size

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-105 |
| **Metric** | Initial JavaScript bundle |
| **Target** | < 100 KB (excluding React runtime) |
| **Measurement** | Build output analysis |
| **Conditions** | Production build |

### 3.2 Reliability Requirements (NFR-200 Series)

**Reference**: [CHARTER: 5.3]

#### NFR-201: SSE Resilience

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-201 |
| **Metric** | Processing completion after network interruption |
| **Target** | 100% (within grace period) |
| **Measurement** | Resilience test |
| **Conditions** | 30-second network drop during processing |

#### NFR-202: Partial Result Availability

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-202 |
| **Metric** | Successful exports displayed when some fail |
| **Target** | 100% |
| **Measurement** | Fault injection test |
| **Conditions** | Export_html fails, others succeed |

#### NFR-203: Session Recovery

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-203 |
| **Metric** | Processing continues after browser refresh |
| **Target** | 100% |
| **Measurement** | State recovery test |
| **Conditions** | Refresh during PROCESSING state |

### 3.3 Scalability Requirements (NFR-300 Series)

**Reference**: [CHARTER: 8.1.1], [ARCH: 12]

#### NFR-301: Concurrent Users

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-301 |
| **Metric** | Concurrent active sessions |
| **Target** | 10 users |
| **Measurement** | Load test |
| **Conditions** | Phase 1 development server |

#### NFR-302: Rate Limiting Effectiveness

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-302 |
| **Metric** | Rate limit enforcement accuracy |
| **Target** | 100% |
| **Measurement** | Integration test |
| **Conditions** | 10 req/min per session limit |

### 3.4 Security Requirements (NFR-400 Series)

**Reference**: [CHARTER: 11], [ARCH: 10]

#### NFR-401: Input Validation Coverage

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-401 |
| **Metric** | Server-side validation on all inputs |
| **Target** | 100% |
| **Measurement** | Code review, security audit |
| **Conditions** | All API routes |

#### NFR-402: SSRF Prevention

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-402 |
| **Metric** | Blocked private IP requests |
| **Target** | 100% |
| **Measurement** | Security test |
| **Conditions** | All RFC 1918 ranges, localhost |

#### NFR-403: SQL Injection Prevention

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-403 |
| **Metric** | Parameterized queries |
| **Target** | 100% |
| **Measurement** | Code review |
| **Conditions** | All database operations via Prisma |

### 3.5 Accessibility Requirements (NFR-500 Series)

**Reference**: [CHARTER: 10.1], [ARCH: 5.2.2]

#### NFR-501: WCAG Compliance Level

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-501 |
| **Metric** | WCAG 2.1 Level AA compliance |
| **Target** | 100% |
| **Measurement** | axe-core audit, manual testing |
| **Conditions** | All interactive components |

#### NFR-502: Lighthouse Accessibility Score

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-502 |
| **Metric** | Lighthouse accessibility score |
| **Target** | >= 90 |
| **Measurement** | Lighthouse audit |
| **Conditions** | All pages |

#### NFR-503: Color Contrast

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-503 |
| **Metric** | Color contrast ratio |
| **Target** | >= 4.5:1 (text), >= 3:1 (UI components) |
| **Measurement** | WebAIM Contrast Checker |
| **Conditions** | All foreground/background combinations |

### 3.6 Maintainability Requirements (NFR-600 Series)

**Reference**: [CHARTER: 13.1]

#### NFR-601: TypeScript Coverage

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-601 |
| **Metric** | TypeScript compilation errors |
| **Target** | 0 |
| **Measurement** | `tsc --noEmit` |
| **Conditions** | All source files |

#### NFR-602: ESLint Compliance

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-602 |
| **Metric** | ESLint errors |
| **Target** | 0 |
| **Measurement** | `eslint` |
| **Conditions** | All source files |

#### NFR-603: Test Coverage

| Aspect | Specification |
|--------|---------------|
| **ID** | NFR-603 |
| **Metric** | Unit test line coverage |
| **Target** | >= 80% |
| **Measurement** | Vitest coverage |
| **Conditions** | All source files |

---

## 4. API Specifications

### 4.1 API Overview

**Base Path**: `/api/v1`
**Protocol**: HTTP/1.1, SSE for streaming
**Content-Type**: `application/json` (requests), `text/event-stream` (SSE)
**Reference**: [ARCH: 5.1], [CHARTER: 8.1]

### 4.2 Upload Endpoint

#### POST /api/v1/upload

**Purpose**: Upload file or register URL for processing

**Request (File Upload)**:
```http
POST /api/v1/upload HTTP/1.1
Content-Type: multipart/form-data

------boundary
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary content]
------boundary--
```

**Request (URL)**:
```http
POST /api/v1/upload HTTP/1.1
Content-Type: application/json

{
  "url": "https://example.com/document.html"
}
```

**Response (201 Created)**:
```http
HTTP/1.1 201 Created
Location: /api/v1/jobs/{jobId}
X-Request-ID: uuid-v4
Content-Type: application/json

{
  "jobId": "uuid-v4",
  "fileId": "uuid-v4",
  "fileName": "document.pdf",
  "fileSize": 1048576,
  "mimeType": "application/pdf",
  "status": "PENDING"
}
```

**Required Headers (MAJ-05, MAJ-19)**:
- `Location`: URL to the created job resource (per RFC 7231)
- `X-Request-ID`: Unique request identifier for tracing

**Error Responses**:

| Status | Code | Description |
|--------|------|-------------|
| 400 | E001 | File too large |
| 400 | E002 | Unsupported file type |
| 400 | E101 | Invalid URL |
| 400 | E104 | URL blocked (SSRF) |
| 413 | E001 | Payload too large |
| 429 | E601 | Rate limit exceeded |
| 500 | E401 | Database error |

### 4.3 Process Endpoint

#### POST /api/v1/process

**Purpose**: Initiate document processing

**Request**:
```http
POST /api/v1/process HTTP/1.1
Content-Type: application/json

{
  "jobId": "uuid-v4"
}
```

**Response (202 Accepted)**:
```json
{
  "jobId": "uuid-v4",
  "status": "PROCESSING",
  "streamUrl": "/api/v1/process/{jobId}/events"
}
```

**Error Responses**:

| Status | Code | Description |
|--------|------|-------------|
| 404 | E501 | Job not found |
| 409 | E701 | Job already processing (state conflict) |
| 429 | E601 | Rate limit exceeded |

### 4.3.1 Cancel Endpoint

#### POST /api/v1/jobs/{id}/cancel

**Purpose**: Cancel an in-progress job

**Request**:
```http
POST /api/v1/jobs/{id}/cancel HTTP/1.1
Content-Type: application/json

{
  "preservePartialResults": false
}
```

**Response (200 OK)**:
```json
{
  "jobId": "uuid-v4",
  "status": "CANCELLED",
  "cancelledAt": "2025-12-11T14:30:00Z",
  "partialResultsPreserved": false,
  "message": "Job cancelled successfully"
}
```

**Error Responses**:

| Status | Code | Description |
|--------|------|-------------|
| 404 | E501 | Job not found |
| 409 | E702 | Job not cancellable (already COMPLETE, ERROR, or CANCELLED) |
| 429 | E601 | Rate limit exceeded |

**Cancellation Behavior**:
1. If job is PENDING: Immediate transition to CANCELLED
2. If job is UPLOADING: Abort upload, cleanup temporary file
3. If job is PROCESSING: Signal MCP abort via AbortController, cleanup partial
4. If job is RETRY_*: Stop retry loop, transition to CANCELLED

### 4.4 SSE Events Endpoint

#### GET /api/v1/process/{jobId}/events

**Purpose**: Subscribe to processing progress events

**Request**:
```http
GET /api/v1/process/{jobId}/events HTTP/1.1
Accept: text/event-stream
Last-Event-ID: {optional-reconnect-id}
```

**Response (200 OK)**:
```http
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive

event: connected
data: {"connectionId": "uuid"}

event: progress
id: evt-1
data: {"stage": "parsing", "percent": 25, "message": "Analyzing document structure..."}

event: progress
id: evt-2
data: {"stage": "conversion", "percent": 60, "message": "Processing with AI..."}

event: complete
id: evt-3
data: {"jobId": "uuid", "status": "COMPLETE", "formats": ["markdown", "html", "json"]}
```

**Event Types**:

| Event | Purpose | Data Schema |
|-------|---------|-------------|
| connected | Connection established | `{ connectionId: string }` |
| progress | Processing update | `{ stage: string, percent: number, message: string }` |
| state_sync | Reconnection sync | `{ stage: string, percent: number, message: string, jobStatus: string }` |
| retry | Retry initiated | `{ attempt: number, maxAttempts: number, nextRetryMs: number, reason: string }` |
| complete | Processing finished | `{ jobId: string, status: string, formats: string[] }` |
| cancelled | Job cancelled | `{ jobId: string, cancelledAt: string, partialResultsPreserved: boolean }` |
| error | Processing failed | `{ code: string, message: string, retryable: boolean }` |

#### 4.4.1 SSE Event ID Format (CRI-09)

**Event ID Format**: `{jobId}-{timestamp}-{sequence}`

| Component | Format | Example |
|-----------|--------|---------|
| jobId | First 8 chars of UUID | `a1b2c3d4` |
| timestamp | Unix timestamp (seconds) | `1702311000` |
| sequence | Zero-padded 4-digit counter | `0001` |

**Example Event ID**: `a1b2c3d4-1702311000-0001`

**Server-Side Event Buffering**:
```typescript
// lib/sse/buffer.ts

interface EventBuffer {
  maxEvents: number;      // 100 events per job
  retentionMs: number;    // 5 minutes (300000ms)
}

const EVENT_BUFFER_CONFIG: EventBuffer = {
  maxEvents: 100,
  retentionMs: 300000,
};

interface BufferedEvent {
  id: string;
  event: string;
  data: string;
  timestamp: number;
}

// Redis-backed event buffer
const EVENT_BUFFER_KEY = (jobId: string) => `hx-docling:events:${jobId}`;

export async function bufferEvent(
  jobId: string,
  event: string,
  data: unknown,
  sequence: number
): Promise<string> {
  const timestamp = Math.floor(Date.now() / 1000);
  const eventId = `${jobId.substring(0, 8)}-${timestamp}-${sequence.toString().padStart(4, '0')}`;

  const bufferedEvent: BufferedEvent = {
    id: eventId,
    event,
    data: JSON.stringify(data),
    timestamp,
  };

  const key = EVENT_BUFFER_KEY(jobId);

  // Add to sorted set with timestamp as score
  await redis.zadd(key, timestamp, JSON.stringify(bufferedEvent));

  // Trim to maxEvents: remove any events beyond maxEvents (keep only newest maxEvents)
  // After ZADD, use ZCARD to get count, then remove excess events
  const currentCount = await redis.zcard(key);
  if (currentCount > EVENT_BUFFER_CONFIG.maxEvents) {
    // Remove oldest events, keeping only the newest maxEvents
    const excessCount = currentCount - EVENT_BUFFER_CONFIG.maxEvents;
    await redis.zremrangebyrank(key, 0, excessCount - 1);
  }

  // Set expiry
  await redis.expire(key, EVENT_BUFFER_CONFIG.retentionMs / 1000);

  return eventId;
}

export async function getEventsSince(
  jobId: string,
  lastEventId: string | null
): Promise<BufferedEvent[]> {
  const key = EVENT_BUFFER_KEY(jobId);

  if (!lastEventId) {
    // Return all buffered events
    const events = await redis.zrange(key, 0, -1);
    return events.map(e => JSON.parse(e));
  }

  // Parse lastEventId to get timestamp
  const [, timestampStr] = lastEventId.split('-');
  const timestamp = parseInt(timestampStr, 10);

  // Get events after the timestamp
  const events = await redis.zrangebyscore(key, `(${timestamp}`, '+inf');
  return events.map(e => JSON.parse(e));
}
```

**Client-Side Reconnection**:
```typescript
// hooks/useSSE.ts - Reconnection handling

function handleReconnection(lastEventId: string | null) {
  // Build URL with query param for Last-Event-ID (EventSource doesn't support headers)
  const url = new URL(`/api/v1/process/${jobId}/events`, window.location.origin);
  if (lastEventId) {
    url.searchParams.set('lastEventId', lastEventId);
  }

  const eventSource = new EventSource(url.toString());

  // Deduplication via Set
  const processedEventIds = new Set<string>();

  eventSource.onmessage = (event) => {
    // Skip duplicate events
    if (processedEventIds.has(event.lastEventId)) {
      return;
    }
    processedEventIds.add(event.lastEventId);

    // Process event
    handleEvent(event);
  };

  // Handle state_sync on reconnection
  eventSource.addEventListener('state_sync', (event) => {
    const state = JSON.parse(event.data);
    // Full state restoration
    updateProgress(state);
    setJobStatus(state.jobStatus);
  });
}
```

**Behavior When Buffer Exhausted**:
1. If requested `Last-Event-ID` is older than buffer retention, send `state_sync` event with current full state
2. Log warning for monitoring
3. Continue with new events from current state

### 4.5 History Endpoint

#### GET /api/v1/history

**Purpose**: Retrieve paginated job history

**Request**:
```http
GET /api/v1/history?page=1&pageSize=20&sortBy=createdAt&sortOrder=desc HTTP/1.1
Cookie: session={sessionId}
```

**Query Parameters**:

| Parameter | Type | Default | Constraints | Description |
|-----------|------|---------|-------------|-------------|
| page | integer | 1 | >= 1 | Page number |
| pageSize | integer | 20 | 1-50 | Items per page |
| sortBy | string | createdAt | `createdAt`, `status` | Sort field |
| sortOrder | string | desc | `asc`, `desc` | Sort direction |

**Pagination Validation (MAJ-21)**:
```typescript
const paginationSchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  pageSize: z.coerce.number().int().min(1).max(50).default(20),
  sortBy: z.enum(['createdAt', 'status']).default('createdAt'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
});

// Error response for invalid pagination
// 400 Bad Request with code E801 (pagination_invalid)
```

**Status Sort Order (MAJ-07)**:
When `sortBy=status`, the sort order is defined as:
1. PROCESSING (highest priority - active jobs first)
2. PENDING
3. UPLOADING
4. RETRY_1, RETRY_2, RETRY_3
5. COMPLETE
6. PARTIAL_COMPLETE
7. CANCELLED
8. ERROR (lowest priority)

```typescript
const STATUS_SORT_ORDER: Record<JobStatus, number> = {
  PROCESSING: 1,
  PENDING: 2,
  UPLOADING: 3,
  RETRY_1: 4,
  RETRY_2: 5,
  RETRY_3: 6,
  COMPLETE: 7,
  PARTIAL_COMPLETE: 8,
  CANCELLED: 9,
  ERROR: 10,
};
```

**Response (200 OK)**:
```json
{
  "jobs": [
    {
      "id": "uuid-v4",
      "status": "COMPLETE",
      "inputType": "FILE",
      "fileName": "document.pdf",
      "fileSize": 1048576,
      "createdAt": "2025-12-11T14:30:00Z",
      "completedAt": "2025-12-11T14:30:45Z",
      "formats": ["MARKDOWN", "HTML", "JSON"]
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "totalPages": 5,
    "totalCount": 100,
    "hasMore": true
  }
}
```

### 4.6 Job Detail Endpoint

#### GET /api/v1/jobs/{id}

**Purpose**: Retrieve full job details with results

**Response (200 OK)**:
```json
{
  "id": "uuid-v4",
  "sessionId": "uuid-v4",
  "status": "COMPLETE",
  "inputType": "FILE",
  "fileName": "document.pdf",
  "fileSize": 1048576,
  "mimeType": "application/pdf",
  "createdAt": "2025-12-11T14:30:00Z",
  "completedAt": "2025-12-11T14:30:45Z",
  "results": [
    {
      "format": "MARKDOWN",
      "content": "# Document Title\n\nContent...",
      "size": 2048
    },
    {
      "format": "HTML",
      "content": "<h1>Document Title</h1><p>Content...</p>",
      "size": 3072
    },
    {
      "format": "JSON",
      "content": "{\"title\": \"Document Title\", ...}",
      "size": 4096
    }
  ]
}
```

### 4.7 Health Endpoint

#### GET /api/v1/health

**Purpose**: System health check

**Reference**: [CHARTER: 8.7]

**Response (200 OK)**:
```json
{
  "status": "healthy",
  "timestamp": "2025-12-11T14:30:00Z",
  "version": "1.0.0",
  "uptime": 86400,
  "checks": {
    "mcp": {
      "status": "ok",
      "latency": 45,
      "lastCheck": "2025-12-11T14:30:00Z"
    },
    "postgres": {
      "status": "ok",
      "latency": 12,
      "lastCheck": "2025-12-11T14:30:00Z"
    },
    "redis": {
      "status": "ok",
      "latency": 5,
      "lastCheck": "2025-12-11T14:30:00Z"
    },
    "fileStorage": {
      "status": "ok",
      "latency": 2,
      "lastCheck": "2025-12-11T14:30:00Z"
    }
  }
}
```

**Status Codes**:

| Status | Meaning |
|--------|---------|
| 200 | healthy or degraded |
| 503 | unhealthy |

**Status Logic**:
- `healthy`: All checks pass
- `degraded`: Non-critical check fails (fileStorage)
- `unhealthy`: Critical check fails (mcp, postgres, redis)

### 4.8 API Request/Response Conventions (MAJ-API-001)

**Purpose**: Define consistent API patterns for requests, responses, headers, and error handling.

#### Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| `Content-Type` | Yes (POST/PUT) | Must be `application/json` or `multipart/form-data` |
| `Accept` | No | Response format, default `application/json` |
| `X-Request-ID` | No | Client-provided request correlation ID |
| `Cookie` | Yes | Session cookie for authentication |

#### Response Headers

| Header | Always | Description |
|--------|--------|-------------|
| `Content-Type` | Yes | `application/json` for all API responses |
| `X-Request-ID` | Yes | Echo client ID or generate UUID |
| `X-RateLimit-*` | Yes | Rate limiting headers (per RFC 9238) |
| `Cache-Control` | Yes | Caching directives |
| `ETag` | Conditional | For cacheable resources |

#### Standard Response Envelope

```typescript
// Success response
interface ApiSuccessResponse<T> {
  data: T;
  meta?: {
    pagination?: PaginationMeta;
    timing?: { durationMs: number };
  };
}

// Error response
interface ApiErrorResponse {
  error: {
    code: string;           // App error code (E001, E102, etc.)
    message: string;        // Developer-friendly message
    userMessage: string;    // User-friendly message
    retryable: boolean;
    retryAfter?: number;    // Seconds until retry allowed
    details?: Record<string, unknown>;
  };
}
```

### 4.9 API Versioning Strategy (MAJ-API-002)

**Purpose**: Define versioning strategy for future API evolution.

**Current Version**: v1

**URL Pattern**: `/api/v{version}/{resource}`

**Versioning Rules**:
1. **Major version in URL**: Breaking changes increment version (v1 -> v2)
2. **Minor changes additive**: New fields, endpoints added without version change
3. **Deprecation policy**: 6 months notice before v1 retirement

**Version Header** (Future):
```
API-Version: 2024-12-01  // Date-based versioning alternative
```

**Response Version Header**:
```
X-API-Version: v1
X-API-Deprecation: 2025-06-01  // When applicable
```

### 4.10 Content Negotiation (MAJ-API-003)

**Purpose**: Define how clients can request different response formats.

**Supported Accept Headers**:

| Accept Header | Response Format |
|---------------|-----------------|
| `application/json` (default) | JSON response |
| `text/plain` | Plain text (for result content) |
| `text/markdown` | Markdown (for markdown results) |
| `text/html` | HTML (for html results) |

**Download Endpoint Content Negotiation**:

```typescript
// GET /api/v1/jobs/{id}/download?format=markdown

// Accept header determines response type
// Accept: application/json -> JSON with content field
// Accept: text/markdown -> Raw markdown content

export async function GET(request: NextRequest) {
  const accept = request.headers.get('Accept') || 'application/json';
  const format = request.nextUrl.searchParams.get('format') || 'markdown';

  const result = await getResult(jobId, format);

  if (accept === 'application/json') {
    return NextResponse.json({
      data: {
        format,
        content: result.content,
        size: result.size,
      },
    });
  }

  // Return raw content with appropriate Content-Type
  const contentTypes: Record<string, string> = {
    markdown: 'text/markdown; charset=utf-8',
    html: 'text/html; charset=utf-8',
    json: 'application/json; charset=utf-8',
  };

  return new Response(result.content, {
    headers: {
      'Content-Type': contentTypes[format] || 'text/plain',
      'Content-Disposition': `attachment; filename="${fileName}.${format}"`,
    },
  });
}
```

### 4.11 Request Validation Middleware (MAJ-API-004)

**Purpose**: Centralized request validation for all API routes.

```typescript
// lib/middleware/validate.ts

import { NextRequest, NextResponse } from 'next/server';
import { z, ZodSchema } from 'zod';

interface ValidationConfig {
  body?: ZodSchema;
  query?: ZodSchema;
  params?: ZodSchema;
}

export function withValidation(
  config: ValidationConfig,
  handler: (
    request: NextRequest,
    context: { params: Record<string, string> }
  ) => Promise<Response>
) {
  return async (
    request: NextRequest,
    context: { params: Record<string, string> }
  ) => {
    // Validate params
    if (config.params) {
      const result = config.params.safeParse(context.params);
      if (!result.success) {
        return NextResponse.json(
          {
            error: {
              code: 'E100',
              message: 'Invalid path parameters',
              userMessage: 'Invalid request',
              retryable: false,
              details: { errors: result.error.flatten() },
            },
          },
          { status: 400 }
        );
      }
    }

    // Validate query parameters
    if (config.query) {
      const params = Object.fromEntries(request.nextUrl.searchParams);
      const result = config.query.safeParse(params);
      if (!result.success) {
        return NextResponse.json(
          {
            error: {
              code: 'E100',
              message: 'Invalid query parameters',
              userMessage: 'Invalid request parameters',
              retryable: false,
              details: { errors: result.error.flatten() },
            },
          },
          { status: 400 }
        );
      }
    }

    // Validate body
    if (config.body && request.method !== 'GET') {
      try {
        const body = await request.json();
        const result = config.body.safeParse(body);
        if (!result.success) {
          return NextResponse.json(
            {
              error: {
                code: 'E100',
                message: 'Invalid request body',
                userMessage: 'Please check your input',
                retryable: false,
                details: { errors: result.error.flatten() },
              },
            },
            { status: 400 }
          );
        }
      } catch {
        return NextResponse.json(
          {
            error: {
              code: 'E100',
              message: 'Invalid JSON body',
              userMessage: 'Invalid request format',
              retryable: false,
            },
          },
          { status: 400 }
        );
      }
    }

    return handler(request, context);
  };
}
```

### 4.12 Idempotency Support (MAJ-API-005)

**Purpose**: Enable safe request retries for non-idempotent operations.

```typescript
// lib/middleware/idempotency.ts

const IDEMPOTENCY_TTL_SECONDS = 3600; // 1 hour

interface IdempotencyRecord {
  status: 'processing' | 'completed';
  response?: {
    status: number;
    body: unknown;
    headers: Record<string, string>;
  };
  createdAt: number;
}

export async function withIdempotency(
  request: NextRequest,
  handler: () => Promise<Response>
): Promise<Response> {
  const idempotencyKey = request.headers.get('Idempotency-Key');

  // No key provided - proceed normally
  if (!idempotencyKey) {
    return handler();
  }

  const redisKey = `hx-docling:idempotency:${idempotencyKey}`;

  // Check for existing record
  const existing = await redis.get(redisKey);

  if (existing) {
    const record: IdempotencyRecord = JSON.parse(existing);

    if (record.status === 'processing') {
      // Request still in progress
      return new Response(null, { status: 409 }); // Conflict
    }

    if (record.response) {
      // Return cached response
      return new Response(JSON.stringify(record.response.body), {
        status: record.response.status,
        headers: {
          ...record.response.headers,
          'Idempotency-Replayed': 'true',
        },
      });
    }
  }

  // Mark as processing
  await redis.setex(
    redisKey,
    IDEMPOTENCY_TTL_SECONDS,
    JSON.stringify({ status: 'processing', createdAt: Date.now() })
  );

  try {
    const response = await handler();

    // Cache successful response
    const body = await response.clone().json();
    const record: IdempotencyRecord = {
      status: 'completed',
      response: {
        status: response.status,
        body,
        headers: Object.fromEntries(response.headers),
      },
      createdAt: Date.now(),
    };

    await redis.setex(redisKey, IDEMPOTENCY_TTL_SECONDS, JSON.stringify(record));

    return response;
  } catch (error) {
    // Remove processing marker on error
    await redis.del(redisKey);
    throw error;
  }
}

// Usage
// POST /api/v1/upload with header: Idempotency-Key: client-uuid
```

---

## 5. Data Models

### 5.1 Database Schema (Prisma)

**Reference**: [CHARTER: 7.3], [ARCH: 8.1]

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model Job {
  id             String    @id @default(uuid())
  sessionId      String
  status         JobStatus
  inputType      InputType

  // File metadata
  fileName       String?
  fileSize       Int?
  filePath       String?
  mimeType       String?

  // URL metadata
  url            String?

  // Processing state
  currentStage   String?
  currentPercent Int?
  currentMessage String?
  checkpointData Json?     @db.JsonB

  // Timestamps
  createdAt      DateTime  @default(now()) @db.Timestamptz
  updatedAt      DateTime  @updatedAt @db.Timestamptz
  completedAt    DateTime? @db.Timestamptz

  // Error tracking
  error          String?
  errorCode      String?
  retryCount     Int       @default(0)

  // Relations
  results        Result[]

  // Indexes
  @@index([sessionId])
  @@index([status, createdAt(sort: Desc)])
  @@index([completedAt])
  @@index([sessionId, status])
  @@index([sessionId, createdAt])
}

model Result {
  id        String       @id @default(uuid())
  jobId     String
  format    ResultFormat
  content   String       @db.Text
  size      Int
  createdAt DateTime     @default(now()) @db.Timestamptz

  job       Job          @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, format])
}

enum JobStatus {
  PENDING
  UPLOADING
  PROCESSING
  RETRY_1
  RETRY_2
  RETRY_3
  COMPLETE
  PARTIAL_COMPLETE
  CANCELLED
  ERROR
}

enum InputType {
  FILE
  URL
}

enum ResultFormat {
  MARKDOWN
  HTML
  JSON
  RAW
}
```

### 5.1.1 Database Connection Validation (MAJ-DB-001)

**Purpose**: Validate database connectivity on application startup to fail fast and prevent runtime errors.

```typescript
// lib/db/health.ts

import { prisma } from './prisma';

interface DatabaseHealthStatus {
  healthy: boolean;
  latencyMs: number;
  error?: string;
}

/**
 * Validate database connection on application startup.
 * Called from instrumentation.ts or app initialization.
 */
export async function validateDatabaseConnection(): Promise<DatabaseHealthStatus> {
  const start = Date.now();

  try {
    // Simple query to validate connection
    await prisma.$queryRaw`SELECT 1`;

    return {
      healthy: true,
      latencyMs: Date.now() - start,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown database error';

    console.error('[Database] Connection validation failed:', errorMessage);

    return {
      healthy: false,
      latencyMs: Date.now() - start,
      error: errorMessage,
    };
  }
}

/**
 * Startup validation - exits process if database unavailable
 */
export async function ensureDatabaseConnection(): Promise<void> {
  const MAX_RETRIES = 3;
  const RETRY_DELAY_MS = 2000;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    const status = await validateDatabaseConnection();

    if (status.healthy) {
      console.log(`[Database] Connection established (${status.latencyMs}ms)`);
      return;
    }

    if (attempt < MAX_RETRIES) {
      console.warn(`[Database] Retry ${attempt}/${MAX_RETRIES} in ${RETRY_DELAY_MS}ms...`);
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
    }
  }

  console.error('[Database] Failed to connect after maximum retries. Exiting.');
  process.exit(1);
}
```

### 5.1.2 JobStatus State Machine (MAJ-DB-002)

**Purpose**: Define valid state transitions for job processing to prevent invalid states and clarify PARTIAL_COMPLETE vs COMPLETE distinction.

```mermaid
stateDiagram-v2
    [*] --> PENDING: Job created
    PENDING --> UPLOADING: Upload started
    PENDING --> CANCELLED: User cancelled

    UPLOADING --> PROCESSING: Upload complete
    UPLOADING --> ERROR: Upload failed
    UPLOADING --> CANCELLED: User cancelled

    PROCESSING --> COMPLETE: All exports successful
    PROCESSING --> PARTIAL_COMPLETE: Some exports failed
    PROCESSING --> ERROR: Conversion failed
    PROCESSING --> RETRY_1: Transient error
    PROCESSING --> CANCELLED: User cancelled

    RETRY_1 --> PROCESSING: Retry successful
    RETRY_1 --> RETRY_2: Retry failed (transient)
    RETRY_1 --> ERROR: Retry failed (non-transient)
    RETRY_1 --> CANCELLED: User cancelled

    RETRY_2 --> PROCESSING: Retry successful
    RETRY_2 --> RETRY_3: Retry failed (transient)
    RETRY_2 --> ERROR: Retry failed (non-transient)
    RETRY_2 --> CANCELLED: User cancelled

    RETRY_3 --> PROCESSING: Retry successful
    RETRY_3 --> ERROR: Max retries exceeded
    RETRY_3 --> CANCELLED: User cancelled

    COMPLETE --> [*]
    PARTIAL_COMPLETE --> [*]
    ERROR --> [*]
    CANCELLED --> [*]
```

**State Definitions**:

| Status | Description | Terminal? |
|--------|-------------|-----------|
| PENDING | Job created, awaiting upload | No |
| UPLOADING | File upload in progress | No |
| PROCESSING | MCP conversion/export in progress | No |
| RETRY_1 | First retry attempt after transient error | No |
| RETRY_2 | Second retry attempt | No |
| RETRY_3 | Third (final) retry attempt | No |
| COMPLETE | All conversions and exports successful | Yes |
| PARTIAL_COMPLETE | Conversion succeeded, some exports failed | Yes |
| CANCELLED | User cancelled the job | Yes |
| ERROR | Unrecoverable error occurred | Yes |

**COMPLETE vs PARTIAL_COMPLETE Distinction**:
- **COMPLETE**: DoclingDocument conversion succeeded AND all three exports (markdown, html, json) succeeded
- **PARTIAL_COMPLETE**: DoclingDocument conversion succeeded BUT at least one export failed. Available exports are stored and retrievable.

**State Transition Validation**:

```typescript
// lib/job/state-machine.ts

const VALID_TRANSITIONS: Record<JobStatus, JobStatus[]> = {
  PENDING: ['UPLOADING', 'CANCELLED'],
  UPLOADING: ['PROCESSING', 'ERROR', 'CANCELLED'],
  PROCESSING: ['COMPLETE', 'PARTIAL_COMPLETE', 'ERROR', 'RETRY_1', 'CANCELLED'],
  RETRY_1: ['PROCESSING', 'RETRY_2', 'ERROR', 'CANCELLED'],
  RETRY_2: ['PROCESSING', 'RETRY_3', 'ERROR', 'CANCELLED'],
  RETRY_3: ['PROCESSING', 'ERROR', 'CANCELLED'],
  COMPLETE: [],      // Terminal state
  PARTIAL_COMPLETE: [], // Terminal state
  CANCELLED: [],     // Terminal state
  ERROR: [],         // Terminal state
};

export function isValidTransition(from: JobStatus, to: JobStatus): boolean {
  return VALID_TRANSITIONS[from]?.includes(to) ?? false;
}

export async function transitionJobStatus(
  jobId: string,
  newStatus: JobStatus
): Promise<void> {
  const job = await prisma.job.findUnique({
    where: { id: jobId },
    select: { status: true },
  });

  if (!job) {
    throw new AppError('E501', 'Job not found');
  }

  if (!isValidTransition(job.status, newStatus)) {
    throw new AppError(
      'E707',
      `Invalid state transition: ${job.status} -> ${newStatus}`
    );
  }

  await prisma.job.update({
    where: { id: jobId },
    data: { status: newStatus },
  });
}
```

### 5.1.3 Connection Pool Configuration (MAJ-DB-003)

**Purpose**: Document connection pool sizing rationale based on workload characteristics.

**Pool Size Calculation**:

```
Optimal Pool Size = (CPU Cores * 2) + Spindle Count
For SSDs: Pool Size = CPU Cores * 2
```

**Recommended Configuration**:

| Environment | Instance Type | Pool Size | Rationale |
|-------------|---------------|-----------|-----------|
| Development | Single instance | 5 | Minimal load, local development |
| Staging | Single instance | 10 | Testing with simulated load |
| Production | Single instance | 25 | 10 concurrent users, headroom for spikes |
| Production HA | Multiple instances | 10/instance | Shared across instances |

**PgBouncer Considerations**:
- Application pool (`connection_limit=5`) connects to PgBouncer (port 6432)
- PgBouncer manages upstream connections to PostgreSQL (port 5432)
- Total connections = `instances * connection_limit` should not exceed PgBouncer's `max_client_conn`

### 5.1.4 Result Size Validation (MAJ-DB-005)

**Purpose**: Enforce maximum result sizes before database insertion to prevent storage issues.

```typescript
// lib/validation/result.ts

const MAX_RESULT_SIZES = {
  MARKDOWN: 25 * 1024 * 1024,  // 25 MB per charter
  HTML: 25 * 1024 * 1024,
  JSON: 25 * 1024 * 1024,
  RAW: 50 * 1024 * 1024,       // DoclingDocument can be larger
};

export function validateResultSize(
  content: string,
  format: ResultFormat
): { valid: boolean; size: number; maxSize: number } {
  const size = Buffer.byteLength(content, 'utf8');
  const maxSize = MAX_RESULT_SIZES[format];

  return {
    valid: size <= maxSize,
    size,
    maxSize,
  };
}

export async function saveResultWithValidation(
  jobId: string,
  format: ResultFormat,
  content: string
): Promise<Result> {
  const validation = validateResultSize(content, format);

  if (!validation.valid) {
    throw new AppError(
      'E305',
      `Result size (${Math.round(validation.size / 1024 / 1024)}MB) exceeds maximum (${Math.round(validation.maxSize / 1024 / 1024)}MB)`
    );
  }

  return prisma.result.create({
    data: {
      jobId,
      format,
      content,
      size: validation.size,
    },
  });
}
```

### 5.2 TypeScript Interfaces

```typescript
// types/document.ts

export interface FileInput {
  type: 'file';
  file: File;
  fileName: string;
  fileSize: number;
  mimeType: string;
}

export interface URLInput {
  type: 'url';
  url: string;
}

export type DocumentInput = FileInput | URLInput;

// types/job.ts

export interface Job {
  id: string;
  sessionId: string;
  status: JobStatus;
  inputType: InputType;
  fileName?: string;
  fileSize?: number;
  filePath?: string;
  mimeType?: string;
  url?: string;
  currentStage?: string;
  currentPercent?: number;
  currentMessage?: string;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  error?: string;
  errorCode?: string;
  retryCount: number;
  results: Result[];
}

export type JobStatus =
  | 'PENDING'
  | 'UPLOADING'
  | 'PROCESSING'
  | 'RETRY_1'
  | 'RETRY_2'
  | 'RETRY_3'
  | 'COMPLETE'
  | 'PARTIAL_COMPLETE'
  | 'CANCELLED'
  | 'ERROR';

export type InputType = 'FILE' | 'URL';

// types/processing.ts

export interface Progress {
  stage: string;
  percent: number;
  message: string;
}

export interface ProcessingResult {
  markdown?: ExportResult;
  html?: ExportResult;
  json?: ExportResult;
  raw?: string;
}

export interface ExportResult {
  success: boolean;
  content?: string;
  error?: string;
  size?: number;
}

// types/errors.ts

export interface AppError {
  code: string;
  message: string;
  userMessage: string;
  suggestedAction: string;
  retryable: boolean;
  retryDelay?: number;
}

export interface ErrorState {
  code: string;
  message: string;
  recovery: ErrorRecovery;
}

export interface ErrorRecovery {
  retryable: boolean;
  suggestedAction: string;
  retryDelay?: number;
}
```

### 5.3 Zustand Store Schema

```typescript
// stores/documentStore.ts

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

// File metadata for persistence (CRI-10)
interface FileMetadata {
  name: string;
  size: number;
  type: string;
  lastModified: number;
}

interface DocumentState {
  // Input state
  file: File | null;
  fileMetadata: FileMetadata | null;  // Persisted (CRI-10)
  url: string | null;
  activeInput: 'file' | 'url' | null;

  // Processing state
  isProcessing: boolean;
  isRecovering: boolean;  // New state for recovery (CRI-10)
  jobId: string | null;
  progress: Progress | null;
  connectionStatus: 'disconnected' | 'connected' | 'polling' | 'recovering';

  // Result state
  result: ProcessingResult | null;

  // Error state
  error: ErrorState | null;

  // Actions (defined below)
}

export const useDocumentStore = create<DocumentState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        file: null,
        fileMetadata: null,
        url: null,
        activeInput: null,
        isProcessing: false,
        isRecovering: false,
        jobId: null,
        progress: null,
        connectionStatus: 'disconnected',
        result: null,
        error: null,

        // Actions with mutual exclusion
        setFile: (file) => {
          if (get().isProcessing) return;
          const fileMetadata = file ? {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: file.lastModified,
          } : null;
          set({ file, fileMetadata, url: null, activeInput: file ? 'file' : null, error: null });
        },

        setUrl: (url) => {
          if (get().isProcessing) return;
          set({ url, file: null, fileMetadata: null, activeInput: url ? 'url' : null, error: null });
        },

        clearInputs: () => {
          if (get().isProcessing) return;
          set({ file: null, fileMetadata: null, url: null, activeInput: null, error: null });
        },

        startProcessing: (jobId) => set({
          isProcessing: true,
          isRecovering: false,
          jobId,
          progress: { stage: 'upload', percent: 0, message: 'Starting...' },
          error: null
        }),

        // Recovery action (CRI-10)
        startRecovery: (jobId) => set({
          isProcessing: true,
          isRecovering: true,
          jobId,
          connectionStatus: 'recovering',
          error: null
        }),

        updateProgress: (progress) => set({ progress }),

        setConnectionStatus: (connectionStatus) => set({ connectionStatus }),

        setResult: (result) => set({
          result,
          isProcessing: false,
          isRecovering: false,
          progress: { stage: 'complete', percent: 100, message: 'Complete!' }
        }),

        setError: (error) => set({ error, isProcessing: false, isRecovering: false }),

        reset: () => set({
          file: null,
          fileMetadata: null,
          url: null,
          activeInput: null,
          isProcessing: false,
          isRecovering: false,
          jobId: null,
          progress: null,
          connectionStatus: 'disconnected',
          result: null,
          error: null,
        }),
      }),
      {
        name: 'document-store',
        partialize: (state) => ({
          // Persist these for recovery (CRI-10)
          jobId: state.jobId,
          fileMetadata: state.fileMetadata,  // Persist file metadata
          url: state.url,                    // Persist URL if used
          activeInput: state.activeInput,
          // Don't persist: file (can't serialize), progress, result
        }),
      }
    ),
    { name: 'DocumentStore' }
  )
);

/**
 * Browser Refresh Recovery Flow (CRI-10)
 *
 * On page load, check for persisted jobId and attempt recovery:
 */

// hooks/useJobRecovery.ts

export function useJobRecovery() {
  const { jobId, fileMetadata, url, startRecovery, setResult, setError, reset } = useDocumentStore();

  useEffect(() => {
    async function attemptRecovery() {
      if (!jobId) return;

      try {
        // Check job status from server
        const response = await fetch(`/api/v1/jobs/${jobId}`);

        if (!response.ok) {
          if (response.status === 404) {
            // Job expired or not found, clear state
            reset();
            return;
          }
          throw new Error('Failed to fetch job status');
        }

        const job = await response.json();

        switch (job.status) {
          case 'COMPLETE':
          case 'PARTIAL_COMPLETE':
            // Job finished while we were away
            setResult(job.results);
            break;

          case 'ERROR':
            // Job failed while we were away
            setError({ code: job.errorCode, message: job.error, recovery: { retryable: false, suggestedAction: 'Try again' } });
            break;

          case 'CANCELLED':
            // Job was cancelled
            reset();
            break;

          case 'PROCESSING':
          case 'RETRY_1':
          case 'RETRY_2':
          case 'RETRY_3':
            // Job still running - reconnect to SSE
            startRecovery(jobId);
            // SSE hook will handle reconnection
            break;

          case 'PENDING':
          case 'UPLOADING':
            // Job in early stage - may need user action
            // Show "reconnecting to job" UI
            startRecovery(jobId);
            break;

          default:
            reset();
        }
      } catch (error) {
        console.error('Job recovery failed:', error);
        reset();
      }
    }

    attemptRecovery();
  }, []); // Run once on mount

  return {
    isRecovering: useDocumentStore((s) => s.isRecovering),
    recoveredFileMetadata: fileMetadata,
    recoveredUrl: url,
  };
}
```

### 5.4 Session Schema (Redis)

```typescript
// lib/redis/session.ts

interface Session {
  id: string;              // UUID v4
  createdAt: number;       // Unix timestamp (seconds)
  lastActivity: number;    // Unix timestamp (seconds)
  jobCount: number;        // Total jobs in session
  activeJobIds: string[];  // Currently processing jobs (supports multiple tabs per MAJ-12)
}

// Key patterns
const REDIS_KEYS = {
  session: (id: string) => `hx-docling:session:${id}`,
  rateLimit: (sessionId: string) => `hx-docling:rate:${sessionId}`,
  jobProgress: (jobId: string) => `hx-docling:job:${jobId}:progress`,
};

// TTLs
const TTL = {
  session: 86400,        // 24 hours
  rateLimit: 60,         // 1 minute
  jobProgress: 300,      // 5 minutes
};
```

### 5.5 Checkpoint Schema (CRI-08)

**Purpose**: Enable job resumption after failures or interruptions. Checkpoints are saved at key processing stages.

```typescript
// types/checkpoint.ts

interface Checkpoint {
  // Checkpoint identification
  jobId: string;
  version: string;           // Schema version for migration compatibility

  // Processing stage
  stage: CheckpointStage;
  stageCompletedAt: string;  // ISO 8601

  // Saved state
  uploadedFilePath?: string;  // After upload stage
  doclingDocument?: DoclingDocument;  // After conversion stage
  exportResults?: {           // After each export stage
    markdown?: ExportResult;
    html?: ExportResult;
    json?: ExportResult;
  };

  // Metadata
  savedAt: string;           // ISO 8601
  expiresAt: string;         // ISO 8601 (24 hours from savedAt)
  checksum?: string;         // MD5 hash for integrity validation
}

type CheckpointStage =
  | 'uploaded'              // File uploaded to temp storage
  | 'converted'             // DoclingDocument created
  | 'export_markdown'       // Markdown export complete
  | 'export_html'           // HTML export complete
  | 'export_json'           // JSON export complete
  | 'completed';            // All exports complete

interface ExportResult {
  success: boolean;
  content?: string;
  size?: number;
  error?: string;
}
```

**Checkpoint Save Points**:

| Stage | Trigger | Data Saved | Size Estimate |
|-------|---------|------------|---------------|
| uploaded | File saved to temp | `uploadedFilePath` | ~100 bytes |
| converted | MCP convert_* returns | `doclingDocument` | 1-50 KB |
| export_markdown | export_markdown returns | `exportResults.markdown` | 1-100 KB |
| export_html | export_html returns | `exportResults.html` | 1-100 KB |
| export_json | export_json returns | `exportResults.json` | 1-50 KB |
| completed | All exports done | Full checkpoint | 5-300 KB |

**Checkpoint Implementation**:

```typescript
// lib/checkpoint/manager.ts

const CHECKPOINT_TTL_HOURS = 24;

export async function saveCheckpoint(
  jobId: string,
  stage: CheckpointStage,
  data: Partial<Checkpoint>
): Promise<void> {
  const now = new Date();
  const expiresAt = new Date(now.getTime() + CHECKPOINT_TTL_HOURS * 60 * 60 * 1000);

  const checkpoint: Checkpoint = {
    jobId,
    version: '1.0.0',
    stage,
    stageCompletedAt: now.toISOString(),
    ...data,
    savedAt: now.toISOString(),
    expiresAt: expiresAt.toISOString(),
  };

  // Calculate checksum for integrity validation
  checkpoint.checksum = calculateChecksum(checkpoint);

  // Save to PostgreSQL checkpointData field
  await prisma.job.update({
    where: { id: jobId },
    data: {
      checkpointData: checkpoint as Prisma.InputJsonValue,
      currentStage: stage,
    },
  });
}

export async function loadCheckpoint(jobId: string): Promise<Checkpoint | null> {
  const job = await prisma.job.findUnique({
    where: { id: jobId },
    select: { checkpointData: true },
  });

  if (!job?.checkpointData) return null;

  const checkpoint = job.checkpointData as unknown as Checkpoint;

  // Validate expiry
  if (new Date(checkpoint.expiresAt) < new Date()) {
    await clearCheckpoint(jobId);
    return null;
  }

  // Validate checksum
  const savedChecksum = checkpoint.checksum;
  checkpoint.checksum = undefined;
  if (calculateChecksum(checkpoint) !== savedChecksum) {
    await clearCheckpoint(jobId);
    throw new CheckpointCorruptedError(jobId);
  }

  return checkpoint;
}

export async function clearCheckpoint(jobId: string): Promise<void> {
  await prisma.job.update({
    where: { id: jobId },
    data: { checkpointData: null },
  });
}
```

**Resume Endpoint**:

#### POST /api/v1/jobs/{id}/resume

**Purpose**: Resume processing from the last checkpoint

**Request**:
```http
POST /api/v1/jobs/{id}/resume HTTP/1.1
Content-Type: application/json
```

**Response (202 Accepted)**:
```json
{
  "jobId": "uuid-v4",
  "status": "PROCESSING",
  "resumedFromStage": "converted",
  "streamUrl": "/api/v1/process/{jobId}/events"
}
```

**Error Responses**:

| Status | Code | Description |
|--------|------|-------------|
| 404 | E501 | Job not found |
| 409 | E703 | No valid checkpoint exists |
| 409 | E704 | Checkpoint expired |
| 409 | E705 | Checkpoint corrupted |
| 409 | E706 | Job already completed |

**Resume Logic**:
```typescript
export async function resumeJob(jobId: string): Promise<void> {
  const checkpoint = await loadCheckpoint(jobId);

  if (!checkpoint) {
    throw new AppError('E703', 'No valid checkpoint exists');
  }

  // Resume from the appropriate stage
  switch (checkpoint.stage) {
    case 'uploaded':
      // Re-run conversion and exports
      await runConversion(jobId, checkpoint.uploadedFilePath!);
      break;
    case 'converted':
      // Re-run all exports
      await runExports(jobId, checkpoint.doclingDocument!);
      break;
    case 'export_markdown':
    case 'export_html':
    case 'export_json':
      // Re-run remaining exports
      await runRemainingExports(jobId, checkpoint);
      break;
    case 'completed':
      // Nothing to resume
      throw new AppError('E706', 'Job already completed');
  }
}
```

---

## 6. Component Specifications

### 6.0 Theme Configuration (MAJ-01)

**Reference**: [CHARTER: Design System]

#### 6.0.1 Dark Mode Implementation

The application MUST support dark mode via `next-themes` and shadcn/ui theming.

**Theme Configuration**:
```typescript
// app/providers.tsx

import { ThemeProvider } from 'next-themes';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      {children}
    </ThemeProvider>
  );
}
```

**CSS Variables** (tailwind.config.ts):
```typescript
// Light theme (default)
':root': {
  '--background': '0 0% 100%',
  '--foreground': '222.2 84% 4.9%',
  '--card': '0 0% 100%',
  '--card-foreground': '222.2 84% 4.9%',
  '--primary': '221.2 83.2% 53.3%',
  '--primary-foreground': '210 40% 98%',
  '--secondary': '210 40% 96.1%',
  '--secondary-foreground': '222.2 47.4% 11.2%',
  '--muted': '210 40% 96.1%',
  '--muted-foreground': '215.4 16.3% 46.9%',
  '--accent': '210 40% 96.1%',
  '--accent-foreground': '222.2 47.4% 11.2%',
  '--destructive': '0 84.2% 60.2%',
  '--destructive-foreground': '210 40% 98%',
  '--border': '214.3 31.8% 91.4%',
  '--input': '214.3 31.8% 91.4%',
  '--ring': '221.2 83.2% 53.3%',
},

// Dark theme
'.dark': {
  '--background': '222.2 84% 4.9%',
  '--foreground': '210 40% 98%',
  '--card': '222.2 84% 4.9%',
  '--card-foreground': '210 40% 98%',
  '--primary': '217.2 91.2% 59.8%',
  '--primary-foreground': '222.2 47.4% 11.2%',
  '--secondary': '217.2 32.6% 17.5%',
  '--secondary-foreground': '210 40% 98%',
  '--muted': '217.2 32.6% 17.5%',
  '--muted-foreground': '215 20.2% 65.1%',
  '--accent': '217.2 32.6% 17.5%',
  '--accent-foreground': '210 40% 98%',
  '--destructive': '0 62.8% 30.6%',
  '--destructive-foreground': '210 40% 98%',
  '--border': '217.2 32.6% 17.5%',
  '--input': '217.2 32.6% 17.5%',
  '--ring': '224.3 76.3% 48%',
}
```

**ThemeToggle Component**:
```typescript
// components/ui/theme-toggle.tsx

'use client';

import { Moon, Sun } from 'lucide-react';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

export function ThemeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon" aria-label="Toggle theme">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### 6.1 Component Architecture Overview

**Reference**: [ARCH: 5.1], [CHARTER: 6.3]

```
src/components/
 ui/                    # shadcn/ui base components
 upload/
    UploadZone.tsx     # Client - File drag-drop
    UrlInput.tsx       # Client - URL entry
    FilePreview.tsx    # Client - Selected file display
 processing/
    ProgressCard.tsx   # Client - Progress display
    StatusBadge.tsx    # Server - Status indicator
    LoadingStates.tsx  # Client - Loading UI states
 results/
    ResultsViewer.tsx  # Client - Tabbed container
    MarkdownView.tsx   # Server - Markdown render
    HtmlView.tsx       # Server - HTML preview
    JsonView.tsx       # Server - JSON display
    RawView.tsx        # Server - Raw output
    DownloadButton.tsx # Client - Download trigger
 history/
    HistoryView.tsx    # Server - History table
    JobRow.tsx         # Server - Table row
    JobDetail.tsx      # Client - Detail modal
    Pagination.tsx     # Server - Page controls
 layout/
    Header.tsx         # Server - App header
    Footer.tsx         # Server - App footer
    Container.tsx      # Server - Layout wrapper
 error/
     ErrorBoundary.tsx  # Client - Error boundary
     ErrorDisplay.tsx   # Client - Error message
     ErrorRecovery.tsx  # Client - Recovery actions
```

### 6.2 Component Specifications

#### 6.2.1 UploadZone Component

| Aspect | Specification |
|--------|---------------|
| **File** | `components/upload/UploadZone.tsx` |
| **Type** | Client Component (`'use client'`) |
| **Purpose** | File selection via drag-drop or click |
| **Dependencies** | react-dropzone, documentStore |
| **shadcn Components** | Card, Button |

**Props Interface**:
```typescript
interface UploadZoneProps {
  disabled?: boolean;
  onFileSelect?: (file: File) => void;
  className?: string;
}
```

**State Management**:
- Reads: `isProcessing` from documentStore
- Writes: `setFile()` action

**Behavior**:
1. Accept files via drag-drop or click
2. Validate file type and size client-side
3. Display validation errors immediately
4. Emit FILE_SELECTED event on valid file
5. Show preview after selection

**Styling Pattern (MAJ-04)**:
```typescript
// TailwindCSS class structure with cn() utility
import { cn } from '@/lib/utils';

<div
  {...getRootProps()}
  className={cn(
    // Base styles
    "border-2 border-dashed rounded-lg p-8 transition-colors cursor-pointer",
    "flex flex-col items-center justify-center gap-4",
    "min-h-[200px]",

    // Default state
    "border-muted-foreground/25 hover:border-muted-foreground/50",

    // Drag active state
    isDragActive && "border-primary bg-primary/10",

    // Drag reject state (invalid file type)
    isDragReject && "border-destructive bg-destructive/10",

    // Disabled state
    disabled && "opacity-50 cursor-not-allowed pointer-events-none",

    // Focus state (keyboard navigation)
    "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
  )}
>
  {/* Content */}
</div>
```

**Accessibility**:
- `role="button"` for dropzone
- `aria-label="Drop file here or click to browse"`
- Keyboard accessible (Enter/Space to activate)
- Focus visible indicator

#### 6.2.2 UrlInput Component

| Aspect | Specification |
|--------|---------------|
| **File** | `components/upload/UrlInput.tsx` |
| **Type** | Client Component (`'use client'`) |
| **Purpose** | URL entry with validation |
| **Dependencies** | react-hook-form, zod, documentStore |
| **shadcn Components** | Input, Button, Label |

**Props Interface**:
```typescript
interface UrlInputProps {
  disabled?: boolean;
  onUrlSubmit?: (url: string) => void;
  className?: string;
}
```

**Validation Schema**:
```typescript
const urlSchema = z.string()
  .url('Invalid URL format')
  .max(2048, 'URL too long')
  .refine(url => !isURLBlocked(url), 'URL not allowed');
```

**Form Component Integration (MAJ-08)**:
```typescript
// Required pattern using shadcn/ui Form with react-hook-form

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';

export function UrlInput({ disabled, onUrlSubmit }: UrlInputProps) {
  const form = useForm<{ url: string }>({
    resolver: zodResolver(z.object({ url: urlSchema })),
    defaultValues: { url: '' },
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(({ url }) => onUrlSubmit?.(url))}>
        <FormField
          control={form.control}
          name="url"
          render={({ field }) => (
            <FormItem>
              <FormLabel>URL</FormLabel>
              <FormControl>
                <Input
                  {...field}
                  placeholder="https://example.com/document.html"
                  disabled={disabled}
                />
              </FormControl>
              <FormMessage /> {/* Displays validation errors */}
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
}
```

**Behavior**:
1. Accept URL via paste or type
2. Validate format and security client-side
3. Display validation errors inline via FormMessage (WCAG 3.3.1)
4. Clear button to reset input
5. Submit on Enter key or button click

#### 6.2.3 ProgressCard Component

| Aspect | Specification |
|--------|---------------|
| **File** | `components/processing/ProgressCard.tsx` |
| **Type** | Client Component (`'use client'`) |
| **Purpose** | Display processing progress |
| **Dependencies** | useSSE hook, documentStore |
| **shadcn Components** | Card, Progress, Badge |

**Props Interface**:
```typescript
interface ProgressCardProps {
  jobId: string;
  className?: string;
}
```

**Sub-States** [ARCH: 5.3.1]:

| SubState | Visual | Message |
|----------|--------|---------|
| initial | Spinner | "Starting..." |
| streaming | Progress bar | "{stage}... ({percent}%)" |
| retry | Spinner + counter | "Reconnecting... (attempt {n}/10)" |
| polling | Pulsing indicator | "Using compatibility mode" |
| recovering | Pulsing + text | "Reconnecting to job..." |

**Badge Variant Mapping (MAJ-02)**:

| Job Status | Badge Variant | Color | Icon |
|------------|---------------|-------|------|
| PENDING | `default` | blue | Clock |
| UPLOADING | `secondary` | purple | Upload |
| PROCESSING | `secondary` | purple | Loader |
| RETRY_1/2/3 | `outline` | orange | RefreshCw |
| COMPLETE | `default` | green | Check |
| PARTIAL_COMPLETE | `outline` | yellow | AlertCircle |
| CANCELLED | `secondary` | gray | XCircle |
| ERROR | `destructive` | red | AlertTriangle |

```typescript
// components/ui/status-badge.tsx

const STATUS_BADGE_CONFIG: Record<JobStatus, { variant: BadgeVariant; icon: LucideIcon }> = {
  PENDING: { variant: 'default', icon: Clock },
  UPLOADING: { variant: 'secondary', icon: Upload },
  PROCESSING: { variant: 'secondary', icon: Loader },
  RETRY_1: { variant: 'outline', icon: RefreshCw },
  RETRY_2: { variant: 'outline', icon: RefreshCw },
  RETRY_3: { variant: 'outline', icon: RefreshCw },
  COMPLETE: { variant: 'default', icon: Check },
  PARTIAL_COMPLETE: { variant: 'outline', icon: AlertCircle },
  CANCELLED: { variant: 'secondary', icon: XCircle },
  ERROR: { variant: 'destructive', icon: AlertTriangle },
};
```

**Accessibility**:
- `role="progressbar"` on progress element
- `aria-valuenow`, `aria-valuemin`, `aria-valuemax`
- `aria-live="polite"` for progress updates
- Screen reader announcement on stage change

#### 6.2.4 ResultsViewer Component

| Aspect | Specification |
|--------|---------------|
| **File** | `components/results/ResultsViewer.tsx` |
| **Type** | Client Component (`'use client'`) |
| **Purpose** | Tabbed results display |
| **Dependencies** | documentStore |
| **shadcn Components** | Tabs, TabsList, TabsTrigger, TabsContent |

**Props Interface**:
```typescript
interface ResultsViewerProps {
  result: ProcessingResult;
  className?: string;
}
```

**Configuration** [CHARTER: 6.3.2]:
```typescript
const RESULTS_CONFIG = {
  defaultTab: 'markdown',
  tabOrder: ['markdown', 'html', 'json', 'raw'],
  rendering: 'eager',
  sessionMemory: true,
};
```

**Skeleton Loading States (MAJ-03)**:
```typescript
// components/results/ResultsSkeleton.tsx

export function ResultsSkeleton() {
  return (
    <div className="space-y-4" aria-busy="true" aria-label="Loading results">
      <Skeleton className="h-10 w-full" /> {/* Tab bar */}
      <Skeleton className="h-[400px] w-full" /> {/* Content area */}
    </div>
  );
}

// Usage with Suspense
<Suspense fallback={<ResultsSkeleton />}>
  <ResultsViewer result={result} />
</Suspense>
```

**Keyboard Shortcuts (MAJ-10)**:
```typescript
// Tab keyboard shortcuts integration
const TAB_SHORTCUTS = {
  'Ctrl+Shift+1': 'markdown',
  'Ctrl+Shift+2': 'html',
  'Ctrl+Shift+3': 'json',
  'Ctrl+Shift+4': 'raw',
};

// Add to ResultsViewer component
useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.ctrlKey && e.shiftKey) {
      const tabIndex = parseInt(e.key);
      if (tabIndex >= 1 && tabIndex <= 4) {
        e.preventDefault();
        const tabs = ['markdown', 'html', 'json', 'raw'];
        setActiveTab(tabs[tabIndex - 1]);
      }
    }
  };

  document.addEventListener('keydown', handleKeyDown);
  return () => document.removeEventListener('keydown', handleKeyDown);
}, []);
```

**Accessibility**:
- Proper ARIA tab pattern
- Keyboard navigation (Arrow keys)
- Focus management on tab switch
- `aria-busy="true"` during loading (MAJ-03)
- Keyboard shortcuts for tab switching (Ctrl/Cmd+Shift+1-4) (MAJ-10)

#### 6.2.5 ErrorRecovery Component

| Aspect | Specification |
|--------|---------------|
| **File** | `components/error/ErrorRecovery.tsx` |
| **Type** | Client Component (`'use client'`) |
| **Purpose** | Display error with recovery actions |
| **Dependencies** | documentStore |
| **shadcn Components** | Card, Button, Alert |

**Props Interface**:
```typescript
interface ErrorRecoveryProps {
  error: ErrorState;
  onRetry: () => void;
  onCancel: () => void;
  onModify: () => void;
}
```

**Recovery Actions by Error Type**:

| Error Code | Retry | Modify | Cancel |
|------------|-------|--------|--------|
| E001-E005 | No | Yes | Yes |
| E101-E104 | No | Yes | Yes |
| E201-E204 | Yes | No | Yes |
| E301-E304 | Yes | No | Yes |
| E401-E403 | Yes | No | Yes |
| E501-E502 | No | No | Yes |
| E601 | Yes (delayed) | No | Yes |

### 6.2.6 Responsive Design Specifications (MAJ-UI-001)

**Purpose**: Define responsive design breakpoints and component behavior at each breakpoint to support tablet users (SC-NF4).

#### Tailwind Breakpoint Definitions

```typescript
// tailwind.config.ts - Standard breakpoints

const breakpoints = {
  sm: '640px',   // Small tablets (portrait)
  md: '768px',   // Tablets (landscape), small laptops
  lg: '1024px',  // Laptops, desktops
  xl: '1280px',  // Large desktops
  '2xl': '1536px', // Extra large screens
};
```

#### Component Behavior by Breakpoint

| Component | Mobile (<640px) | Tablet (768px-1023px) | Desktop (>=1024px) |
|-----------|-----------------|------------------------|-------------------|
| UploadZone | Full width, stacked | Full width, stacked | 60% width, side-by-side with URL |
| UrlInput | Full width below upload | Full width below upload | 40% width, side-by-side |
| ResultsTabs | Horizontal scroll | Horizontal tabs | Horizontal tabs |
| HistoryTable | Card layout | Compact table | Full table |
| Pagination | Simplified (prev/next) | Full pagination | Full pagination |

#### Layout Patterns

```typescript
// components/layout/MainLayout.tsx

export function MainLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className={cn(
      'min-h-screen bg-background',
      // Mobile first
      'px-4 py-6',
      // Tablet
      'md:px-6 md:py-8',
      // Desktop
      'lg:px-8 lg:py-10',
      // Max width container
      'mx-auto max-w-7xl'
    )}>
      {children}
    </div>
  );
}

// components/upload/InputSection.tsx

export function InputSection() {
  return (
    <div className={cn(
      // Mobile: stacked layout
      'flex flex-col gap-4',
      // Desktop: side-by-side
      'lg:flex-row lg:gap-6'
    )}>
      <div className="lg:w-3/5">
        <UploadZone />
      </div>
      <div className="lg:w-2/5">
        <UrlInput />
      </div>
    </div>
  );
}
```

#### Touch Interaction Specifications

| Element | Min Touch Target | Spacing |
|---------|-----------------|---------|
| Buttons | 44x44px | 8px minimum gap |
| Tab triggers | 44px height | 4px gap between |
| Table rows | 48px height | No gap needed |
| Form inputs | 44px height | 16px vertical margin |

```typescript
// Touch-friendly button sizing
<Button className={cn(
  // Ensure minimum touch target
  'min-h-[44px] min-w-[44px]',
  // Padding for larger touch area
  'px-4 py-2',
  // Spacing between adjacent buttons
  'gap-2'
)}>
  {children}
</Button>
```

### 6.2.7 Code Splitting Strategy (MAJ-UI-006)

**Purpose**: Achieve 100KB initial bundle target through strategic code splitting.

#### Dynamic Import Configuration

```typescript
// components/results/ResultsViewer.tsx

import dynamic from 'next/dynamic';
import { Skeleton } from '@/components/ui/skeleton';

// Lazy load heavy components
const MarkdownView = dynamic(
  () => import('./MarkdownView'),
  {
    loading: () => <Skeleton className="h-[400px]" />,
    ssr: true, // Enable server rendering
  }
);

const JsonView = dynamic(
  () => import('./JsonView'),
  {
    loading: () => <Skeleton className="h-[400px]" />,
    ssr: true,
  }
);

// Syntax highlighter (heavy dependency)
const SyntaxHighlighter = dynamic(
  () => import('@/components/ui/syntax-highlighter'),
  { ssr: false } // Client-only due to DOM requirements
);
```

#### Bundle Size Targets

| Bundle | Target | Contents |
|--------|--------|----------|
| Main | <50KB | Core React, layout, routing |
| Upload | <15KB | UploadZone, UrlInput, validation |
| Results | <25KB | Tabs, markdown rendering |
| History | <10KB | Table, pagination |

#### Optimization Techniques

```typescript
// next.config.ts

const config = {
  experimental: {
    optimizePackageImports: [
      'lucide-react',      // Tree-shake icons
      '@radix-ui/react-*', // Tree-shake Radix
      'date-fns',          // Tree-shake date functions
    ],
  },
};
```

### 6.2.8 Form Validation Timing (MAJ-UI-007)

**Purpose**: Specify validation behavior for optimal UX and accessibility.

```typescript
// components/upload/UrlInput.tsx - Validation timing

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const form = useForm<{ url: string }>({
  resolver: zodResolver(urlSchema),
  defaultValues: { url: '' },

  // Validation timing configuration (MAJ-UI-007)
  mode: 'onBlur',           // Initial validation on blur
  reValidateMode: 'onChange', // Re-validate on change after first error
  delayError: 300,          // Debounce error display by 300ms
});
```

#### Validation Timing Rules

| Event | Behavior | Rationale |
|-------|----------|-----------|
| onChange | No validation (initial) | Avoid interrupting typing |
| onBlur | Validate field | User finished editing |
| onChange (after error) | Re-validate | Immediate feedback on fixes |
| onSubmit | Validate all | Final validation before submit |

### 6.2.9 Optimistic UI Rollback Pattern (MAJ-UI-008)

**Purpose**: Specify rollback behavior when server validation fails after optimistic UI update.

```typescript
// hooks/useOptimisticUpload.ts

interface OptimisticState {
  status: 'idle' | 'optimistic' | 'confirmed' | 'rolled-back';
  data: Job | null;
  error: AppError | null;
}

export function useOptimisticUpload() {
  const [state, setState] = useState<OptimisticState>({
    status: 'idle',
    data: null,
    error: null,
  });

  const upload = async (file: File) => {
    // Optimistic update
    const optimisticJob: Job = {
      id: `temp-${Date.now()}`,
      status: 'UPLOADING',
      fileName: file.name,
      fileSize: file.size,
      // ...
    };

    setState({
      status: 'optimistic',
      data: optimisticJob,
      error: null,
    });

    try {
      const confirmedJob = await uploadFile(file);

      setState({
        status: 'confirmed',
        data: confirmedJob,
        error: null,
      });
    } catch (error) {
      // Rollback on error
      setState({
        status: 'rolled-back',
        data: null,
        error: error as AppError,
      });

      // Show rollback feedback
      toast.error('Upload failed', {
        description: (error as AppError).userMessage,
        action: {
          label: 'Retry',
          onClick: () => upload(file),
        },
      });
    }
  };

  return { state, upload };
}
```

#### Rollback Test Scenarios

| Scenario | Optimistic State | Server Response | Rollback Behavior |
|----------|------------------|-----------------|-------------------|
| File too large | Show uploading | 400 E001 | Clear file, show error |
| Invalid type | Show uploading | 400 E002 | Clear file, show error |
| Server error | Show uploading | 500 | Show retry option |
| Network error | Show uploading | No response | Show retry option |

### 6.2.10 SSE Event Out-of-Order Handling (MAJ-UI-009)

**Purpose**: Handle SSE events that arrive out of order due to network conditions.

```typescript
// hooks/useSSE.ts - Out-of-order event handling

interface ProgressState {
  lastEventId: string;
  lastPercent: number;
  lastTimestamp: number;
}

function handleProgressEvent(
  event: MessageEvent,
  state: ProgressState
): ProgressState | null {
  const data = JSON.parse(event.data);

  // Extract sequence from event ID (format: jobId-timestamp-sequence)
  const [, timestamp, sequence] = event.lastEventId.split('-');
  const eventTimestamp = parseInt(timestamp, 10);
  const eventSequence = parseInt(sequence, 10);

  // Reject events older than current state
  if (eventTimestamp < state.lastTimestamp) {
    console.warn('[SSE] Discarding out-of-order event:', event.lastEventId);
    return null;
  }

  // Reject events with lower sequence in same timestamp
  if (
    eventTimestamp === state.lastTimestamp &&
    eventSequence <= parseInt(state.lastEventId.split('-')[2], 10)
  ) {
    console.warn('[SSE] Discarding duplicate event:', event.lastEventId);
    return null;
  }

  // Never show backwards progress (MAJ-UI-002 related)
  if (data.percent < state.lastPercent) {
    console.warn('[SSE] Ignoring backwards progress:', data.percent);
    data.percent = state.lastPercent;
  }

  return {
    lastEventId: event.lastEventId,
    lastPercent: data.percent,
    lastTimestamp: eventTimestamp,
  };
}
```

### 6.2.11 Tab Content Preloading Strategy (MAJ-UI-005)

**Purpose**: Define whether result tabs are eagerly or lazily rendered.

**Configuration**:

```typescript
// components/results/ResultsViewer.tsx

const PRELOAD_STRATEGY = {
  // All tabs pre-rendered but hidden (better responsiveness, more memory)
  eager: {
    renderMode: 'all',
    visibility: 'hidden',
  },
  // Only active tab rendered (less memory, possible flicker on switch)
  lazy: {
    renderMode: 'active-only',
    visibility: 'visible',
  },
};

// Default: eager for better UX (results are already loaded)
const ACTIVE_STRATEGY = 'eager';

// Implementation
<Tabs defaultValue="markdown">
  <TabsList>
    {/* Tab triggers always rendered */}
  </TabsList>

  {ACTIVE_STRATEGY === 'eager' ? (
    // Eager: render all, control visibility
    <>
      <TabsContent value="markdown" forceMount className="data-[state=inactive]:hidden">
        <MarkdownView content={result.markdown} />
      </TabsContent>
      <TabsContent value="html" forceMount className="data-[state=inactive]:hidden">
        <HtmlView content={result.html} />
      </TabsContent>
      {/* ... */}
    </>
  ) : (
    // Lazy: render only active
    <>
      <TabsContent value="markdown">
        <MarkdownView content={result.markdown} />
      </TabsContent>
      <TabsContent value="html">
        <HtmlView content={result.html} />
      </TabsContent>
      {/* ... */}
    </>
  )}
</Tabs>
```

### 6.3 Custom Hooks Specifications

#### 6.3.1 useUpload Hook

```typescript
// hooks/useUpload.ts

interface UseUploadOptions {
  onSuccess?: (job: Job) => void;
  onError?: (error: AppError) => void;
}

interface UseUploadReturn {
  upload: (input: DocumentInput) => Promise<Job>;
  isUploading: boolean;
  progress: number;
  error: AppError | null;
}

export function useUpload(options?: UseUploadOptions): UseUploadReturn;
```

#### 6.3.2 useProcess Hook

```typescript
// hooks/useProcess.ts

interface UseProcessOptions {
  onProgress?: (progress: Progress) => void;
  onComplete?: (result: ProcessingResult) => void;
  onError?: (error: AppError) => void;
}

interface UseProcessReturn {
  process: (jobId: string) => Promise<void>;
  cancel: () => void;
  isProcessing: boolean;
  progress: Progress | null;
  error: AppError | null;
}

export function useProcess(options?: UseProcessOptions): UseProcessReturn;
```

#### 6.3.3 useSSE Hook

```typescript
// hooks/useSSE.ts

interface UseSSEOptions {
  maxRetries?: number;
  backoffBase?: number;
  backoffMax?: number;
  pollingInterval?: number;
}

interface UseSSEReturn {
  progress: Progress;
  connectionStatus: 'disconnected' | 'connected' | 'polling';
  error: Error | null;
  disconnect: () => void;
}

export function useSSE(jobId: string, options?: UseSSEOptions): UseSSEReturn;
```

#### 6.3.4 useDownload Hook

```typescript
// hooks/useDownload.ts

interface UseDownloadReturn {
  download: (content: string, format: ResultFormat, originalName: string) => void;
  isDownloading: boolean;
}

export function useDownload(): UseDownloadReturn;
```

#### 6.3.5 useHistory Hook

```typescript
// hooks/useHistory.ts

interface UseHistoryOptions {
  page?: number;
  pageSize?: number;
  sortBy?: 'createdAt' | 'status';
  sortOrder?: 'asc' | 'desc';
}

interface UseHistoryReturn {
  jobs: JobSummary[];
  pagination: PaginationInfo;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
}

export function useHistory(options?: UseHistoryOptions): UseHistoryReturn;
```

---

## 7. Integration Specifications

### 7.0 Architecture Overview (CRI-11)

**IMPORTANT**: This section clarifies the communication patterns to avoid confusion between MCP protocol and application-level SSE.

#### 7.0.1 Communication Patterns

The hx-docling-ui application uses TWO distinct communication patterns:

```
+------------------+                    +------------------+                    +-------------------------+
|                  |  HTTP/JSON-RPC     |                  |  HTTP/JSON-RPC     |                         |
|     Browser      | <--------------->  |   Next.js API    | <--------------->  |  hx-docling-mcp-server  |
|                  |                    |   (Route Handlers)|                    |  (MCP Protocol)         |
+------------------+                    +------------------+                    +-------------------------+
        |                                        |
        |  Application SSE                       |
        |  (progress updates)                    |
        +----------------------------------------+
```

**Pattern 1: Application-Level SSE (Browser to Next.js)**
- **Purpose**: Real-time progress updates to browser
- **Endpoint**: `GET /api/v1/process/{jobId}/events`
- **Direction**: Server-to-client (unidirectional)
- **Protocol**: Standard SSE (text/event-stream)
- **Content**: Progress events, completion events, error events

**Pattern 2: MCP Protocol (Next.js to hx-docling-mcp-server)**
- **Purpose**: Document processing tool invocation
- **Transport**: HTTP/JSON-RPC 2.0 (NOT SSE transport)
- **Direction**: Request-response (bidirectional)
- **Protocol**: MCP over HTTP (initialize, initialized notification, tools/call)
- **Content**: Tool invocations, DoclingDocument responses

**Key Distinction**:
- MCP protocol does NOT use SSE transport in this architecture
- Application SSE is completely separate from MCP protocol
- MCP server (hx-docling-mcp-server) does NOT stream responses to the browser
- Progress events are generated by Next.js API routes and published via Redis pub/sub

#### 7.0.2 Data Flow Diagram

```mermaid
sequenceDiagram
    participant Browser
    participant NextJS as Next.js API
    participant Redis
    participant MCP as hx-docling-mcp-server

    Note over Browser,MCP: Phase 1: Job Initiation
    Browser->>NextJS: POST /api/v1/process
    NextJS->>Redis: Create job record
    NextJS-->>Browser: { jobId, streamUrl }

    Note over Browser,MCP: Phase 2: SSE Connection (Application-level)
    Browser->>NextJS: GET /api/v1/process/{jobId}/events (SSE)
    NextJS->>Redis: Subscribe to job:{jobId}:progress

    Note over Browser,MCP: Phase 3: MCP Processing (HTTP/JSON-RPC)
    NextJS->>MCP: initialize { clientInfo, capabilities }
    MCP-->>NextJS: { serverInfo, capabilities }
    NextJS->>MCP: notifications/initialized
    NextJS->>MCP: tools/call { name: "convert_pdf", arguments }
    NextJS->>Redis: Publish progress (10%)
    Redis-->>NextJS: Progress event
    NextJS-->>Browser: SSE: event: progress

    MCP-->>NextJS: { DoclingDocument }
    NextJS->>Redis: Publish progress (80%)
    Redis-->>NextJS: Progress event
    NextJS-->>Browser: SSE: event: progress

    Note over Browser,MCP: Phase 4: Export (Parallel)
    NextJS->>MCP: tools/call { name: "export_markdown" }
    NextJS->>MCP: tools/call { name: "export_html" }
    NextJS->>MCP: tools/call { name: "export_json" }
    MCP-->>NextJS: { markdown content }
    MCP-->>NextJS: { html content }
    MCP-->>NextJS: { json content }

    NextJS->>Redis: Publish progress (100%)
    NextJS-->>Browser: SSE: event: complete
```

### 7.1 MCP Client Integration

**Reference**: [ARCH: 9.1], [PATTERN: 3-4]

#### 7.1.1 MCP Client Configuration

```typescript
// lib/mcp/client.ts

interface MCPClientConfig {
  endpoint: string;
  transport: 'http';  // HTTP/JSON-RPC only, NOT SSE transport
  timeout: number;
  retries: number;
  auth?: MCPAuthConfig;  // Optional authentication (MAJ-09)
}

// Authentication configuration (MAJ-09)
interface MCPAuthConfig {
  type: 'none' | 'bearer' | 'api-key';
  token?: string;       // For bearer token auth
  apiKey?: string;      // For API key auth
  headerName?: string;  // Custom header name (default: X-API-Key)
}

const DEFAULT_CONFIG: MCPClientConfig = {
  endpoint: process.env.DOCLING_MCP_ORIGIN || 'http://hx-docling-mcp-server.hx.dev.local:8000',
  transport: 'http',
  timeout: 300000,
  retries: 3,
  auth: {
    // hx-docling-mcp-server currently does NOT require authentication
    // for internal network access (Phase 1 - development server)
    type: 'none',
    // For production with authentication:
    // type: 'api-key',
    // apiKey: process.env.MCP_API_KEY,
    // headerName: 'X-API-Key',
  },
};
```

**Authentication Note (MAJ-09)**:
- **Phase 1 (Development)**: hx-docling-mcp-server on internal network does NOT require authentication
- **Production**: If authentication is required, use `api-key` type with `X-API-Key` header
- **Bearer Token**: If OAuth/JWT is used, use `bearer` type with `Authorization: Bearer {token}` header

#### 7.1.1.1 MCP Version Configuration (MAJ-MCP-001)

**Purpose**: Configure MCP protocol version via environment variable for flexibility.

```typescript
// Environment variable for MCP version
const MCP_PROTOCOL_VERSION = process.env.MCP_PROTOCOL_VERSION || '2024-11-05';

// Usage in initialization
const initRequest = {
  jsonrpc: '2.0',
  method: 'initialize',
  params: {
    protocolVersion: MCP_PROTOCOL_VERSION,
    clientInfo: { name: 'hx-docling-ui', version: '1.0.0' },
    capabilities: { tools: { listChanged: false } },
  },
  id: generateId(),
};
```

#### 7.1.1.2 Server Capabilities Validation (MAJ-MCP-002)

**Purpose**: Validate server capabilities after initialization to ensure required features are supported.

```typescript
// lib/mcp/capabilities.ts

interface MCPServerCapabilities {
  tools?: {
    listChanged?: boolean;
  };
  prompts?: {
    listChanged?: boolean;
  };
  resources?: {
    subscribe?: boolean;
    listChanged?: boolean;
  };
  logging?: {};
}

interface ServerInfo {
  name: string;
  version: string;
}

interface InitializeResponse {
  protocolVersion: string;
  serverInfo: ServerInfo;
  capabilities: MCPServerCapabilities;
}

export function validateServerCapabilities(response: InitializeResponse): MCPServerCapabilities {
  // Verify server supports tools capability (required)
  if (!response.capabilities.tools) {
    throw new MCPError(
      'E205',
      'MCP server does not support tools capability'
    );
  }

  // Log server information for debugging
  console.log(`[MCP] Connected to ${response.serverInfo.name} v${response.serverInfo.version}`);
  console.log(`[MCP] Protocol version: ${response.protocolVersion}`);

  // Store capabilities for later use
  return response.capabilities;
}

// Updated MCPClient with capability validation
class MCPClient {
  private serverCapabilities: MCPServerCapabilities | null = null;

  async initialize(): Promise<void> {
    if (this.initialized) return;

    const initResponse = await this.request({
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        protocolVersion: MCP_PROTOCOL_VERSION,
        clientInfo: { name: 'hx-docling-ui', version: '1.0.0' },
        capabilities: { tools: { listChanged: false } },
      },
      id: generateId(),
    });

    // Validate and store server capabilities
    this.serverCapabilities = validateServerCapabilities(initResponse.result);

    // Continue with initialized notification...
  }

  hasCapability(capability: keyof MCPServerCapabilities): boolean {
    return this.serverCapabilities?.[capability] !== undefined;
  }
}
```

#### 7.1.1.3 Transport Configuration Clarification (MAJ-MCP-003)

**Purpose**: Clarify that MCP transport is always HTTP/JSON-RPC; the `enableProgressStream` option controls application-level SSE for progress.

```typescript
interface MCPClientConfig {
  endpoint: string;
  timeout: number;
  retries: number;
  auth?: MCPAuthConfig;

  // Progress streaming configuration (application-level, NOT MCP SSE transport)
  enableProgressStream: boolean;  // Default: true
  progressStreamEndpoint?: string;
}

const DEFAULT_CONFIG: MCPClientConfig = {
  endpoint: process.env.DOCLING_MCP_ORIGIN || 'http://hx-docling-mcp-server.hx.dev.local:8000',
  timeout: 300000,
  retries: 3,
  auth: { type: 'none' },
  enableProgressStream: true,  // Enable application SSE for progress updates
};
```

**Clarification**:
- MCP communication is always HTTP/JSON-RPC (request-response)
- `enableProgressStream` controls whether the application publishes progress via Redis -> SSE
- The MCP server does NOT stream responses; it returns complete DoclingDocument on success

#### 7.1.2 MCP Initialization Sequence

**Reference**: [ARCH: 9.1.1], [PATTERN: 4.3]

```mermaid
sequenceDiagram
    participant App as hx-docling-ui
    participant MCP as hx-docling-mcp-server

    App->>MCP: initialize { clientInfo, capabilities }
    MCP-->>App: { serverInfo, capabilities }
    App->>MCP: initialized (notification)
    Note over MCP: Server ready for tool calls
    App->>MCP: tools/list
    MCP-->>App: { tools: [...] }
    Note over App: Cache tool schemas
    App->>MCP: tools/call { name, arguments }
    MCP-->>App: { result | error }
```

**IMPORTANT**: Per MCP protocol specification, the `initialized` notification MUST be sent after receiving the `initialize` response and BEFORE invoking any tools. Failure to send this notification may cause the MCP server to reject tool calls.

**Implementation**:
```typescript
class MCPClient {
  private initialized = false;
  private toolRegistry: Map<string, MCPTool> = new Map();

  async initialize(): Promise<void> {
    if (this.initialized) return;

    // Step 1: Capability negotiation (request)
    const initResponse = await this.request({
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        clientInfo: { name: 'hx-docling-ui', version: '1.0.0' },
        capabilities: { tools: { listChanged: false } },
      },
      id: generateId(),
    });

    // Step 2: Send initialized notification (REQUIRED by MCP protocol)
    // This is a notification (no id), not a request
    await this.notify({
      jsonrpc: '2.0',
      method: 'notifications/initialized',
      params: {},
    });

    // Step 3: Tool discovery
    const toolsResponse = await this.request({
      jsonrpc: '2.0',
      method: 'tools/list',
      id: generateId(),
    });

    // Step 4: Cache schemas
    for (const tool of toolsResponse.tools) {
      this.toolRegistry.set(tool.name, tool);
    }

    this.initialized = true;
  }

  // Helper for notifications (no response expected)
  private async notify(message: JsonRpcNotification): Promise<void> {
    await fetch(this.endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message),
    });
    // No response expected for notifications
  }

  async invoke(toolName: string, params: unknown): Promise<unknown> {
    if (!this.initialized) await this.initialize();

    const tool = this.toolRegistry.get(toolName);
    if (!tool) throw new MCPError('E204', `Unknown tool: ${toolName}`);

    return this.request({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: { name: toolName, arguments: params },
      id: generateId(),
    });
  }
}
```

#### 7.1.3 Tool Parameter Schemas

**Reference**: [ARCH: 9.1.3]

```typescript
// lib/mcp/schemas.ts

const FilePathSchema = z.object({
  file_path: z.string().min(1),
  options: z.object({}).passthrough().optional(),
});

const UrlSchema = z.object({
  url: z.string().url(),
  options: z.object({}).passthrough().optional(),
});

const ExportSchema = z.object({
  document: z.object({}).passthrough(),
  options: z.object({}).passthrough().optional(),
});

export const TOOL_SCHEMAS: Record<string, z.ZodSchema> = {
  'convert_pdf': FilePathSchema,
  'convert_docx': FilePathSchema,
  'convert_xlsx': FilePathSchema,
  'convert_pptx': FilePathSchema,
  'convert_url': UrlSchema,
  'export_markdown': ExportSchema,
  'export_html': ExportSchema,
  'export_json': ExportSchema,
};

// DoclingDocument Schema (MAJ-16)
// Explicit validation instead of z.object({}).passthrough()
const DoclingDocumentSchema = z.object({
  schema_name: z.string(),
  version: z.string(),
  name: z.string(),
  origin: z.object({
    mimetype: z.string().optional(),
    filename: z.string().optional(),
    uri: z.string().optional(),
  }).optional(),
  furniture: z.object({
    self_ref: z.string(),
    children: z.array(z.any()),
    content_text: z.string().optional(),
  }).optional(),
  body: z.object({
    self_ref: z.string(),
    children: z.array(z.any()),
    content_text: z.string().optional(),
  }).optional(),
  groups: z.array(z.any()).optional(),
  pictures: z.array(z.any()).optional(),
  tables: z.array(z.any()).optional(),
  key_value_items: z.array(z.any()).optional(),
  pages: z.record(z.any()).optional(),
}).passthrough(); // Allow additional fields from MCP server

// Updated ExportSchema using DoclingDocumentSchema
const ExportSchemaStrict = z.object({
  document: DoclingDocumentSchema,
  options: z.object({}).passthrough().optional(),
});
```

#### 7.1.4 MCP Error Code Mapping

MCP uses JSON-RPC 2.0 standard error codes, while the application uses custom error codes. This section defines the mapping between the two systems.

**JSON-RPC 2.0 Standard Error Codes** (from MCP):

| Code | Name | Description |
|------|------|-------------|
| -32700 | Parse Error | Invalid JSON received |
| -32600 | Invalid Request | JSON is not a valid request |
| -32601 | Method Not Found | Method/tool does not exist |
| -32602 | Invalid Params | Invalid method parameters |
| -32603 | Internal Error | Internal JSON-RPC error |
| -32000 to -32099 | Server Error | Server-defined errors |

**MCP to Application Error Mapping**:

```typescript
// lib/mcp/error-mapping.ts

interface MCPErrorMapping {
  mcpCode: number;
  appCode: string;
  userMessage: string;
  retryable: boolean;
}

const MCP_ERROR_MAP: Record<number, MCPErrorMapping> = {
  // JSON-RPC standard errors
  [-32700]: { appCode: 'E203', userMessage: 'Invalid request format', retryable: false },
  [-32600]: { appCode: 'E203', userMessage: 'Invalid request format', retryable: false },
  [-32601]: { appCode: 'E204', userMessage: 'Requested tool not available', retryable: false },
  [-32602]: { appCode: 'E203', userMessage: 'Invalid parameters', retryable: false },
  [-32603]: { appCode: 'E201', userMessage: 'Processing service error', retryable: true },

  // MCP server-specific errors (-32000 range)
  [-32000]: { appCode: 'E201', userMessage: 'Processing service unavailable', retryable: true },
  [-32001]: { appCode: 'E202', userMessage: 'Request timeout', retryable: true },
  [-32002]: { appCode: 'E302', userMessage: 'Document conversion failed', retryable: true },
  [-32003]: { appCode: 'E303', userMessage: 'Export generation failed', retryable: true },
};

export function mapMCPError(mcpError: JsonRpcError): AppError {
  const mapping = MCP_ERROR_MAP[mcpError.code];

  if (mapping) {
    return {
      code: mapping.appCode,
      message: mcpError.message,
      userMessage: mapping.userMessage,
      suggestedAction: mapping.retryable ? 'Try again' : 'Contact support',
      retryable: mapping.retryable,
      originalMCPCode: mcpError.code, // Preserve for debugging
    };
  }

  // Default mapping for unknown errors
  return {
    code: 'E201',
    message: mcpError.message,
    userMessage: 'An unexpected error occurred',
    suggestedAction: 'Try again later',
    retryable: true,
    originalMCPCode: mcpError.code,
  };
}
```

**Error Response Structure** (includes both code systems):

```typescript
interface ErrorResponse {
  // Application error code (for UI display)
  code: string;
  message: string;
  userMessage: string;
  suggestedAction: string;
  retryable: boolean;

  // Original MCP error (for debugging)
  originalMCPCode?: number;
  originalMCPMessage?: string;
}
```

### 7.2 SSE Streaming Integration

**Reference**: [ARCH: 9.2], [CHARTER: 6.8]

#### 7.2.1 Two-Endpoint SSE Pattern

**POST /api/v1/process** - Job initiation:
```typescript
export async function POST(request: Request) {
  const { jobId } = await request.json();

  await prisma.job.update({
    where: { id: jobId },
    data: { status: 'PROCESSING' },
  });

  // Start async processing
  processJobAsync(jobId);

  return NextResponse.json({
    jobId,
    streamUrl: `/api/v1/process/${jobId}/events`,
  });
}
```

**GET /api/v1/process/{jobId}/events** - SSE subscription:
```typescript
export async function GET(
  request: Request,
  { params }: { params: { jobId: string } }
) {
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder();

      // Send connected event
      controller.enqueue(
        encoder.encode('event: connected\ndata: {}\n\n')
      );

      // Subscribe to job updates
      for await (const update of subscribeToJob(params.jobId)) {
        if (update.type === 'progress') {
          controller.enqueue(
            encoder.encode(`event: progress\ndata: ${JSON.stringify(update)}\n\n`)
          );
        } else if (update.type === 'complete') {
          controller.enqueue(
            encoder.encode(`event: complete\ndata: ${JSON.stringify(update)}\n\n`)
          );
          break;
        }
      }

      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

### 7.3 PostgreSQL Integration

**Reference**: [ARCH: 8.1], [CHARTER: 12.5]

#### 7.3.1 Prisma Client Singleton

```typescript
// lib/db/prisma.ts

import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development'
      ? ['query', 'error', 'warn']
      : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

#### 7.3.2 Connection Configuration

```env
# Via PgBouncer (application)
DATABASE_URL=postgresql://docling_user:${DB_PASSWORD}@hx-postgres-server.hx.dev.local:6432/docling_db?connection_limit=5&pool_timeout=20&sslmode=verify-full&sslrootcert=/etc/docling/ssl/ca.crt

# Direct (migrations only)
DIRECT_DATABASE_URL=postgresql://docling_migration:${MIGRATION_PASSWORD}@hx-postgres-server.hx.dev.local:5432/docling_db?sslmode=verify-full
```

### 7.4 Redis Integration

**Reference**: [ARCH: 9.4], [CHARTER: 7.4]

#### 7.4.1 Redis Client Configuration

```typescript
// lib/redis/client.ts

import Redis from 'ioredis';
import fs from 'fs';

// TLS configuration for production (CRI-06)
const tlsConfig = process.env.REDIS_TLS_ENABLED === 'true' ? {
  tls: {
    rejectUnauthorized: true,
    ca: fs.readFileSync(process.env.REDIS_CA_CERT_PATH || '/etc/docling/ssl/redis-ca.crt'),
    // Optional client certificate authentication
    cert: process.env.REDIS_CLIENT_CERT_PATH
      ? fs.readFileSync(process.env.REDIS_CLIENT_CERT_PATH)
      : undefined,
    key: process.env.REDIS_CLIENT_KEY_PATH
      ? fs.readFileSync(process.env.REDIS_CLIENT_KEY_PATH)
      : undefined,
  },
} : {};

const redisConfig = {
  host: process.env.REDIS_HOST || 'hx-redis-server.hx.dev.local',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  db: 0,
  maxRetriesPerRequest: 3,
  keepAlive: 30000,
  connectTimeout: 10000,
  commandTimeout: 5000,
  // Retry strategy for resilience
  retryStrategy: (times: number) => {
    if (times > 10) return null; // Stop retrying after 10 attempts
    return Math.min(times * 100, 3000); // Exponential backoff, max 3s
  },
  ...tlsConfig,
};

const globalForRedis = globalThis as unknown as {
  redis: Redis | undefined;
};

export const redis =
  globalForRedis.redis ?? new Redis(redisConfig);

if (process.env.NODE_ENV !== 'production') {
  globalForRedis.redis = redis;
}
```

**Environment Variables for Redis TLS**:
```env
# Redis TLS Configuration
REDIS_TLS_ENABLED=true
REDIS_CA_CERT_PATH=/etc/docling/ssl/redis-ca.crt
REDIS_CLIENT_CERT_PATH=/etc/docling/ssl/redis-client.crt  # Optional
REDIS_CLIENT_KEY_PATH=/etc/docling/ssl/redis-client.key   # Optional
# Use rediss:// scheme for TLS connections
REDIS_URL=rediss://:${REDIS_PASSWORD}@hx-redis-server.hx.dev.local:6379/0
```

#### 7.4.2 Rate Limiting Implementation (Sliding Window)

**IMPORTANT**: This implementation uses a sliding window algorithm (per Charter 8.1.1) to prevent burst attacks at window boundaries. The previous fixed-window approach was vulnerable to burst attacks.

```typescript
// lib/redis/rate-limit.ts

const RATE_LIMIT_MAX = 10;
const RATE_LIMIT_WINDOW_SECONDS = 60;

// Lua script for atomic sliding window rate limiting (CRI-04, CRI-07)
// This prevents race conditions and ensures atomicity
const SLIDING_WINDOW_SCRIPT = `
local key = KEYS[1]
local now = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local limit = tonumber(ARGV[3])

-- Remove entries outside the window
redis.call('ZREMRANGEBYSCORE', key, 0, now - window)

-- Count current requests in window
local count = redis.call('ZCARD', key)

if count < limit then
  -- Add new request with current timestamp as score
  redis.call('ZADD', key, now, now .. '-' .. math.random())
  -- Set expiry on the key (cleanup)
  redis.call('EXPIRE', key, window)
  return {1, limit - count - 1, 0}  -- allowed, remaining, retryAfter
else
  -- Get oldest entry to calculate retry time
  local oldest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
  local retryAfter = oldest[2] and (window - (now - oldest[2])) or window
  return {0, 0, math.ceil(retryAfter)}  -- denied, remaining, retryAfter
end
`;

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  retryAfter?: number;
}

export async function checkRateLimit(sessionId: string): Promise<RateLimitResult> {
  const key = `hx-docling:rate:${sessionId}`;
  const now = Math.floor(Date.now() / 1000); // Current time in seconds

  try {
    const result = await redis.eval(
      SLIDING_WINDOW_SCRIPT,
      1,                        // Number of keys
      key,                      // KEYS[1]
      now,                      // ARGV[1]: current timestamp
      RATE_LIMIT_WINDOW_SECONDS, // ARGV[2]: window size
      RATE_LIMIT_MAX            // ARGV[3]: limit
    ) as [number, number, number];

    const [allowed, remaining, retryAfter] = result;

    return {
      allowed: allowed === 1,
      remaining,
      retryAfter: retryAfter > 0 ? retryAfter : undefined,
    };
  } catch (error) {
    // Fallback behavior on Redis error (see circuit breaker below)
    throw new RedisError('Rate limit check failed', error);
  }
}
```

#### 7.4.3 Redis Circuit Breaker (CRI-05)

**Purpose**: Provides graceful degradation when Redis is unavailable, preventing cascading failures.

```typescript
// lib/redis/circuit-breaker.ts

interface CircuitBreakerState {
  state: 'closed' | 'open' | 'half-open';
  failureCount: number;
  lastFailureTime: number;
  successCount: number;
}

interface CircuitBreakerConfig {
  failureThreshold: number;      // Failures before opening circuit
  resetTimeout: number;          // Time in ms before trying half-open
  successThreshold: number;      // Successes needed to close from half-open
}

const DEFAULT_CONFIG: CircuitBreakerConfig = {
  failureThreshold: 5,
  resetTimeout: 30000,  // 30 seconds
  successThreshold: 3,
};

class RedisCircuitBreaker {
  private state: CircuitBreakerState = {
    state: 'closed',
    failureCount: 0,
    lastFailureTime: 0,
    successCount: 0,
  };

  constructor(private config: CircuitBreakerConfig = DEFAULT_CONFIG) {}

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state.state === 'open') {
      if (Date.now() - this.state.lastFailureTime > this.config.resetTimeout) {
        this.state.state = 'half-open';
        this.state.successCount = 0;
      } else {
        throw new CircuitOpenError('Redis circuit breaker is open');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    if (this.state.state === 'half-open') {
      this.state.successCount++;
      if (this.state.successCount >= this.config.successThreshold) {
        this.state.state = 'closed';
        this.state.failureCount = 0;
      }
    } else {
      this.state.failureCount = 0;
    }
  }

  private onFailure(): void {
    this.state.failureCount++;
    this.state.lastFailureTime = Date.now();

    if (this.state.failureCount >= this.config.failureThreshold) {
      this.state.state = 'open';
    }
  }

  getState(): CircuitBreakerState {
    return { ...this.state };
  }
}

export const redisCircuitBreaker = new RedisCircuitBreaker();

// Fallback strategies when circuit is open
export enum FallbackStrategy {
  FAIL_FAST = 'fail-fast',           // Return 503 immediately
  ALLOW_ALL = 'allow-all',           // Skip rate limiting (risky)
  IN_MEMORY = 'in-memory',           // Use in-memory rate limiting
}

export async function checkRateLimitWithFallback(
  sessionId: string,
  fallbackStrategy: FallbackStrategy = FallbackStrategy.IN_MEMORY
): Promise<RateLimitResult> {
  try {
    return await redisCircuitBreaker.execute(() => checkRateLimit(sessionId));
  } catch (error) {
    if (error instanceof CircuitOpenError) {
      switch (fallbackStrategy) {
        case FallbackStrategy.FAIL_FAST:
          throw new ServiceUnavailableError('Rate limiting service unavailable');
        case FallbackStrategy.ALLOW_ALL:
          return { allowed: true, remaining: RATE_LIMIT_MAX };
        case FallbackStrategy.IN_MEMORY:
          return checkInMemoryRateLimit(sessionId);
      }
    }
    throw error;
  }
}

// In-memory fallback (single instance only)
const inMemoryLimits = new Map<string, { count: number; windowStart: number }>();

function checkInMemoryRateLimit(sessionId: string): RateLimitResult {
  const now = Math.floor(Date.now() / 1000);
  const key = sessionId;
  const entry = inMemoryLimits.get(key);

  if (!entry || now - entry.windowStart > RATE_LIMIT_WINDOW_SECONDS) {
    inMemoryLimits.set(key, { count: 1, windowStart: now });
    return { allowed: true, remaining: RATE_LIMIT_MAX - 1 };
  }

  if (entry.count >= RATE_LIMIT_MAX) {
    return {
      allowed: false,
      remaining: 0,
      retryAfter: RATE_LIMIT_WINDOW_SECONDS - (now - entry.windowStart),
    };
  }

  entry.count++;
  return { allowed: true, remaining: RATE_LIMIT_MAX - entry.count };
}
```

#### 7.4.4 Redis Health Check

```typescript
// lib/redis/health.ts

interface RedisHealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  latency: number;
  details: {
    pingOk: boolean;
    pingLatency: number;
    memoryUsagePercent?: number;
    connectedClients?: number;
    evictedKeys?: number;
  };
}

const HEALTH_THRESHOLDS = {
  pingLatencyMs: 100,        // PING response time threshold
  memoryUsagePercent: 75,    // Memory usage warning threshold
};

export async function checkRedisHealth(): Promise<RedisHealthStatus> {
  const start = Date.now();

  try {
    // PING check
    await redis.ping();
    const pingLatency = Date.now() - start;

    // INFO stats for deeper health check
    const info = await redis.info('memory');
    const memoryInfo = parseRedisInfo(info);
    const memoryUsagePercent = memoryInfo.used_memory / memoryInfo.maxmemory * 100;

    const statsInfo = await redis.info('stats');
    const stats = parseRedisInfo(statsInfo);

    const details = {
      pingOk: true,
      pingLatency,
      memoryUsagePercent,
      connectedClients: stats.connected_clients,
      evictedKeys: stats.evicted_keys,
    };

    // Determine status
    if (pingLatency > HEALTH_THRESHOLDS.pingLatencyMs) {
      return { status: 'degraded', latency: pingLatency, details };
    }
    if (memoryUsagePercent > HEALTH_THRESHOLDS.memoryUsagePercent) {
      return { status: 'degraded', latency: pingLatency, details };
    }

    return { status: 'healthy', latency: pingLatency, details };
  } catch (error) {
    return {
      status: 'unhealthy',
      latency: Date.now() - start,
      details: { pingOk: false, pingLatency: -1 },
    };
  }
}
```

#### 7.4.5 Session CRUD Operations

```typescript
// lib/redis/session.ts

import { redis } from './client';

interface Session {
  id: string;
  createdAt: number;
  lastActivity: number;
  jobCount: number;
  activeJobIds: string[];  // Changed from activeJobId to support multiple tabs (MAJ-12)
}

const SESSION_TTL = 86400; // 24 hours

export async function createSession(sessionId: string): Promise<Session> {
  const session: Session = {
    id: sessionId,
    createdAt: Math.floor(Date.now() / 1000),
    lastActivity: Math.floor(Date.now() / 1000),
    jobCount: 0,
    activeJobIds: [],
  };

  const key = `hx-docling:session:${sessionId}`;

  // Use HSET for hash storage (more efficient than JSON string)
  await redis.multi()
    .hset(key, {
      id: session.id,
      createdAt: session.createdAt.toString(),
      lastActivity: session.lastActivity.toString(),
      jobCount: session.jobCount.toString(),
      activeJobIds: JSON.stringify(session.activeJobIds),
    })
    .expire(key, SESSION_TTL)
    .exec();

  return session;
}

export async function getSession(sessionId: string): Promise<Session | null> {
  const key = `hx-docling:session:${sessionId}`;
  const data = await redis.hgetall(key);

  if (!data || Object.keys(data).length === 0) {
    return null;
  }

  return {
    id: data.id,
    createdAt: parseInt(data.createdAt, 10),
    lastActivity: parseInt(data.lastActivity, 10),
    jobCount: parseInt(data.jobCount, 10),
    activeJobIds: JSON.parse(data.activeJobIds || '[]'),
  };
}

export async function updateSessionActivity(sessionId: string): Promise<void> {
  const key = `hx-docling:session:${sessionId}`;
  const now = Math.floor(Date.now() / 1000);

  // Update lastActivity and reset TTL (sliding expiration)
  await redis.multi()
    .hset(key, 'lastActivity', now.toString())
    .expire(key, SESSION_TTL)
    .exec();
}

export async function deleteSession(sessionId: string): Promise<void> {
  const key = `hx-docling:session:${sessionId}`;
  await redis.del(key);
}
```

---

## 8. Security Specifications

### 8.1 Input Validation

**Reference**: [CHARTER: 11.2], [ARCH: 10.3]

#### 8.1.1 File Validation Schema

```typescript
// lib/validation/file.ts

import { z } from 'zod';

export const fileSchema = z.object({
  name: z.string().min(1).refine(
    (name) => ALLOWED_EXTENSIONS.some(ext => name.toLowerCase().endsWith(ext)),
    { message: 'Unsupported file extension' }
  ),
  size: z.number()
    .max(100 * 1024 * 1024, 'File must be under 100 MB'),
  type: z.enum([
    'application/pdf',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-excel',
    'image/png',
    'image/jpeg',
    'image/tiff',
  ]),
});

const ALLOWED_EXTENSIONS = [
  '.pdf',
  '.doc', '.docx',
  '.ppt', '.pptx',
  '.xls', '.xlsx',
  '.png', '.jpg', '.jpeg', '.tiff',
];
```

#### 8.1.2 URL Validation Schema

```typescript
// lib/validation/url.ts

import { z } from 'zod';

export const urlSchema = z.string()
  .url({ message: 'Invalid URL format' })
  .max(2048, { message: 'URL too long (max 2048 characters)' })
  .refine(url => {
    const parsed = new URL(url);

    // Protocol check
    if (!['http:', 'https:'].includes(parsed.protocol)) {
      return false;
    }

    const hostname = parsed.hostname.toLowerCase();

    // Block localhost
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return false;
    }

    // Block private IP ranges
    const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (ipv4Pattern.test(hostname)) {
      const parts = hostname.split('.').map(Number);
      if (parts[0] === 10) return false;
      if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return false;
      if (parts[0] === 192 && parts[1] === 168) return false;
      if (parts[0] === 169 && parts[1] === 254) return false;
    }

    // Block internal domains
    if (hostname.endsWith('.hx.dev.local')) {
      return false;
    }

    return true;
  }, { message: 'URL not allowed (internal or private address)' });
```

### 8.2 Content Security Policy

**Reference**: [CHARTER: 6.4]

```typescript
// next.config.ts headers

{
  key: 'Content-Security-Policy',
  value: [
    "default-src 'self'",
    "script-src 'self'",
    "style-src 'self' 'unsafe-inline'",
    "img-src 'self' data: blob:",
    "connect-src 'self' http://hx-docling-mcp-server.hx.dev.local:8000",
    "font-src 'self'",
    "object-src 'none'",
    "frame-ancestors 'none'",
    "base-uri 'self'",
    "form-action 'self'",
  ].join('; '),
}
```

### 8.3 Security Headers

```typescript
// next.config.ts headers

const securityHeaders = [
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'X-Frame-Options', value: 'DENY' },
  { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
  { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
  { key: 'Cross-Origin-Resource-Policy', value: 'same-origin' },
];
```

### 8.4 Rate Limiting Headers

```typescript
// Rate limit response headers (RFC 9238)

const rateLimitHeaders = {
  'X-RateLimit-Limit': '10',
  'X-RateLimit-Remaining': String(remaining),
  'X-RateLimit-Reset': String(Math.floor(Date.now() / 1000) + retryAfter),
  'RateLimit-Limit': '10',
  'RateLimit-Remaining': String(remaining),
  'RateLimit-Reset': String(retryAfter),
  'Retry-After': String(retryAfter),
};
```

---

## 9. Accessibility Specifications

### 9.1 WCAG 2.1 AA Requirements

**Reference**: [CHARTER: 10.1], [ARCH: 5.2.2]

#### 9.1.1 Perceivable

| Criterion | Requirement | Implementation |
|-----------|-------------|----------------|
| 1.1.1 Non-text Content | All images have alt text | `alt` attribute on all `<img>` |
| 1.3.1 Info and Relationships | Semantic HTML structure | Proper heading hierarchy |
| 1.4.1 Use of Color | Color not sole indicator | Icons + text for status |
| 1.4.3 Contrast (Minimum) | 4.5:1 ratio | Tailwind color palette validated |
| 1.4.11 Non-text Contrast | 3:1 ratio for UI | Focus rings, borders |

#### 9.1.2 Operable

| Criterion | Requirement | Implementation |
|-----------|-------------|----------------|
| 2.1.1 Keyboard | All functions keyboard accessible | Tab order, focus management |
| 2.1.2 No Keyboard Trap | No focus traps | Modal escape, focus return |
| 2.4.3 Focus Order | Logical focus order | DOM order matches visual |
| 2.4.7 Focus Visible | Visible focus indicator | `focus-visible` ring |

#### 9.1.3 Understandable

| Criterion | Requirement | Implementation |
|-----------|-------------|----------------|
| 3.1.1 Language of Page | `lang` attribute | `<html lang="en">` |
| 3.2.1 On Focus | No context change on focus | No auto-submit |
| 3.3.1 Error Identification | Errors clearly identified | Error codes + messages |
| 3.3.2 Labels or Instructions | Form inputs labeled | `<label>` elements |

#### 9.1.4 Robust

| Criterion | Requirement | Implementation |
|-----------|-------------|----------------|
| 4.1.1 Parsing | Valid HTML | ESLint jsx-a11y rules |
| 4.1.2 Name, Role, Value | ARIA attributes | shadcn/ui built-in |

### 9.2 ARIA Implementation

#### 9.2.1 Progress Indicator

```typescript
<div
  role="progressbar"
  aria-valuenow={percent}
  aria-valuemin={0}
  aria-valuemax={100}
  aria-label={`Document processing: ${message}`}
  aria-live="polite"
>
  <Progress value={percent} />
  <span className="sr-only">{message}</span>
</div>
```

#### 9.2.2 Tab Navigation

```typescript
<Tabs defaultValue="markdown">
  <TabsList role="tablist" aria-label="Result formats">
    <TabsTrigger
      value="markdown"
      role="tab"
      aria-selected={activeTab === 'markdown'}
      aria-controls="panel-markdown"
    >
      Markdown
    </TabsTrigger>
    {/* ... more tabs */}
  </TabsList>
  <TabsContent
    value="markdown"
    role="tabpanel"
    id="panel-markdown"
    aria-labelledby="tab-markdown"
  >
    {/* content */}
  </TabsContent>
</Tabs>
```

#### 9.2.3 Error Announcements

```typescript
<div
  role="alert"
  aria-live="assertive"
  aria-atomic="true"
>
  <AlertCircle aria-hidden="true" />
  <span>Error {error.code}: {error.message}</span>
</div>
```

### 9.3 Keyboard Navigation

**Reference**: [CHARTER: 10.4]

| Shortcut | Action | Context |
|----------|--------|---------|
| Tab | Navigate between elements | Global |
| Enter/Space | Activate button/link | Focused element |
| Escape | Close modal/dismiss | Modal/toast |
| Arrow Up/Down | Navigate list items | History list |
| Arrow Left/Right | Switch tabs | Results tabs |
| Ctrl/Cmd+Enter | Process document | Input focused |
| Ctrl/Cmd+Shift+D | Download results | Results visible |

### 9.4 Screen Reader Announcement Strategy (MAJ-A11Y-001)

**Purpose**: Define debouncing strategy for progress announcements to avoid overwhelming screen reader users.

#### Announcement Debouncing

```typescript
// hooks/useA11yAnnouncer.ts

interface AnnouncerConfig {
  minIntervalMs: number;      // Minimum time between announcements
  maxQueueSize: number;       // Maximum queued announcements
  politeness: 'polite' | 'assertive';
}

const DEFAULT_CONFIG: AnnouncerConfig = {
  minIntervalMs: 500,         // 500ms minimum between progress updates
  maxQueueSize: 3,
  politeness: 'polite',
};

export function useA11yAnnouncer(config = DEFAULT_CONFIG) {
  const lastAnnounceTime = useRef(0);
  const pendingAnnouncement = useRef<string | null>(null);

  const announce = useCallback((message: string, urgent = false) => {
    const now = Date.now();
    const timeSinceLast = now - lastAnnounceTime.current;

    if (urgent) {
      // Immediate announcement for errors
      announceToScreenReader(message, 'assertive');
      lastAnnounceTime.current = now;
      pendingAnnouncement.current = null;
      return;
    }

    if (timeSinceLast >= config.minIntervalMs) {
      // Safe to announce immediately
      announceToScreenReader(message, config.politeness);
      lastAnnounceTime.current = now;
      pendingAnnouncement.current = null;
    } else {
      // Queue for later (debounce)
      pendingAnnouncement.current = message;

      // Schedule announcement for when interval has passed
      setTimeout(() => {
        if (pendingAnnouncement.current === message) {
          announceToScreenReader(message, config.politeness);
          lastAnnounceTime.current = Date.now();
          pendingAnnouncement.current = null;
        }
      }, config.minIntervalMs - timeSinceLast);
    }
  }, [config]);

  return { announce };
}

function announceToScreenReader(
  message: string,
  politeness: 'polite' | 'assertive'
): void {
  const announcer = document.getElementById('a11y-announcer');
  if (!announcer) return;

  // Clear and reset (forces screen reader to announce)
  announcer.textContent = '';

  // Use requestAnimationFrame to ensure DOM update
  requestAnimationFrame(() => {
    announcer.setAttribute('aria-live', politeness);
    announcer.textContent = message;
  });
}
```

#### Announcement Patterns

| Event | Announcement | Priority | Debounce |
|-------|--------------|----------|----------|
| Processing started | "Processing document: {filename}" | polite | No |
| Progress update | "{percent}% complete" | polite | 500ms |
| Stage change | "Stage: {stage}" | polite | No |
| Completion | "Processing complete" | polite | No |
| Error | "Error: {message}" | assertive | No |
| Reconnecting | "Reconnecting..." | polite | No |

#### Screen Reader Live Region

```tsx
// components/layout/A11yAnnouncer.tsx

export function A11yAnnouncer() {
  return (
    <>
      {/* Polite announcements (progress) */}
      <div
        id="a11y-announcer"
        role="status"
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      />

      {/* Assertive announcements (errors) */}
      <div
        id="a11y-assertive-announcer"
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
        className="sr-only"
      />
    </>
  );
}
```

### 9.5 Focus Management Patterns (MAJ-A11Y-002)

**Purpose**: Define focus management for all interactive scenarios.

#### Focus Restoration Rules

| Scenario | Focus Destination |
|----------|-------------------|
| Modal close | Element that opened the modal |
| Toast dismiss | No focus change (non-blocking) |
| Tab content change | First focusable element in new tab content |
| File upload success | Process button |
| Processing complete | First result tab |
| Error display | Error message (assertive) then retry button |
| SSE reconnection | No focus change |

#### Focus Management Implementation

```typescript
// hooks/useFocusManagement.ts

import { useRef, useCallback } from 'react';

export function useFocusManagement() {
  const focusStack = useRef<HTMLElement[]>([]);

  const pushFocus = useCallback((element: HTMLElement) => {
    // Save current focused element
    if (document.activeElement instanceof HTMLElement) {
      focusStack.current.push(document.activeElement);
    }
    // Focus new element
    element.focus();
  }, []);

  const popFocus = useCallback(() => {
    const previous = focusStack.current.pop();
    if (previous && document.body.contains(previous)) {
      previous.focus();
    }
  }, []);

  const focusFirstError = useCallback(() => {
    const firstError = document.querySelector('[aria-invalid="true"]');
    if (firstError instanceof HTMLElement) {
      firstError.focus();
    }
  }, []);

  return { pushFocus, popFocus, focusFirstError };
}
```

#### Modal Focus Trap

```typescript
// components/ui/Modal.tsx

export function Modal({ open, onClose, children }: ModalProps) {
  const modalRef = useRef<HTMLDivElement>(null);
  const triggerRef = useRef<HTMLElement | null>(null);

  useEffect(() => {
    if (open) {
      // Save trigger element
      triggerRef.current = document.activeElement as HTMLElement;

      // Focus first focusable element in modal
      const firstFocusable = modalRef.current?.querySelector(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      ) as HTMLElement;
      firstFocusable?.focus();
    } else {
      // Restore focus to trigger
      triggerRef.current?.focus();
    }
  }, [open]);

  // Trap focus within modal
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Tab' && modalRef.current) {
      const focusables = modalRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const first = focusables[0] as HTMLElement;
      const last = focusables[focusables.length - 1] as HTMLElement;

      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    }

    if (e.key === 'Escape') {
      onClose();
    }
  };

  return (
    <div
      ref={modalRef}
      role="dialog"
      aria-modal="true"
      onKeyDown={handleKeyDown}
    >
      {children}
    </div>
  );
}
```

### 9.6 Color Contrast Validation (MAJ-A11Y-003)

**Purpose**: Document color contrast requirements and validation approach.

#### Contrast Requirements

| Element Type | Ratio Required | Standard |
|--------------|----------------|----------|
| Normal text (<24px, <19px bold) | 4.5:1 | WCAG AA |
| Large text (>=24px, >=19px bold) | 3:1 | WCAG AA |
| UI components (borders, focus rings) | 3:1 | WCAG AA |
| Non-text content (icons, graphs) | 3:1 | WCAG AA |

#### Color Palette Validation

```typescript
// lib/a11y/contrast.ts

const COLOR_PALETTE = {
  // Background colors
  background: {
    light: '#ffffff',
    dark: '#0a0a0a',
  },
  // Foreground colors
  foreground: {
    light: '#0a0a0a',
    dark: '#fafafa',
  },
  // Status colors
  status: {
    success: { light: '#16a34a', dark: '#22c55e' },  // Green
    error: { light: '#dc2626', dark: '#ef4444' },    // Red
    warning: { light: '#d97706', dark: '#f59e0b' },  // Amber
    info: { light: '#2563eb', dark: '#3b82f6' },     // Blue
  },
  // Muted colors
  muted: {
    light: '#737373',  // 4.54:1 on white
    dark: '#a3a3a3',   // 4.56:1 on black
  },
};

// Automated contrast check in CI
// Uses axe-core with WCAG AA ruleset
```

#### Testing Approach

```typescript
// test/a11y/contrast.test.ts

describe('Color Contrast', () => {
  it('meets WCAG AA requirements in light mode', async ({ page }) => {
    await page.goto('/');

    const results = await new AxeBuilder({ page })
      .withRules(['color-contrast'])
      .analyze();

    expect(results.violations).toEqual([]);
  });

  it('meets WCAG AA requirements in dark mode', async ({ page }) => {
    await page.goto('/');
    await page.click('[data-testid="theme-toggle"]');

    const results = await new AxeBuilder({ page })
      .withRules(['color-contrast'])
      .analyze();

    expect(results.violations).toEqual([]);
  });
});
```

### 9.7 Reduced Motion Support (MAJ-A11Y-004)

**Purpose**: Respect user preferences for reduced motion.

```typescript
// hooks/useReducedMotion.ts

export function useReducedMotion(): boolean {
  const [reducedMotion, setReducedMotion] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setReducedMotion(mediaQuery.matches);

    const handler = (e: MediaQueryListEvent) => setReducedMotion(e.matches);
    mediaQuery.addEventListener('change', handler);

    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return reducedMotion;
}

// Usage in components
const reducedMotion = useReducedMotion();

<Progress
  value={progress}
  className={cn(
    !reducedMotion && 'transition-all duration-300'
  )}
/>
```

#### CSS Implementation

```css
/* globals.css */

@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Alternative: Use CSS custom property */
:root {
  --transition-duration: 200ms;
}

@media (prefers-reduced-motion: reduce) {
  :root {
    --transition-duration: 0ms;
  }
}
```

---

## 10. Testing Specifications

### 10.1 Testing Strategy Overview

**Reference**: [CHARTER: 13.2]

| Test Type | Tool | Coverage Target | Run Frequency |
|-----------|------|-----------------|---------------|
| Unit Tests | Vitest | >= 80% lines | Every commit |
| Component Tests | React Testing Library | All components | Every commit |
| Integration Tests | Vitest + MSW | API routes, MCP | Every PR |
| E2E Tests | Playwright | Critical paths | Daily/Release |
| Accessibility Tests | axe-core | All components | Every PR |
| Security Tests | Custom + OWASP | Critical endpoints | Every PR |
| Performance Tests | Lighthouse | Key pages | Weekly |

### 10.1.1 Security Testing Specifications (MAJ-11, MAJ-13, MAJ-20)

**Reference**: [CHARTER: 11.3], [ARCH: 10.5]

#### Security Test Categories

| Category | Tests | Tool | Run Frequency |
|----------|-------|------|---------------|
| Input Validation | XSS, SQLi, SSRF | Custom + OWASP ZAP | Every PR |
| Authentication | Session fixation, cookie security | Custom | Every PR |
| Rate Limiting | Bypass attempts, sliding window | Custom | Every PR |
| File Upload | Magic byte validation, path traversal | Custom | Every PR |
| SSRF Prevention | Internal IP blocking, DNS rebinding | Custom | Every PR |
| CSP Validation | Header verification | Custom | Every PR |

#### Security Test Specifications

```typescript
// test/security/input-validation.test.ts

describe('Security: Input Validation', () => {
  describe('XSS Prevention', () => {
    it('sanitizes script tags in URL input', async () => {
      const response = await fetch('/api/v1/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          url: 'https://example.com/<script>alert(1)</script>',
        }),
      });

      expect(response.status).toBe(400);
      const data = await response.json();
      expect(data.code).toBe('E101'); // Invalid URL format
    });

    it('sanitizes HTML in filename', async () => {
      const formData = new FormData();
      const file = new File(['test'], '<img onerror=alert(1)>.pdf');
      formData.append('file', file);

      const response = await fetch('/api/v1/upload', {
        method: 'POST',
        body: formData,
      });

      // Filename should be sanitized or rejected
      expect(response.status).toBe(400);
    });
  });

  describe('SSRF Prevention', () => {
    const BLOCKED_URLS = [
      'http://localhost/secret',
      'http://127.0.0.1/admin',
      'http://192.168.1.1/internal',
      'http://10.0.0.1/private',
      'http://169.254.169.254/latest/meta-data/',  // AWS metadata
      'http://[::1]/ipv6-localhost',
      'http://internal.hx.dev.local/api',
    ];

    BLOCKED_URLS.forEach(url => {
      it(`blocks SSRF attempt to ${url}`, async () => {
        const response = await fetch('/api/v1/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url }),
        });

        expect(response.status).toBe(400);
        const data = await response.json();
        expect(data.code).toBe('E104'); // URL blocked
      });
    });

    it('blocks DNS rebinding attempts', async () => {
      // Test URL that resolves to internal IP
      const response = await fetch('/api/v1/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          url: 'http://attacker.com.resolves-to-169.254.169.254/',
        }),
      });

      // Should be blocked after DNS resolution
      expect(response.status).toBe(400);
    });
  });

  describe('SQL Injection Prevention', () => {
    it('sanitizes SQL injection in query parameters', async () => {
      const response = await fetch(
        '/api/v1/history?sortBy=createdAt; DROP TABLE jobs;--'
      );

      // Should reject invalid parameter, not execute SQL
      expect(response.status).toBe(400);
    });
  });
});

// test/security/rate-limiting.test.ts

describe('Security: Rate Limiting', () => {
  it('enforces sliding window rate limit', async () => {
    const sessionId = 'test-session-' + Date.now();

    // Make requests up to the limit
    for (let i = 0; i < 10; i++) {
      const response = await fetch('/api/v1/upload', {
        method: 'POST',
        headers: { Cookie: `session=${sessionId}` },
        body: JSON.stringify({ url: 'https://example.com/doc.pdf' }),
      });

      if (i < 10) {
        expect(response.status).not.toBe(429);
      }
    }

    // 11th request should be rate limited
    const blockedResponse = await fetch('/api/v1/upload', {
      method: 'POST',
      headers: { Cookie: `session=${sessionId}` },
      body: JSON.stringify({ url: 'https://example.com/doc.pdf' }),
    });

    expect(blockedResponse.status).toBe(429);
    expect(blockedResponse.headers.get('Retry-After')).toBeDefined();
  });

  it('uses sliding window (not fixed window)', async () => {
    // This test verifies the sliding window implementation
    // by checking that requests at window boundaries don't
    // allow burst attacks
    // Implementation: make 5 requests at t=55s, wait 10s,
    // verify only 5 more allowed (not 10)
  });
});

// test/security/file-upload.test.ts

describe('Security: File Upload', () => {
  it('validates file magic bytes (not just extension)', async () => {
    // Create file with PDF extension but wrong magic bytes
    const fakeFile = new File(
      ['GIF89a'],  // GIF magic bytes
      'document.pdf',
      { type: 'application/pdf' }
    );

    const formData = new FormData();
    formData.append('file', fakeFile);

    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      body: formData,
    });

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.code).toBe('E004'); // File corrupted/invalid
  });

  it('prevents path traversal in filename', async () => {
    const formData = new FormData();
    const file = new File(['test'], '../../../etc/passwd.pdf');
    formData.append('file', file);

    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      body: formData,
    });

    // Should sanitize filename or reject
    expect(response.status).toBe(400);
  });

  it('validates Content-Length matches actual size', async () => {
    // Test for content-length smuggling
    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      headers: {
        'Content-Length': '100',  // Claim 100 bytes
      },
      body: new ArrayBuffer(1000000),  // Actually 1MB
    });

    expect(response.status).toBe(400);
  });
});

// test/security/csp.test.ts

describe('Security: Content Security Policy', () => {
  it('returns correct CSP headers', async () => {
    const response = await fetch('/');

    const csp = response.headers.get('Content-Security-Policy');
    expect(csp).toContain("default-src 'self'");
    expect(csp).toContain("script-src 'self'");
    expect(csp).toContain("frame-ancestors 'none'");
    expect(csp).not.toContain("'unsafe-eval'");
  });

  it('returns security headers', async () => {
    const response = await fetch('/');

    expect(response.headers.get('X-Content-Type-Options')).toBe('nosniff');
    expect(response.headers.get('X-Frame-Options')).toBe('DENY');
    expect(response.headers.get('Referrer-Policy')).toBe('strict-origin-when-cross-origin');
  });
});
```

#### OWASP Top 10 Coverage

| OWASP Category | Mitigation | Test |
|----------------|------------|------|
| A01: Broken Access Control | Session validation, RBAC | `access-control.test.ts` |
| A02: Cryptographic Failures | TLS, secure cookies | `crypto.test.ts` |
| A03: Injection | Input validation, parameterized queries | `injection.test.ts` |
| A04: Insecure Design | Threat modeling review | Design review |
| A05: Security Misconfiguration | CSP, security headers | `headers.test.ts` |
| A06: Vulnerable Components | npm audit, Dependabot | CI pipeline |
| A07: Authentication Failures | Session management | `auth.test.ts` |
| A08: Software/Data Integrity | CSRF tokens, SRI | `integrity.test.ts` |
| A09: Logging/Monitoring | Audit logging tests | `logging.test.ts` |
| A10: SSRF | URL validation | `ssrf.test.ts` |

### 10.2 Unit Test Specifications

#### 10.2.1 Validation Tests

```typescript
// lib/validation/__tests__/file.test.ts

describe('fileSchema', () => {
  it('accepts valid PDF file', () => {
    const result = fileSchema.safeParse({
      name: 'document.pdf',
      size: 1024 * 1024,
      type: 'application/pdf',
    });
    expect(result.success).toBe(true);
  });

  it('rejects file over 100MB', () => {
    const result = fileSchema.safeParse({
      name: 'large.pdf',
      size: 101 * 1024 * 1024,
      type: 'application/pdf',
    });
    expect(result.success).toBe(false);
    expect(result.error?.issues[0].message).toContain('100 MB');
  });

  it('rejects unsupported extension', () => {
    const result = fileSchema.safeParse({
      name: 'script.exe',
      size: 1024,
      type: 'application/octet-stream',
    });
    expect(result.success).toBe(false);
  });
});
```

#### 10.2.2 Store Tests

```typescript
// stores/__tests__/documentStore.test.ts

describe('documentStore', () => {
  beforeEach(() => {
    useDocumentStore.setState({
      file: null,
      url: null,
      activeInput: null,
      isProcessing: false,
    });
  });

  it('setFile clears URL and sets activeInput', () => {
    const store = useDocumentStore.getState();
    const mockFile = new File([''], 'test.pdf');

    store.setUrl('https://example.com');
    store.setFile(mockFile);

    expect(useDocumentStore.getState().file).toBe(mockFile);
    expect(useDocumentStore.getState().url).toBeNull();
    expect(useDocumentStore.getState().activeInput).toBe('file');
  });

  it('prevents input changes during processing', () => {
    const store = useDocumentStore.getState();
    const mockFile = new File([''], 'test.pdf');

    store.setFile(mockFile);
    store.startProcessing('job-123');
    store.setUrl('https://example.com');

    expect(useDocumentStore.getState().url).toBeNull();
    expect(useDocumentStore.getState().file).toBe(mockFile);
  });
});
```

### 10.3 Component Test Specifications

#### 10.3.1 UploadZone Tests

```typescript
// components/upload/__tests__/UploadZone.test.tsx

describe('UploadZone', () => {
  it('renders dropzone with correct label', () => {
    render(<UploadZone />);
    expect(screen.getByText(/drop file here/i)).toBeInTheDocument();
  });

  it('accepts valid PDF file on drop', async () => {
    const onFileSelect = vi.fn();
    render(<UploadZone onFileSelect={onFileSelect} />);

    const file = new File(['content'], 'test.pdf', { type: 'application/pdf' });
    const dropzone = screen.getByTestId('upload-dropzone');

    await fireEvent.drop(dropzone, { dataTransfer: { files: [file] } });

    expect(onFileSelect).toHaveBeenCalledWith(file);
  });

  it('shows error for oversized file', async () => {
    render(<UploadZone />);

    // Create mock large file
    const largeFile = new File(['x'.repeat(101 * 1024 * 1024)], 'large.pdf');
    const dropzone = screen.getByTestId('upload-dropzone');

    await fireEvent.drop(dropzone, { dataTransfer: { files: [largeFile] } });

    expect(screen.getByText(/file must be under 100 MB/i)).toBeInTheDocument();
  });

  it('is keyboard accessible', async () => {
    render(<UploadZone />);

    const dropzone = screen.getByTestId('upload-dropzone');
    dropzone.focus();

    expect(document.activeElement).toBe(dropzone);
  });
});
```

#### 10.3.2 ProgressCard Tests

```typescript
// components/processing/__tests__/ProgressCard.test.tsx

describe('ProgressCard', () => {
  it('displays initial state', () => {
    render(<ProgressCard jobId="test-job" />);
    expect(screen.getByText(/starting/i)).toBeInTheDocument();
  });

  it('updates on progress event', async () => {
    render(<ProgressCard jobId="test-job" />);

    // Mock SSE event
    act(() => {
      mockSSE.emit('progress', { stage: 'conversion', percent: 50, message: 'Processing...' });
    });

    expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '50');
    expect(screen.getByText(/processing/i)).toBeInTheDocument();
  });

  it('shows reconnection state', async () => {
    render(<ProgressCard jobId="test-job" />);

    act(() => {
      mockSSE.emit('error');
    });

    expect(screen.getByText(/reconnecting/i)).toBeInTheDocument();
  });
});
```

### 10.4 Integration Test Specifications

#### 10.4.1 API Route Tests

```typescript
// app/api/v1/upload/__tests__/route.test.ts

describe('POST /api/v1/upload', () => {
  it('creates job for valid file upload', async () => {
    const formData = new FormData();
    formData.append('file', new Blob(['content']), 'test.pdf');

    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      body: formData,
    });

    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.jobId).toBeDefined();
    expect(data.status).toBe('PENDING');
  });

  it('returns 400 for oversized file', async () => {
    const formData = new FormData();
    const largeFile = new Blob([new ArrayBuffer(101 * 1024 * 1024)]);
    formData.append('file', largeFile, 'large.pdf');

    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      body: formData,
    });

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.code).toBe('E001');
  });

  it('blocks private URL', async () => {
    const response = await fetch('/api/v1/upload', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url: 'http://192.168.1.1/secret' }),
    });

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.code).toBe('E104');
  });
});
```

### 10.5 E2E Test Specifications

#### 10.5.1 Critical Path Tests

```typescript
// test/e2e/critical-path.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Critical Path', () => {
  test('upload PDF -> process -> view results -> download', async ({ page }) => {
    await page.goto('/');

    // Upload file
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles('test/fixtures/sample.pdf');

    // Verify preview
    await expect(page.locator('[data-testid="file-preview"]')).toContainText('sample.pdf');

    // Start processing
    await page.click('button:has-text("Process")');

    // Wait for completion
    await expect(page.locator('[data-testid="progress-complete"]'))
      .toBeVisible({ timeout: 60000 });

    // Verify results
    await page.click('button:has-text("Markdown")');
    await expect(page.locator('[data-testid="markdown-content"]'))
      .not.toBeEmpty();

    // Download
    const [download] = await Promise.all([
      page.waitForEvent('download'),
      page.click('button:has-text("Download")'),
    ]);

    expect(download.suggestedFilename()).toMatch(/\.md$/);
  });

  test('SSE reconnection on network interruption', async ({ page, context }) => {
    await page.goto('/');

    // Start processing
    await page.locator('input[type="file"]').setInputFiles('test/fixtures/sample.pdf');
    await page.click('button:has-text("Process")');

    // Wait for streaming to start
    await expect(page.locator('[data-testid="connection-status"]'))
      .toContainText('Connected');

    // Simulate network interruption
    await context.setOffline(true);

    // Verify reconnection UI
    await expect(page.locator('[data-testid="connection-status"]'))
      .toContainText('Reconnecting');

    // Restore network
    await context.setOffline(false);

    // Verify reconnection success
    await expect(page.locator('[data-testid="connection-status"]'))
      .toContainText('Connected', { timeout: 30000 });

    // Verify processing completes
    await expect(page.locator('[data-testid="progress-complete"]'))
      .toBeVisible({ timeout: 60000 });
  });

  test('history view and re-download', async ({ page }) => {
    // First, create a job
    await page.goto('/');
    await page.locator('input[type="file"]').setInputFiles('test/fixtures/sample.pdf');
    await page.click('button:has-text("Process")');
    await expect(page.locator('[data-testid="progress-complete"]'))
      .toBeVisible({ timeout: 60000 });

    // Navigate to history
    await page.click('button:has-text("History")');

    // Verify job appears
    await expect(page.locator('table tbody tr')).toHaveCount.greaterThan(0);

    // Click job to view detail
    await page.click('table tbody tr:first-child');

    // Download from history
    const [download] = await Promise.all([
      page.waitForEvent('download'),
      page.click('[data-testid="job-detail"] button:has-text("Download")'),
    ]);

    expect(download.suggestedFilename()).toMatch(/\.md$/);
  });
});
```

### 10.6 Accessibility Test Specifications

```typescript
// test/a11y/accessibility.spec.ts

import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test.describe('Accessibility', () => {
  test('main page has no accessibility violations', async ({ page }) => {
    await page.goto('/');

    const results = await new AxeBuilder({ page })
      .withTags(['wcag2a', 'wcag2aa'])
      .analyze();

    expect(results.violations).toEqual([]);
  });

  test('results page has no accessibility violations', async ({ page }) => {
    // Navigate to page with results
    await page.goto('/');
    await page.locator('input[type="file"]').setInputFiles('test/fixtures/sample.pdf');
    await page.click('button:has-text("Process")');
    await expect(page.locator('[data-testid="progress-complete"]'))
      .toBeVisible({ timeout: 60000 });

    const results = await new AxeBuilder({ page })
      .withTags(['wcag2a', 'wcag2aa'])
      .analyze();

    expect(results.violations).toEqual([]);
  });

  test('keyboard navigation works', async ({ page }) => {
    await page.goto('/');

    // Tab through main elements
    await page.keyboard.press('Tab');
    const uploadZone = page.locator('[data-testid="upload-dropzone"]');
    await expect(uploadZone).toBeFocused();

    await page.keyboard.press('Tab');
    const urlInput = page.locator('[data-testid="url-input"]');
    await expect(urlInput).toBeFocused();

    await page.keyboard.press('Tab');
    const processButton = page.locator('button:has-text("Process")');
    await expect(processButton).toBeFocused();
  });
});
```

### 10.7 Test Fixtures Specification (MAJ-TEST-004)

**Purpose**: Define required test fixtures for unit, integration, and E2E tests to ensure consistent and reproducible testing.

#### 10.7.1 Test Fixture Directory Structure

```
test/
 fixtures/
    documents/
       pdf/
          sample.pdf              # 100KB - simple single-page
          multi-page.pdf          # 5MB - 50 pages, text + images
          image-heavy.pdf         # 20MB - scanned document
          complex-tables.pdf      # 2MB - complex table layouts
          empty.pdf               # 10KB - blank PDF
       docx/
          sample.docx             # 50KB - simple document
          with-images.docx        # 10MB - embedded images
          with-tables.docx        # 500KB - complex tables
       xlsx/
          sample.xlsx             # 100KB - single sheet
          multi-sheet.xlsx        # 5MB - 10 sheets with data
          with-charts.xlsx        # 2MB - charts and formulas
       pptx/
          sample.pptx             # 500KB - 5 slides
          media-rich.pptx         # 15MB - videos and animations
       images/
           sample.png              # 500KB - document scan
           sample.jpg              # 1MB - photograph
           sample.tiff             # 5MB - high-resolution scan
    invalid/
       corrupted.pdf               # Invalid PDF structure
       wrong-extension.pdf         # Actually a DOCX file
       too-large.pdf               # 150MB - exceeds limit
       executable.pdf.exe          # Security test file
       malicious-filename.<script>.pdf
    responses/
       mcp/
          initialize-success.json
          tools-list.json
          convert-pdf-success.json
          export-markdown-success.json
          error-timeout.json
          error-invalid-params.json
       api/
           upload-success.json
           process-success.json
           history-paginated.json
    sessions/
        valid-session.json
        expired-session.json
```

#### 10.7.2 Fixture Characteristics

| Fixture | Size | Characteristics | Purpose |
|---------|------|-----------------|---------|
| sample.pdf | 100KB | Single page, text only | Happy path unit tests |
| multi-page.pdf | 5MB | 50 pages, mixed content | Integration tests |
| image-heavy.pdf | 20MB | Scanned document | Performance testing |
| complex-tables.pdf | 2MB | Nested tables | Table extraction tests |
| too-large.pdf | 150MB | Exceeds 100MB limit | Size validation tests |
| corrupted.pdf | 10KB | Invalid structure | Error handling tests |

#### 10.7.3 Mock MCP Responses

```typescript
// test/fixtures/responses/mcp/convert-pdf-success.json

{
  "jsonrpc": "2.0",
  "result": {
    "content": [
      {
        "type": "document",
        "document": {
          "schema_name": "docling_core.transforms.v1.DoclingDocument",
          "version": "1.0.0",
          "name": "sample.pdf",
          "origin": {
            "mimetype": "application/pdf",
            "filename": "sample.pdf"
          },
          "body": {
            "self_ref": "#/body",
            "children": [],
            "content_text": "Sample document content..."
          }
        }
      }
    ]
  },
  "id": "test-123"
}
```

### 10.8 URL Validation Test Matrix (MAJ-TEST-001)

**Purpose**: Comprehensive test coverage for URL validation including SSRF prevention.

```typescript
// test/validation/url.test.ts

describe('URL Validation Tests', () => {
  describe('Valid URLs', () => {
    const validUrls = [
      'https://example.com/document.pdf',
      'https://cdn.example.com/files/doc.pdf',
      'http://public-docs.org/api/download?id=123',
      'https://192.0.2.1/public/file.pdf',  // Documentation IP range
    ];

    validUrls.forEach(url => {
      it(`accepts ${url}`, () => {
        expect(urlSchema.safeParse(url).success).toBe(true);
      });
    });
  });

  describe('Invalid URL Formats', () => {
    const invalidFormats = [
      { url: 'not-a-url', reason: 'missing protocol' },
      { url: 'ftp://example.com/file', reason: 'invalid protocol' },
      { url: 'javascript:alert(1)', reason: 'javascript protocol' },
      { url: 'data:text/html,<script>', reason: 'data URI' },
      { url: 'file:///etc/passwd', reason: 'file protocol' },
      { url: 'x'.repeat(2049), reason: 'exceeds 2048 chars' },
    ];

    invalidFormats.forEach(({ url, reason }) => {
      it(`rejects ${reason}`, () => {
        const result = urlSchema.safeParse(url);
        expect(result.success).toBe(false);
      });
    });
  });

  describe('SSRF Prevention', () => {
    const blockedUrls = [
      // Localhost
      'http://localhost/admin',
      'http://127.0.0.1/secret',
      'http://[::1]/ipv6',

      // Private ranges (RFC 1918)
      'http://10.0.0.1/internal',
      'http://10.255.255.255/edge',
      'http://172.16.0.1/private',
      'http://172.31.255.255/edge',
      'http://192.168.1.1/lan',
      'http://192.168.255.255/edge',

      // Link-local
      'http://169.254.169.254/metadata',  // AWS metadata
      'http://169.254.1.1/linklocal',

      // Internal domains
      'http://internal.hx.dev.local/api',
      'http://db.hx.dev.local:5432/',
    ];

    blockedUrls.forEach(url => {
      it(`blocks SSRF to ${new URL(url).hostname}`, () => {
        const result = urlSchema.safeParse(url);
        expect(result.success).toBe(false);
      });
    });
  });

  describe('Edge Cases', () => {
    it('handles URL with authentication', () => {
      const url = 'https://user:pass@example.com/file.pdf';
      const result = urlSchema.safeParse(url);
      // Should reject or sanitize credentials
      expect(result.success).toBe(false);
    });

    it('handles URL with port', () => {
      const url = 'https://example.com:8443/file.pdf';
      expect(urlSchema.safeParse(url).success).toBe(true);
    });

    it('handles URL with query and fragment', () => {
      const url = 'https://example.com/doc?v=1#section';
      expect(urlSchema.safeParse(url).success).toBe(true);
    });

    it('handles IDN domains', () => {
      const url = 'https://xn--nxasmq5b.example.com/file.pdf';  // Punycode
      expect(urlSchema.safeParse(url).success).toBe(true);
    });
  });
});
```

### 10.9 Integration Test Database Assertions (MAJ-TEST-002)

**Purpose**: Ensure API tests verify database state changes, not just HTTP responses.

```typescript
// test/integration/api-database.test.ts

describe('API Database Integration', () => {
  beforeEach(async () => {
    await prisma.job.deleteMany();
    await prisma.result.deleteMany();
  });

  describe('POST /api/v1/upload', () => {
    it('creates Job record with correct initial state', async () => {
      const formData = new FormData();
      formData.append('file', new Blob(['test']), 'test.pdf');

      const response = await fetch('/api/v1/upload', {
        method: 'POST',
        body: formData,
      });

      const { jobId } = await response.json();

      // Database assertion
      const job = await prisma.job.findUnique({ where: { id: jobId } });

      expect(job).not.toBeNull();
      expect(job?.status).toBe('PENDING');
      expect(job?.fileName).toBe('test.pdf');
      expect(job?.inputType).toBe('FILE');
      expect(job?.createdAt).toBeDefined();
    });
  });

  describe('POST /api/v1/process', () => {
    it('creates Result records on successful processing', async () => {
      // Setup: Create job
      const job = await prisma.job.create({
        data: {
          sessionId: 'test-session',
          status: 'PENDING',
          inputType: 'FILE',
          fileName: 'test.pdf',
          filePath: '/tmp/test.pdf',
          mimeType: 'application/pdf',
        },
      });

      // Process (with mocked MCP)
      await fetch('/api/v1/process', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ jobId: job.id }),
      });

      // Wait for completion
      await waitForJobStatus(job.id, 'COMPLETE');

      // Database assertions
      const results = await prisma.result.findMany({
        where: { jobId: job.id },
      });

      expect(results.length).toBe(3); // markdown, html, json
      expect(results.map(r => r.format).sort()).toEqual(['HTML', 'JSON', 'MARKDOWN']);

      results.forEach(result => {
        expect(result.content).toBeTruthy();
        expect(result.size).toBeGreaterThan(0);
      });
    });

    it('updates Job status through state machine', async () => {
      const job = await prisma.job.create({
        data: {
          sessionId: 'test-session',
          status: 'PENDING',
          inputType: 'FILE',
          fileName: 'test.pdf',
          filePath: '/tmp/test.pdf',
        },
      });

      // Start processing
      await fetch('/api/v1/process', {
        method: 'POST',
        body: JSON.stringify({ jobId: job.id }),
      });

      // Verify intermediate states (may need polling)
      const processingJob = await waitForJobStatus(job.id, 'PROCESSING');
      expect(processingJob?.status).toBe('PROCESSING');

      // Verify final state
      const completedJob = await waitForJobStatus(job.id, 'COMPLETE', 60000);
      expect(completedJob?.status).toBe('COMPLETE');
      expect(completedJob?.completedAt).toBeDefined();
    });
  });

  describe('GET /api/v1/history', () => {
    it('returns jobs filtered by sessionId', async () => {
      // Create jobs for different sessions
      await prisma.job.createMany({
        data: [
          { sessionId: 'session-a', status: 'COMPLETE', inputType: 'FILE' },
          { sessionId: 'session-a', status: 'COMPLETE', inputType: 'FILE' },
          { sessionId: 'session-b', status: 'COMPLETE', inputType: 'FILE' },
        ],
      });

      const response = await fetch('/api/v1/history', {
        headers: { Cookie: 'session=session-a' },
      });
      const { jobs } = await response.json();

      expect(jobs.length).toBe(2);
      jobs.forEach((job: Job) => {
        expect(job.sessionId).toBe('session-a');
      });
    });
  });
});
```

### 10.10 Accessibility Dynamic Content Tests (MAJ-TEST-003)

**Purpose**: Test accessibility of dynamic content updates, not just static pages.

```typescript
// test/a11y/dynamic-content.test.ts

describe('Accessibility: Dynamic Content', () => {
  describe('Progress Announcements', () => {
    it('announces progress updates via aria-live', async ({ page }) => {
      await page.goto('/');
      await page.locator('input[type="file"]').setInputFiles('test/fixtures/sample.pdf');
      await page.click('button:has-text("Process")');

      // Capture announced text
      const announcements: string[] = [];
      await page.addListener('console', msg => {
        if (msg.text().includes('[a11y-announce]')) {
          announcements.push(msg.text());
        }
      });

      // Wait for some progress
      await page.waitForSelector('[data-testid="progress-card"]');
      await page.waitForTimeout(2000);

      // Verify announcements occurred
      expect(announcements.length).toBeGreaterThan(0);
    });

    it('debounces rapid announcements', async ({ page }) => {
      // Verify that rapid SSE events don't flood screen readers
      await page.goto('/');
      await page.locator('input[type="file"]').setInputFiles('test/fixtures/sample.pdf');
      await page.click('button:has-text("Process")');

      const ariaLive = page.locator('[aria-live="polite"]');
      const updateCount = await page.evaluate(() => {
        let count = 0;
        const observer = new MutationObserver(() => count++);
        observer.observe(
          document.querySelector('[aria-live="polite"]')!,
          { childList: true, subtree: true }
        );
        return new Promise(resolve => setTimeout(() => resolve(count), 5000));
      });

      // With 500ms debounce, expect ~10 announcements max in 5s
      expect(updateCount).toBeLessThan(15);
    });
  });

  describe('Error Announcements', () => {
    it('announces errors via aria-live assertive', async ({ page }) => {
      await page.goto('/');

      // Trigger validation error
      await page.locator('[data-testid="url-input"]').fill('invalid-url');
      await page.keyboard.press('Tab');

      const errorAlert = page.locator('[role="alert"]');
      await expect(errorAlert).toBeVisible();
      await expect(errorAlert).toHaveAttribute('aria-live', 'assertive');
    });
  });

  describe('Focus Management', () => {
    it('returns focus after modal close', async ({ page }) => {
      await page.goto('/history');
      const triggerButton = page.locator('table tbody tr:first-child button');

      await triggerButton.click();
      await expect(page.locator('[role="dialog"]')).toBeVisible();

      await page.keyboard.press('Escape');
      await expect(page.locator('[role="dialog"]')).not.toBeVisible();

      // Focus should return to trigger
      await expect(triggerButton).toBeFocused();
    });

    it('traps focus within modal', async ({ page }) => {
      await page.goto('/history');
      await page.locator('table tbody tr:first-child button').click();

      const modal = page.locator('[role="dialog"]');
      await expect(modal).toBeVisible();

      // Tab through all focusable elements
      const focusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
      const focusableCount = await modal.locator(focusableSelector).count();

      for (let i = 0; i < focusableCount + 2; i++) {
        await page.keyboard.press('Tab');
        const focused = await page.evaluate(() => document.activeElement?.closest('[role="dialog"]'));
        expect(focused).not.toBeNull();
      }
    });
  });
});
```

### 10.11 MCP Server Mocking Strategy (MAJ-MCP-TEST)

**Purpose**: Define MSW handlers for deterministic MCP server testing.

```typescript
// test/mocks/handlers/mcp.ts

import { http, HttpResponse } from 'msw';

const MCP_ENDPOINT = process.env.DOCLING_MCP_ORIGIN || 'http://hx-docling-mcp-server.hx.dev.local:8000';

export const mcpHandlers = [
  // Initialize handler
  http.post(MCP_ENDPOINT, async ({ request }) => {
    const body = await request.json() as { method: string; id: string };

    if (body.method === 'initialize') {
      return HttpResponse.json({
        jsonrpc: '2.0',
        result: {
          protocolVersion: '2024-11-05',
          serverInfo: { name: 'mock-mcp-server', version: '1.0.0' },
          capabilities: { tools: { listChanged: false } },
        },
        id: body.id,
      });
    }

    if (body.method === 'tools/list') {
      return HttpResponse.json({
        jsonrpc: '2.0',
        result: {
          tools: [
            { name: 'convert_pdf', description: 'Convert PDF', inputSchema: {} },
            { name: 'export_markdown', description: 'Export Markdown', inputSchema: {} },
            { name: 'export_html', description: 'Export HTML', inputSchema: {} },
            { name: 'export_json', description: 'Export JSON', inputSchema: {} },
          ],
        },
        id: body.id,
      });
    }

    if (body.method === 'tools/call') {
      // Simulate processing time
      await new Promise(resolve => setTimeout(resolve, 100));

      return HttpResponse.json({
        jsonrpc: '2.0',
        result: {
          content: [{ type: 'document', document: mockDoclingDocument }],
        },
        id: body.id,
      });
    }

    return HttpResponse.json({
      jsonrpc: '2.0',
      error: { code: -32601, message: 'Method not found' },
      id: body.id,
    });
  }),
];

// Scenario handlers for testing edge cases
export const mcpTimeoutHandler = http.post(MCP_ENDPOINT, async () => {
  await new Promise(resolve => setTimeout(resolve, 310000)); // > 300s timeout
  return new Response(null, { status: 504 });
});

export const mcpErrorHandler = http.post(MCP_ENDPOINT, () => {
  return HttpResponse.json({
    jsonrpc: '2.0',
    error: { code: -32603, message: 'Internal error' },
    id: 'error-test',
  });
});

export const mcpPartialFailureHandler = http.post(MCP_ENDPOINT, async ({ request }) => {
  const body = await request.json() as { method: string; params?: { name: string } };

  if (body.params?.name === 'export_html') {
    return HttpResponse.json({
      jsonrpc: '2.0',
      error: { code: -32003, message: 'Export failed' },
      id: 'partial-test',
    });
  }

  // Return success for other tools
  return HttpResponse.json({
    jsonrpc: '2.0',
    result: { content: [{ type: 'text', text: 'Success' }] },
    id: 'partial-test',
  });
});
```

---

## 11. Quality Gates and Acceptance Criteria

### 11.1 Pre-Commit Quality Gates

**Reference**: [CHARTER: 13.3]

| Gate | Tool | Threshold | Blocking |
|------|------|-----------|----------|
| TypeScript | `tsc --noEmit` | 0 errors | Yes |
| ESLint | `eslint` | 0 errors | Yes |
| Prettier | `prettier --check` | 0 errors | Yes |
| Unit Tests | `vitest run` | Pass | Yes |

### 11.2 PR Quality Gates

| Gate | Tool | Threshold | Blocking |
|------|------|-----------|----------|
| Build | `npm run build` | Success | Yes |
| Unit Coverage | Vitest | >= 80% lines | Yes |
| Branch Coverage | Vitest | >= 75% | Yes |
| Accessibility | axe-core | 0 violations | Yes |
| Integration Tests | Vitest | Pass | Yes |

### 11.3 Release Quality Gates

| Gate | Tool | Threshold | Blocking |
|------|------|-----------|----------|
| E2E Tests | Playwright | Pass | Yes |
| Lighthouse Performance | Lighthouse | >= 80 | Yes |
| Lighthouse Accessibility | Lighthouse | >= 90 | Yes |
| LCP | Lighthouse | < 2.5s | Yes |
| FCP | Lighthouse | < 1.8s | Yes |
| Bundle Size | Build analysis | < 100KB JS | Warning |

### 11.4 Functional Acceptance Criteria

| ID | Criterion | Validation Method | Pass Criteria |
|----|-----------|-------------------|---------------|
| SC-F1 | PDF upload produces Markdown | Manual test | Markdown content displayed |
| SC-F2 | Excel upload produces output | Manual test | All formats available |
| SC-F3 | PowerPoint upload produces output | Manual test | All formats available |
| SC-F4 | URL input produces HTML | Manual test | HTML preview displays |
| SC-F5 | Real-time progress updates | SSE validation | Updates within 500ms |
| SC-F6 | SSE auto-reconnection | Network simulation | Reconnects within 30s |
| SC-F7 | Tab switching works | UI test | All tabs display content |
| SC-F8 | Download works | Download validation | File downloads correctly |
| SC-F9 | Error display complete | Error injection | Code + message + action shown |
| SC-F10 | History pagination works | UI test | Pages navigate correctly |
| SC-F11 | Re-download works | Persistence test | Past results downloadable |
| SC-F12 | Health check reports all deps | Health check test | All services reported |

### 11.5 Non-Functional Acceptance Criteria

| ID | Criterion | Target | Validation |
|----|-----------|--------|------------|
| SC-NF1 | LCP | < 2.5s | Lighthouse |
| SC-NF2 | FCP | < 1.8s | Lighthouse |
| SC-NF3 | Time to first progress | < 500ms | Performance timing |
| SC-NF4 | Tablet responsive | >= 768px | Manual test |
| SC-NF5 | Accessibility score | >= 90 | Lighthouse |
| SC-NF6 | Performance score | >= 80 | Lighthouse |
| SC-NF7 | Console errors | 0 | Browser dev tools |

### 11.6 Resilience Acceptance Criteria

| ID | Criterion | Validation |
|----|-----------|------------|
| SC-R1 | SSE reconnection < 30s | Network simulation |
| SC-R2 | Processing continues after MCP transient failure | Fault injection |
| SC-R3 | Partial results displayed | Partial failure test |
| SC-R4 | Session survives browser refresh | State recovery test |

---

## 12. Appendices

### Appendix A: Error Code Reference

| Code | Category | Message | Retryable | Suggested Action |
|------|----------|---------|-----------|------------------|
| E001 | File | File too large | No | Try smaller file |
| E002 | File | Unsupported file type | No | Try different format |
| E003 | File | File read error | Yes | Try again |
| E004 | File | File corrupted | No | Try different file |
| E005 | File | Storage unavailable | Yes | Try again later |
| E101 | URL | Invalid URL format | No | Check URL |
| E102 | URL | URL unreachable | Yes | Check URL or try later |
| E103 | URL | URL timeout | Yes | Try again |
| E104 | URL | URL blocked | No | Try different URL |
| E201 | MCP | Server unavailable | Yes | Try again later |
| E202 | MCP | Connection timeout | Yes | Try again |
| E203 | MCP | Invalid parameters | No | Contact support |
| E204 | MCP | Tool not found | No | Contact support |
| E301 | Processing | Processing timeout | Yes | Try smaller file |
| E302 | Processing | Conversion failed | Yes | Try different file |
| E303 | Processing | Export failed | Yes | Retry export |
| E304 | Processing | Partial failure | - | Some results available |
| E401 | Database | Connection error | Yes | Try again |
| E402 | Database | Query timeout | Yes | Try again |
| E403 | Database | Write failed | Yes | Try again |
| E501 | Session | Session expired | No | Refresh page |
| E502 | Session | Invalid session | No | Clear cookies |
| E601 | Rate | Rate limit exceeded | Yes (delayed) | Wait and retry |

### Appendix B: Environment Variables

**IMPORTANT (MAJ-17)**: All timeout and duration values explicitly specify units in comments to prevent ambiguity.

```env
# ============================================================
# Application
# ============================================================
NODE_ENV=development
NEXT_PUBLIC_APP_VERSION=1.0.0-dev

# ============================================================
# MCP Server Configuration
# ============================================================
DOCLING_MCP_ORIGIN=http://hx-docling-mcp-server.hx.dev.local:8000

# MCP Timeouts (in milliseconds)
DOCLING_MCP_TIMEOUT_SMALL_MS=60000    # 60 seconds - for small documents < 1MB
DOCLING_MCP_TIMEOUT_MEDIUM_MS=180000  # 180 seconds - for medium documents 1-10MB
DOCLING_MCP_TIMEOUT_LARGE_MS=300000   # 300 seconds - for large documents > 10MB

# MCP Authentication (optional - see MAJ-09)
# MCP_API_KEY=<from-vault>
# MCP_AUTH_HEADER=X-API-Key

# ============================================================
# File Upload Configuration
# ============================================================
MAX_FILE_SIZE_MB=100                   # Maximum file size in megabytes
ALLOWED_FILE_TYPES=.pdf,.docx,.doc,.pptx,.ppt,.xlsx,.xls,.png,.jpg,.jpeg,.tiff
TEMP_STORAGE_PATH=/tmp/docling-processing
PERSISTENT_STORAGE_PATH=/data/docling-uploads
FILE_CLEANUP_INTERVAL_MS=3600000       # 1 hour - cleanup orphaned temp files

# ============================================================
# PostgreSQL Configuration
# ============================================================
# Via PgBouncer (application - port 6432)
DATABASE_URL=postgresql://docling_user:${DB_PASSWORD}@hx-postgres-server.hx.dev.local:6432/docling_db?connection_limit=5&pool_timeout=20&sslmode=verify-full&sslrootcert=/etc/docling/ssl/ca.crt

# Direct connection (migrations only - port 5432)
DIRECT_DATABASE_URL=postgresql://docling_migration:${MIGRATION_PASSWORD}@hx-postgres-server.hx.dev.local:5432/docling_db?sslmode=verify-full&sslrootcert=/etc/docling/ssl/ca.crt

# Connection pool settings
DB_POOL_SIZE=5                         # Maximum pool size per instance
DB_POOL_TIMEOUT_MS=20000              # 20 seconds - connection acquisition timeout

# ============================================================
# Redis Configuration
# ============================================================
REDIS_HOST=hx-redis-server.hx.dev.local
REDIS_PORT=6379
REDIS_PASSWORD=<from-vault>

# For TLS connections (MAJ-06/CRI-06)
REDIS_TLS_ENABLED=true
REDIS_CA_CERT_PATH=/etc/docling/ssl/redis-ca.crt
REDIS_URL=rediss://:${REDIS_PASSWORD}@hx-redis-server.hx.dev.local:6379/0

# Redis timeouts (in milliseconds)
REDIS_CONNECT_TIMEOUT_MS=10000        # 10 seconds
REDIS_COMMAND_TIMEOUT_MS=5000         # 5 seconds

# ============================================================
# Rate Limiting Configuration
# ============================================================
RATE_LIMIT_MAX=10                      # Maximum requests per window
RATE_LIMIT_WINDOW_SECONDS=60           # 60 seconds - sliding window size

# Circuit breaker settings (MAJ-14/CRI-05)
CIRCUIT_FAILURE_THRESHOLD=5            # Failures before opening circuit
CIRCUIT_RESET_TIMEOUT_MS=30000         # 30 seconds - time before half-open
CIRCUIT_SUCCESS_THRESHOLD=3            # Successes needed to close circuit

# ============================================================
# SSE Configuration
# ============================================================
SSE_HEARTBEAT_INTERVAL_MS=15000        # 15 seconds - keepalive interval
SSE_RECONNECT_DELAY_MS=3000            # 3 seconds - initial reconnect delay
SSE_MAX_RECONNECT_ATTEMPTS=10
SSE_EVENT_BUFFER_SIZE=100              # Events to buffer for reconnection
SSE_EVENT_BUFFER_TTL_MS=300000         # 5 minutes - buffer retention

# ============================================================
# Session Configuration
# ============================================================
SESSION_TTL_SECONDS=86400              # 24 hours - session expiry
SESSION_COOKIE_NAME=hx-docling-session

# ============================================================
# Job Configuration
# ============================================================
JOB_CHECKPOINT_TTL_HOURS=24            # Checkpoint retention
CLEANUP_ON_CANCEL=true                 # Delete partial results on cancel
```

### Appendix B.1: Icon Imports (MAJ-18)

**Required Lucide Icons**:
```typescript
// components/icons.ts - Centralized icon imports

import {
  // Status icons
  Clock,           // PENDING status
  Upload,          // UPLOADING status
  Loader,          // PROCESSING status
  RefreshCw,       // RETRY_* status
  Check,           // COMPLETE status
  AlertCircle,     // PARTIAL_COMPLETE status
  XCircle,         // CANCELLED status
  AlertTriangle,   // ERROR status

  // Action icons
  FileUp,          // File upload
  Link,            // URL input
  Download,        // Download action
  Copy,            // Copy to clipboard
  Trash2,          // Delete action
  RotateCcw,       // Retry action

  // UI icons
  Sun,             // Light theme
  Moon,            // Dark theme
  ChevronLeft,     // Navigation
  ChevronRight,    // Navigation
  X,               // Close/dismiss

  // Accessibility icons
  type LucideIcon,
} from 'lucide-react';

// Re-export for type-safe usage
export {
  Clock, Upload, Loader, RefreshCw, Check,
  AlertCircle, XCircle, AlertTriangle,
  FileUp, Link, Download, Copy, Trash2, RotateCcw,
  Sun, Moon, ChevronLeft, ChevronRight, X,
};
export type { LucideIcon };
```

**Usage Pattern**:
```typescript
// Always import from centralized icons file
import { Clock, AlertTriangle, type LucideIcon } from '@/components/icons';

// Type-safe icon component
interface IconProps {
  icon: LucideIcon;
  className?: string;
}
```

### Appendix C: File Structure

```
hx-docling-ui/
 src/
    app/
       layout.tsx
       page.tsx
       history/page.tsx
       error.tsx
       loading.tsx
       globals.css
       api/v1/
           upload/route.ts
           process/route.ts
           process/[jobId]/events/route.ts
           history/route.ts
           jobs/[id]/route.ts
           health/route.ts
    components/
       ui/
       upload/
       processing/
       results/
       history/
       layout/
       error/
    lib/
       db/prisma.ts
       redis/client.ts
       mcp/client.ts
       sse/manager.ts
       validation/
       utils/
    stores/
       documentStore.ts
       uiStore.ts
    hooks/
       useUpload.ts
       useProcess.ts
       useSSE.ts
       useDownload.ts
       useHistory.ts
    types/
        document.ts
        processing.ts
        job.ts
        errors.ts
 prisma/
    schema.prisma
    seed.ts
    migrations/
 test/
    e2e/
    a11y/
    fixtures/
 scripts/
 public/
 .env.development
 .env.example
 next.config.ts
 tailwind.config.ts
 tsconfig.json
 vitest.config.ts
 playwright.config.ts
 package.json
```

---

## Document Control

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0.0 | 2025-12-11 | Alex Rivera | Initial comprehensive specification |
| 1.1.0 | 2025-12-12 | Alex Rivera | Addressed all Critical and Major issues from review |
| 1.2.0 | 2025-12-12 | Alex Rivera | Addressed remaining Minor issues from complete consolidated review |

---

**Cross-References**:
- Charter: `project/0.0-charter/0.1-hx-docling-ui-charter.md` v0.7.0
- Solution Architecture: `project/0.2-architecture/0.2.1-solution-architecture.md` v2.1.0
- Agentic Patterns: `project/0.2-architecture/0.2.2-agentic-patterns.md` v2.1.0
- Consolidated Gaps Review: `project/0.3-specification/reviews/consolidated-gaps-issues.md`

---

## 13. Changelog

### Version 1.2.1 (2025-12-12)

**Summary**: This patch release fixes a defect (DEF-013) where the retry attempt count was mismatched between the code example and the state machine definition.

#### Defect Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| DEF-013 | Retry attempt count mismatch between code and state machine | Fixed `executeWithRetry` function to use two-phase structure (initial attempt + retry loop) with `maxRetries: 3` instead of `maxAttempts: 3`, ensuring 4 total attempts (PROCESSING + RETRY_1 + RETRY_2 + RETRY_3) as defined in the state machine. Updated SSE event format to use `maxRetries` for clarity. | FR-803 |

#### Technical Changes

1. **RETRY_CONFIG**: Changed from `maxAttempts: 3` to `maxRetries: 3` with clarifying comment "3 retries after initial attempt (4 total)"
2. **executeWithRetry function**: Restructured to two-phase approach:
   - Phase 1: Initial attempt in PROCESSING state
   - Phase 2: Retry loop (RETRY_1, RETRY_2, RETRY_3) only entered on retryable failures
3. **Retry SSE Event**: Changed `maxAttempts` field to `maxRetries` for semantic clarity
4. **Loop alignment**: Retry index now correctly maps to state names (retry 0 = RETRY_1, retry 1 = RETRY_2, retry 2 = RETRY_3)

#### Rationale

The previous implementation had `maxAttempts: 3` with a single loop starting at attempt 0, which meant:
- Only 3 total attempts (0, 1, 2)
- `backoffMs[2]` (4000ms) was never accessed
- Loop indices did not align with RETRY_1/2/3 state names
- Inconsistent with AC-803.1 ("Max 3 retry attempts" meaning 3 retries after initial)

The fix aligns the code with:
- State machine definition (PROCESSING + RETRY_1 + RETRY_2 + RETRY_3 = 4 total attempts)
- AC-803.1 acceptance criteria (3 retry attempts after initial)
- AC-803.2 exponential backoff (all three delays 1s, 2s, 4s now used)

---

### Version 1.1.0 (2025-12-12)

**Summary**: This release addresses all 23 Critical and 46 Major issues identified during the comprehensive specification review by the 11-person review team.

#### Critical Issues Resolved (23)

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| CRI-01 | Missing job cancellation specification | Added FR-406 with full cancellation flow, POST /api/v1/jobs/{id}/cancel endpoint, AbortController integration, CANCELLED status | 2.4, 4.3.1, 5.1 |
| CRI-02 | Missing MCP `initialized` notification | Added required `notifications/initialized` notification after initialize response | 7.1.2 |
| CRI-03 | Missing MCP to App error code mapping | Added Section 7.1.4 with complete JSON-RPC to App error mapping | 7.1.4 |
| CRI-04 | Fixed window rate limiting (not sliding) | Changed to sliding window algorithm per Charter 8.1.1 | 7.4.2 |
| CRI-05 | Missing Redis circuit breaker | Added Section 7.4.3 with full circuit breaker implementation | 7.4.3 |
| CRI-06 | Missing Redis TLS configuration | Added TLS config with CA cert validation in 7.4.1 | 7.4.1 |
| CRI-07 | Rate limiting race condition | Added Lua script for atomic sliding window operation | 7.4.2 |
| CRI-08 | Missing checkpoint data schema | Added Section 5.5 with complete Checkpoint schema and Resume endpoint | 5.5 |
| CRI-09 | Missing SSE Event ID format | Added Section 4.4.1 with event ID format and buffering | 4.4.1 |
| CRI-10 | Missing browser refresh recovery | Added useJobRecovery hook and updated DocumentStore persistence | 5.3 |
| CRI-11 | Architecture documentation confusing | Added Section 7.0 clarifying two communication patterns | 7.0 |
| CRI-12 | PgBouncer port clarity | Added explicit port 6432 vs 5432 comments in DATABASE_URL | 7.3.2, Appendix B |
| CRI-13 | directUrl for migrations | Added DIRECT_DATABASE_URL with port 5432 for migrations | 7.3.2, Appendix B |
| CRI-14 | SSL cert validation missing | Added sslrootcert parameter to connection strings | 7.3.2, Appendix B |
| CRI-15 | MCP transport confusion | Clarified HTTP/JSON-RPC transport, NOT SSE | 7.0.1 |
| CRI-16 | Missing retry SSE event | Added `retry` event type with attempt/nextRetryMs | 4.4, FR-803 |
| CRI-17 | Missing state_sync jobStatus | Added jobStatus field to state_sync event | 4.4 |
| CRI-18 | CANCELLED status missing | Added CANCELLED to JobStatus enum | 5.1, 5.3 |
| CRI-19 | Missing 404 for job endpoints | Added 404 E501 to cancel, resume endpoints | 4.3.1, 5.5 |
| CRI-20 | Progress format incorrect | Fixed MCP progress format documentation | 7.1 |
| CRI-21 | Missing retry mechanism details | Added complete retry implementation in FR-803 | FR-803 |
| CRI-22 | Session recovery incomplete | Added comprehensive recovery flow with all job statuses | 5.3 |
| CRI-23 | Missing error recovery for Redis | Added circuit breaker fallback strategies | 7.4.3 |

#### Major Issues Resolved (46)

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-01 | Missing dark mode implementation | Added Section 6.0 with full dark mode spec | 6.0 |
| MAJ-02 | Incomplete Badge variant mapping | Added STATUS_BADGE_CONFIG with all status variants | 6.2.3 |
| MAJ-03 | Missing Skeleton loading states | Added ResultsSkeleton with aria-busy | 6.2.4 |
| MAJ-04 | Missing UploadZone styling | Added cn() pattern with all states | 6.2.1 |
| MAJ-05 | Missing Location header for 201 | Added Location header to upload response | 4.2 |
| MAJ-06 | Wrong error code for 409 | Changed to E701/E702 for conflict states | 4.3, 4.3.1 |
| MAJ-07 | Missing status sort order | Added STATUS_SORT_ORDER constant | 4.5 |
| MAJ-08 | Missing Form component integration | Added shadcn/ui Form pattern for UrlInput | 6.2.2 |
| MAJ-09 | Missing MCP server authentication | Added MCPAuthConfig with auth types | 7.1.1 |
| MAJ-10 | Missing keyboard shortcuts for tabs | Added Ctrl+Shift+1-4 tab shortcuts | 6.2.4 |
| MAJ-11 | Missing security testing specs | Added Section 10.1.1 with security tests | 10.1.1 |
| MAJ-12 | activeJobId should be array | Changed to activeJobIds[] for multiple tabs | 5.4, 7.4.5 |
| MAJ-13 | Missing OWASP coverage | Added OWASP Top 10 coverage table | 10.1.1 |
| MAJ-14 | Circuit breaker state storage | Added in-memory state in RedisCircuitBreaker | 7.4.3 |
| MAJ-15 | Missing RETRY state transitions | Added complete state transition table | FR-803 |
| MAJ-16 | DoclingDocument validation too loose | Added explicit DoclingDocumentSchema | 7.1.3 |
| MAJ-17 | Environment variable units unclear | Added explicit _MS, _SECONDS suffixes | Appendix B |
| MAJ-18 | Missing Lucide icon imports | Added Appendix B.1 with centralized imports | Appendix B.1 |
| MAJ-19 | Missing X-Request-ID header | Added to upload response headers | 4.2 |
| MAJ-20 | Missing SSRF test cases | Added comprehensive SSRF test suite | 10.1.1 |
| MAJ-21 | Missing pagination validation | Added paginationSchema with Zod | 4.5 |
| MAJ-22-46 | Various minor specification gaps | Addressed throughout document | Various |

#### Files Modified

- `project/0.3-specification/0.3.1-detailed-specification.md` - This document

#### Review Reference

All changes are in response to issues documented in:
`project/0.3-specification/reviews/consolidated-gaps-issues.md`

Review conducted by: Neo Martinez, Trinity Chen, James Wilson, William Chen, Julia Santos, Ola Okonkwo, Gordon Freeman, Sri Patel, George Thompson, Bob Anderson, Sophia Davis

### Version 1.2.0 (2025-12-12)

**Summary**: This release addresses the remaining Minor issues identified in the complete consolidated review document, bringing the specification to production-ready completeness.

#### Database/Infrastructure Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-DB-001 | Missing database startup validation | Added Section 5.1.1 with `validateDatabaseConnection()` and `ensureDatabaseConnection()` | 5.1.1 |
| MAJ-DB-002 | Missing job status state machine diagram | Added Section 5.1.2 with Mermaid state diagram, state definitions, and transition validation | 5.1.2 |
| MAJ-DB-003 | Missing connection pool sizing rationale | Added Section 5.1.3 with pool size calculation and environment-specific recommendations | 5.1.3 |
| MAJ-DB-005 | Missing result size validation | Added Section 5.1.4 with `validateResultSize()` before database insertion | 5.1.4 |

#### MCP Integration Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-MCP-001 | MCP version not configurable | Added Section 7.1.1.1 with `MCP_PROTOCOL_VERSION` environment variable | 7.1.1.1 |
| MAJ-MCP-002 | Missing server capabilities validation | Added Section 7.1.1.2 with `validateServerCapabilities()` and capability storage | 7.1.1.2 |
| MAJ-MCP-003 | Transport configuration ambiguity | Added Section 7.1.1.3 clarifying HTTP/JSON-RPC vs application SSE | 7.1.1.3 |

#### API Design Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-API-001 | Missing API conventions documentation | Added Section 4.8 with request/response patterns, headers, standard envelope | 4.8 |
| MAJ-API-002 | Missing API versioning strategy | Added Section 4.9 with URL versioning, deprecation policy | 4.9 |
| MAJ-API-003 | Missing content negotiation | Added Section 4.10 with Accept header handling, download content types | 4.10 |
| MAJ-API-004 | Missing centralized validation middleware | Added Section 4.11 with `withValidation()` middleware | 4.11 |
| MAJ-API-005 | Missing idempotency support | Added Section 4.12 with `Idempotency-Key` header handling | 4.12 |

#### Frontend/UI Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-UI-001 | Missing responsive design breakpoints | Added Section 6.2.6 with Tailwind breakpoints, component behavior matrix | 6.2.6 |
| MAJ-UI-005 | Tab preloading strategy undefined | Added Section 6.2.11 with eager/lazy rendering configuration | 6.2.11 |
| MAJ-UI-006 | Missing code splitting strategy | Added Section 6.2.7 with dynamic imports, bundle size targets | 6.2.7 |
| MAJ-UI-007 | Form validation timing unclear | Added Section 6.2.8 with onBlur/onChange validation rules | 6.2.8 |
| MAJ-UI-008 | Optimistic UI rollback undefined | Added Section 6.2.9 with rollback pattern and test scenarios | 6.2.9 |
| MAJ-UI-009 | SSE out-of-order handling | Added Section 6.2.10 with event ordering and deduplication | 6.2.10 |

#### Testing Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-TEST-001 | Missing URL validation test matrix | Added Section 10.8 with comprehensive SSRF, format, edge case tests | 10.8 |
| MAJ-TEST-002 | Integration tests missing DB assertions | Added Section 10.9 with database state verification patterns | 10.9 |
| MAJ-TEST-003 | Missing dynamic content a11y tests | Added Section 10.10 with progress announcements, focus management tests | 10.10 |
| MAJ-TEST-004 | Missing test fixtures specification | Added Section 10.7 with fixture directory structure, characteristics | 10.7 |
| MAJ-MCP-TEST | Missing MCP mock handlers | Added Section 10.11 with MSW handlers for MCP scenarios | 10.11 |

#### Accessibility Minor Issues Resolved

| ID | Issue | Resolution | Section |
|----|-------|------------|---------|
| MAJ-A11Y-001 | Missing announcement debouncing strategy | Added Section 9.4 with `useA11yAnnouncer` hook, timing rules | 9.4 |
| MAJ-A11Y-002 | Missing focus management patterns | Added Section 9.5 with focus restoration rules, modal trap | 9.5 |
| MAJ-A11Y-003 | Missing color contrast validation | Added Section 9.6 with contrast requirements, testing approach | 9.6 |
| MAJ-A11Y-004 | Missing reduced motion support | Added Section 9.7 with `useReducedMotion` hook, CSS implementation | 9.7 |

#### New Sections Added

1. **Section 5.1.1-5.1.4**: Database connection validation, state machine, pool configuration, result validation
2. **Section 7.1.1.1-7.1.1.3**: MCP version configuration, capabilities validation, transport clarification
3. **Section 4.8-4.12**: API conventions, versioning, content negotiation, validation middleware, idempotency
4. **Section 6.2.6-6.2.11**: Responsive design, code splitting, form validation, optimistic UI, SSE ordering, tab preloading
5. **Section 9.4-9.7**: Screen reader announcements, focus management, color contrast, reduced motion
6. **Section 10.7-10.11**: Test fixtures, URL validation matrix, DB integration tests, dynamic a11y tests, MCP mocks

#### Files Modified

- `project/0.3-specification/0.3.1-detailed-specification.md` - This document

#### Review Reference

All changes are in response to Minor issues documented in:
`project/0.3-specification/reviews/complete-consolidated-review.md`

#### Specification Status

With this update, the specification is now **COMPLETE** and **READY FOR IMPLEMENTATION**:
- All 23 Critical issues: RESOLVED (v1.1.0)
- All 46 Major issues: RESOLVED (v1.1.0)
- All 99 Minor issues: RESOLVED or documented as implementation-time decisions (v1.2.0)

The specification now comprehensively covers all aspects required for implementation:
- Functional requirements
- Data models and database schema
- API specifications
- MCP integration patterns
- Frontend component specifications
- Security specifications
- Accessibility specifications
- Testing specifications
- Quality gates and acceptance criteria
